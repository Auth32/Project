/// <reference types="node" />

import { BaseProviderOptions } from '@metamask/providers/dist/BaseProvider';
import { CedeExposedErrors } from '@cede/utils';
import { Duplex } from 'stream';
import { JsonRpcConnection } from '@metamask/providers/dist/BaseProvider';
import { JsonRpcEngine } from 'json-rpc-engine';
import SafeEventEmitter from '@metamask/safe-event-emitter';

declare type AccountId = string;

declare interface AccountSettings {
    hiddenTokens: PortfolioToken[]; // TODO: We don't need to save as much data here
}

declare type ActiveVaultMethod = () => Promise<VaultId>;

declare type AddCexMethod = (params: AddCexParams) => Promise<Result>;

declare type AddCexParams = {
    exchangeId?: string;
};

declare type AddressBookItem = {
    address: string;
    name: string;
    id: string;
};

declare type Any = any;

declare enum ApiPermissions {
    TRADE = "trade",
    READ = "read",
    WITHDRAW = "withdraw",
}

declare type BalancesMethod = (params: BalancesParams) => Promise<GroupedBalancesByAccount>;

declare type BalancesParams = {
    vaultId: VaultId;
    accountId?: AccountId[];
    walletTypes?: WalletType[];
    opts?: {
        forceRefresh?: boolean;
    };
};

declare interface BaseProviderState {
    vaultPreviews: null | VaultItem[];
    isConnected: boolean;
    isUnlocked: boolean;
}

declare type CancelOrderMethod = (params: CancelOrderParams) => Promise<CancelOrderStatus>;

declare type CancelOrderParams = {
    accountId: AccountId;
    orderId: OrderId;
    pairSymbol: PairSymbol;
};

declare enum CancelOrderStatus {
    CANCELED = "canceled",
    ALREADY_FILLED = "already_filled",
}

export declare const CedeErrors: CedeExposedErrors;

declare type CedeEvents = "connect" | "disconnect" | "accountsChanged" | "lock" | "unlock";

export declare class CedeProvider {
    private inpageProvider;
    constructor(inpageProvider: InpageProvider);
    request: <T extends keyof UntrustedApi>(args: RequestArguments<T>) => Promise<UntrustedApiReturn[T]>;
    on: (event: CedeEvents, listener: (...args: unknown[]) => void) => this;
    once: (event: CedeEvents, callback: (...args: unknown[]) => void) => this;
    off: (event: CedeEvents, callback: (...args: unknown[]) => void) => this;
    removeListener: (event: CedeEvents, callback: (...args: unknown[]) => void) => this;
    removeAllListeners: (event?: CedeEvents) => this;
    emit: (event: CedeEvents, ...args: unknown[]) => boolean;
    getVaultPreviews: () => VaultItem[] | null;
    getIsUnlocked: () => boolean;
    getActiveVault: () => VaultItem | undefined;
}

declare type CefiInfoTx = {
    account: {
        exchangeId: string;
        accountId: AccountId;
        network?: string;
    };
    wallet: {
        depositAddress: string;
        walletType: WalletType;
    };
    transaction: CefiTx;
};

declare type CefiTx = {
    amount: number;
    refAmount?: number;
    tokenSymbol: TokenSymbol;
    transactionId: string;
    fee: Fee;
    status: TxStatus;
    timestamp: number;
};

declare type CheckAddressIsWhitelistedMethod = (params: {
    accountId: AccountId;
    addressName: string;
    address: string;
    currency: string;
}) => Promise<boolean>;

declare enum ConnectionStatus {
    ONLINE = "online",
    OFFLINE = "offline",
    NOT_GOOD = "notGood",
    RECONNECTION_REQUIRED = "reconnectionRequired",
}

declare type ConnectMethod = (params?: ConnectParams) => Promise<VaultItem[]>;

declare type ConnectParams = {
    onboard: boolean;
    silent?: boolean;
};

declare type CreateOrderMethod = (params: CreateOrderParams) => Promise<Order>;

declare type CreateOrderParams = {
    accountId: AccountId;
    pairSymbol: PairSymbol;
    orderSide: OrderSide;
    orderType: OrderType;
    amount: string;
    price: string;
};

declare type CreateOrderRequest = {
    pairSymbol: PairSymbol;
    orderSide: OrderSide;
    orderType: OrderType;
    price: string; // price from the ticker (base to quote).
    amount: string; // the amount in base currency
};

declare type DefiInfoTx = {
    account: {
        address: string;
        network: InternalChainId;
        networkLabel?: string;
    };
    transaction: {
        transactionHash: string;
        fee: Fee;
        status: TxStatus;
        timestamp: number;
        tokens: {
            amount: number;
            refAmount?: number;
            tokenSymbol: TokenSymbol;
            address: string; //  why do we need an address here? I think we should remove it
        }[];
    };
};

declare type DepositableToken = {
    tokenSymbol: TokenSymbol;
    networks?: MarketNetwork[];
};

declare type DepositableTokensMethod = (params: DepositableTokensParams) => Promise<DepositableToken[]>;

declare type DepositableTokensParams = {
    accountId: AccountId;
};

declare type DepositAddress = {
    tokenSymbol: TokenSymbol;
    address: string;
    network: InternalChainId;
    /**
     * @description
     * A tag or memo is a unique identifier assigned to each account
     * for identifying a deposit and crediting the appropriate account.
     *
     * Some exchanges require a tag or memo to be included with the deposit
     * for some tokens, such as BNB or ATOM
     */
    tag?: string;
};

declare type DepositMethod = (params: DepositParams) => Promise<DepositAddress>;

declare type DepositParams = {
    accountId: AccountId;
    tokenSymbol: TokenSymbol;
    network: InternalChainId;
};

export declare function detectCedeProvider(timeout?: number): Promise<CedeProvider | null>;

declare type DisconnectMethod = () => Promise<Result>;

declare type EditOrderMethod = (params: EditOrderParams) => Promise<Order>;

declare type EditOrderParams = {
    accountId: AccountId;
    orderId: OrderId;
    pairSymbol: PairSymbol;
    orderSide?: OrderSide;
    orderType?: OrderType;
    price?: string;
    amount?: string;
};

declare type EstimatedFee = Fee;

declare type EstimatedFeeAndAmount = {
    estimatedFee: EstimatedFee;
    estimatedAmount: string; // in base currency
};

declare type ExchangeInfo = {
    name: string;
    id: string;
    logo: string;
    status: ExchangeStatus | "unknown";
    supportedWalletTypes: string[];
    supportedFeatures: string[];
    auhenticationMethod: "oauth" | "apiKeys";
    isRequiringEmailConfirmation: boolean;
    minimumWithdrawalUrl?: string;
    isRequiringAddressWhitelisting: boolean;
    shouldCheckWhitelist: boolean;
    requireTwoKeys: boolean;
    ipWhitelistAddresses: string[];
};

declare enum ExchangeStatus {
    Ok = "ok",
    Shutdown = "shutdown",
    Error = "error",
    Maintenance = "maintenance",
}

declare type Fee = {
    amount: number; // amount (not percentage) of crypto taken as fee
    refAmount?: number;
    tokenSymbol: TokenSymbol; // crypto token involved in the taken fee
};

declare type FiatCurrency = {
    symbol: string;
    rate?: number;
};

declare type GetAddressBookMethod = () => Promise<AddressBookItem[]>;

declare type GetMarketRateMethod = (params: MarketRateParams) => Promise<MarketRate>;

declare type GetMinAmountsMethod = (params: GetMinAmountsParams) => Promise<MinAmounts>;

declare type GetMinAmountsParams = {
    accountId: AccountId;
    pairSymbol: PairSymbol;
    orderSide: OrderSide;
    price: string;
};

declare type GetNetworksMethod = (params: GetNetworksParams) => Promise<MarketNetwork[]>;

declare type GetNetworksParams = {
    accountId: AccountId;
    tokenSymbol: TokenSymbol;
    opts: {
        toDeposit?: boolean;
        toWithdraw?: boolean;
    };
};

declare type GetPricesMethod = () => Promise<PricesByTokenSymbol>;

declare type GetSettingsMethod = () => Promise<UserSettings>;

declare type GetWithdrawalByIdMethod = (params: GetWithdrawalByIdParams) => Promise<Transaction>;

declare type GetWithdrawalByIdParams = {
    accountId: string;
    withdrawalId: string;
    tokenSymbol: string;
    timestamp: number;
};

declare type GroupedBalances = {
    [tokenSymbol: string]: TokenBalance;
};

declare type GroupedBalancesByAccount = {
    [accountId: AccountId]: GroupedBalancesByWalletType;
};

declare type GroupedBalancesByWalletType = {
    [tokenSymbol: TokenSymbol]: TokenBalanceTypes & {
        [type in WalletType]?: TokenBalanceTypes;
    };
};

export declare class InpageProvider extends SafeEventEmitter {
    protected _state: BaseProviderState;
    protected _rpcEngine: JsonRpcEngine;
    protected _jsonRpcConnection: JsonRpcConnection;
    protected _connectionStream: Duplex;
    protected static _defaultState: BaseProviderState;
    constructor(connectionStream: Duplex, { jsonRpcStreamName, maxEventListeners }?: BaseProviderOptions);
    /**
     * Called when connection is lost to critical streams.
     *
     * @emits InpageProvider#disconnect
     */
    protected _handleStreamDisconnect(streamName: string, error: Error): void;
    /**
     * Internal RPC method. Forwards requests to background via the RPC engine.
     * Also remap ids inbound and outbound.
     *
     * @param payload - The RPC request object.
     */
    request: (args: any) => Promise<unknown>;
    /**
     * When the provider becomes connected, updates internal state and emits
     * required events. Idempotent.
     *
     * @emits connect event
     */
    protected _connectionEstablished(): void;
    protected _updateVaults(vaultPreviews: {
        vaultsPreview: VaultItem[];
    }): Promise<void>;
    protected _unlock(): void;
    protected _lock(): void;
    protected getNotificationApi(): {
        connect: () => void;
        accountsChanged: (vaultPreviews: {
            vaultsPreview: VaultItem[];
        }) => Promise<void>;
        unlock: () => void;
        lock: () => void;
    };
    protected executeMethod<T extends InpageProviderApiMethods>(method: InpageProviderApiMethods, ...params: Any[]): ReturnType<InpageProviderApi[T]>;
    getIsUnlocked(): boolean;
    /** Returns vaultPreview */
    getVaultPreviews(): VaultItem[] | null;
    getActiveVault(): VaultItem | undefined;
}

declare type InpageProviderApi = ReturnType<InpageProvider["getNotificationApi"]>;

declare type InpageProviderApiMethods = keyof InpageProviderApi;

declare type InternalChainId = string;

declare type KrakenWithdrawalPrepareReturn = { fee: Fee; method: string };

export declare type LatestVersion = typeof latestVersion;

declare const latestVersion: {
    connect: RequestVersion.V2;
    disconnect: RequestVersion.V1;
    vaults: RequestVersion.V1;
    vaultAccounts: RequestVersion.V1;
    supportedExchanges: RequestVersion.V1;
    getWithdrawalById: RequestVersion.V2;
    transactions: RequestVersion.V2;
    balances: RequestVersion.V3;
    nfts: RequestVersion.V2;
    openOrders: RequestVersion.V2;
    retrieveOrder: RequestVersion.V2;
    editOrder: RequestVersion.V2;
    getMinAmounts: RequestVersion.V2;
    createOrder: RequestVersion.V2;
    prepareOrder: RequestVersion.V2;
    getMarketPairs: RequestVersion.V2;
    getMarketRate: RequestVersion.V2;
    tickers: RequestVersion.V1;
    tokens: RequestVersion.V1;
    activeVault: RequestVersion.V1;
    depositableTokens: RequestVersion.V2;
    getNetworks: RequestVersion.V2;
    deposit: RequestVersion.V2;
    cancelOrder: RequestVersion.V2;
    addCex: RequestVersion.V2;
    withdrawToDefi: RequestVersion.V2;
    withdrawableTokens: RequestVersion.V2;
    getPrices: RequestVersion.V1;
    prepareWithdrawal: RequestVersion.V2;
    getSettings: RequestVersion.V1;
    getAddressBook: RequestVersion.V1;
    checkAddressIsWhitelisted: RequestVersion.V1;
};

declare type MarketNetwork = {
    name: string;
    network: string;
    withdrawFee?: string;
    withdrawMax?: string;
    withdrawMin?: string;
    withdrawalEnabled: boolean;
    depositEnabled: boolean;
    chainId?: number; // chain id in decimal format
};

declare type MarketPair = {
    pairSymbol: PairSymbol;
    base: TokenSymbol;
    quote: TokenSymbol;
    type: WalletType;
    taker: number;
    maker: number;
    active: boolean;
    precision: {
        amount: number;
        price: number;
        base: number;
        quote: number;
    };
    limits: {
        amount: {
            min: number;
            max: number;
        };
        price: {
            min: number;
            max: number;
        };
        cost: {
            min: number;
        };
        // market: {
        //   min: number;
        //   max: number;
        // };
    };
};

declare type MarketPairsMethod = (params: MarketPairsParams) => Promise<MarketPair[]>;

declare type MarketPairsParams = {
    accountId: AccountId;
};

declare type MarketRate = {
    bid: string;
    ask: string;
};

declare type MarketRateParams = {
    accountId: AccountId;
    pairSymbol: PairSymbol;
};

declare type MinAmounts = {
    minBaseAmount: string;
    minQuoteAmount: string;
    minPrice: string;
};

declare type Nft = {
    data?: {
        name: string;
        description: string;
        imageUrl: string;
        animationUrl?: string;
        attributes: Record<string, string | number>;
        collection: {
            name: string;
            imageUrl: string;
            creator: string;
        };
    };
    amount?: number;
    tokenId: string;
    tokenAddress: string;
    owner?: string;
    network: InternalChainId;
};

declare type NftsMethod = (params: NftsParams) => Promise<{ nfts: Nft[]; total: number }>;

declare type NftsParams = {
    accountId: AccountId;
};

declare type OpenOrdersMethod = (params: OpenOrdersParams) => Promise<Order[]>;

declare type OpenOrdersParams = {
    accountId: AccountId;
    pairSymbol: PairSymbol;
    since?: number;
    limit?: number;
};

declare type Order = {
    id: OrderId;
    timestamp: number;
    status: OrderStatus;
    pairSymbol: PairSymbol;
    type: OrderType;
    side: OrderSide;
    price: number;
    amount: number;
    filled: number;
    fee: Fee;
};

declare type OrderId = string;

declare type OrderSide = "buy" | "sell";

declare enum OrderStatus {
    OPEN = "open",
    CLOSED = "closed",
    CANCELED = "canceled",
    UNKNOWN = "unknown",
}

declare enum OrderType {
    LIMIT = "limit",
    MARKET = "market",
    UNKNOWN = "unknown",
}

declare type PairSymbol = string;

declare type PortfolioToken = {
    token: string;
    balancesByAccount: PortfolioTokenByAccount[];
} & TokenBalance;

declare type PortfolioTokenByAccount = {
    accountName: string;
    exchangeId: string;
    walletTypes: {
        [type in WalletType]?: TokenBalance;
    };
} & TokenBalance;

declare type PreparedOrder = EstimatedFeeAndAmount & {
    createOrderRequest: CreateOrderRequest;
};

declare type PrepareOrderMethod = (params: CreateOrderParams) => Promise<PreparedOrder>;

declare type PrepareWithdrawalMethod = (
params: PrepareWithdrawalParams,
) => Promise<"success" | KrakenWithdrawalPrepareReturn>;

declare type PrepareWithdrawalParams = {
    accountId: AccountId;
    tokenSymbol: TokenSymbol;
    amount: number;
    address?: string;
    opts?: {
        key?: string;
    };
};

declare type PricesByTokenSymbol = {
    [tokenSymbol: TokenSymbol]: number;
};

export declare const PROVIDER = "cede-provider";

/**
 * @description Public account data, that can be exposed to the UI and to the dApp.
 *
 * It's important to keep parentVault property out of this type, because it's a circular dependency,
 * and most importantly, it exposes the private vault data.
 */
declare type PublicAccount = {
    id: AccountId;
    status: ConnectionStatus;
    accountName: string;
    exchangeId: string;
    permissions: ApiPermissions[];
    settings?: AccountSettings;
    isOauth?: boolean;
    isFastApi?: boolean;
};

declare type RequestArguments<K extends UntrustedApiMethods> = UntrustedApiParams[K] extends undefined
? { method: K }
: undefined extends UntrustedApiParams[K]
? { method: K; params?: UntrustedApiParams[K] }
: { method: K; params: UntrustedApiParams[K] };

export declare enum RequestVersion {
    V1 = 1,
    V2 = 2,
    V3 = 3
}

declare type Result = "success" | "error";

declare type RetrieveOrderMethod = (params: RetrieveOrderParams) => Promise<Order>;

declare type RetrieveOrderParams = {
    accountId: AccountId;
    orderId: string;
    pairSymbol: PairSymbol;
};

declare type SupportedExchangesMethod = () => Promise<ExchangeInfo[]>;

declare type TokenBalance = {
    tokenName?: string;
    totalBalance: number;
    refTotalBalance: number;
    freeBalance: number;
    refFreeBalance: number;
};

declare type TokenBalanceTypes = {
    tokenName?: string;
    freeBalance: number;
    refFreeBalance: number;
    usedBalance: number;
    refUsedBalance: number;
    totalBalance: number;
    refTotalBalance: number;
};

declare type TokenSymbol = string;

declare type Transaction<
F extends CefiInfoTx | DefiInfoTx = CefiInfoTx | DefiInfoTx,
T extends CefiInfoTx | DefiInfoTx = CefiInfoTx | DefiInfoTx,
> = {
    from: F;
    to: T;
    type: TxType;
    pairSymbol?: string; // Only for trades
};

declare type TransactionsMethod = (params: TransactionsParams) => Promise<Transaction[]>;

declare type TransactionsParams = {
    vaultId: VaultId;
    accountIds?: AccountId[];
    tokenSymbol?: TokenSymbol;
    txType?: string;
    startTime?: number;
    pageCount?: number;
    pageIndex?: number;
    includeTemp?: boolean;
};

declare enum TxStatus {
    PENDING = "pending",
    OK = "ok",
    CANCELLED = "cancelled",
    FAILED = "failed",
}

declare type TxType = "transfer" | "swap" | "deposit" | "withdrawal" | "order";

declare interface UntrustedApi {
    connect: ConnectMethod;
    disconnect: DisconnectMethod;
    vaults: VaultsMethod;
    vaultAccounts: VaultAccountsMethod;
    supportedExchanges: SupportedExchangesMethod;
    getWithdrawalById: GetWithdrawalByIdMethod;
    transactions: TransactionsMethod;
    balances: BalancesMethod;
    nfts: NftsMethod;
    openOrders: OpenOrdersMethod;
    retrieveOrder: RetrieveOrderMethod;
    editOrder: EditOrderMethod;
    getMinAmounts: GetMinAmountsMethod;
    createOrder: CreateOrderMethod;
    prepareOrder: PrepareOrderMethod;
    getMarketPairs: MarketPairsMethod;
    getMarketRate: GetMarketRateMethod;
    activeVault: ActiveVaultMethod;
    depositableTokens: DepositableTokensMethod;
    getNetworks: GetNetworksMethod;
    deposit: DepositMethod;
    cancelOrder: CancelOrderMethod;
    addCex: AddCexMethod;
    withdrawToDefi: WithdrawToDefiMethod;
    prepareWithdrawal: PrepareWithdrawalMethod;
    withdrawableTokens: WithdrawableTokensMethod;
    getPrices: GetPricesMethod;
    getSettings: GetSettingsMethod;
    getAddressBook: GetAddressBookMethod;
    checkAddressIsWhitelisted: CheckAddressIsWhitelistedMethod;
}

declare type UntrustedApiMethods = keyof UntrustedApi;

declare type UntrustedApiParams = {
    [key in UntrustedApiMethods]: Parameters<UntrustedApi[key]>[0];
};

declare type UntrustedApiReturn = {
    [key in UntrustedApiMethods]: Awaited<ReturnType<UntrustedApi[key]>>;
};

declare type UserSettings = {
    language: string;
    currency: FiatCurrency;
    balanceBelow: number;
    extensionUrl: string;
};

declare type VaultAccountsMethod = (params: VaultAccountsParams) => Promise<VaultItem>;

declare type VaultAccountsParams = {
    vaultId: VaultId;
};

declare type VaultId = string;

declare type VaultItem = {
    id: string;
    name: string;
    accounts: PublicAccount[];
    image: string;
    isActive?: boolean;
};

declare type VaultsMethod = () => Promise<VaultItem[]>;

declare enum WalletType {
    MAIN = "main",
    FUNDING = "funding",
    SPOT = "spot",
    FUTURES = "futures",
    MARGIN = "margin",
    OPTIONS = "options",
    EARN = "earn",
    BOT = "bot",
    CARD = "card",
    OTHER = "other",
}

declare type WithdrawableTokensMethod = (params: WithdrawableTokensParams) => Promise<GroupedBalances>;

declare type WithdrawableTokensParams = {
    accountId: AccountId;
};

declare type WithdrawToDefiMethod = (params: WithdrawToDefiParams) => Promise<Transaction>;

declare type WithdrawToDefiParams = {
    accountId: AccountId;
    tokenSymbol: TokenSymbol;
    network: string | number;
    amount: string;
    address: string;
    code?: string;
    withdrawalTag?: string;
};

export { }
