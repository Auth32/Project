var Xi = Object.defineProperty;
var Ki = (e, t, n) => t in e ? Xi(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var ye = (e, t, n) => (Ki(e, typeof t != "symbol" ? t + "" : t, n), n);
var Yi = /* @__PURE__ */ ((e) => (e[e.V1 = 1] = "V1", e[e.V2 = 2] = "V2", e[e.V3 = 3] = "V3", e))(Yi || {});
const Zi = {
  connect: 2,
  disconnect: 1,
  vaults: 1,
  vaultAccounts: 1,
  supportedExchanges: 1,
  getWithdrawalById: 2,
  transactions: 2,
  balances: 3,
  nfts: 2,
  openOrders: 2,
  retrieveOrder: 2,
  editOrder: 2,
  getMinAmounts: 2,
  createOrder: 2,
  prepareOrder: 2,
  getMarketPairs: 2,
  getMarketRate: 2,
  tickers: 1,
  tokens: 1,
  activeVault: 1,
  depositableTokens: 2,
  getNetworks: 2,
  deposit: 2,
  cancelOrder: 2,
  addCex: 2,
  withdrawToDefi: 2,
  withdrawableTokens: 2,
  getPrices: 1,
  prepareWithdrawal: 2,
  getSettings: 1,
  getAddressBook: 1,
  checkAddressIsWhitelisted: 1
  /* V1 */
};
class en {
  constructor(t) {
    ye(this, "inpageProvider");
    ye(this, "request", async (t) => {
      const s = Zi[t.method] ?? -1, u = t;
      return u.params ? u.params = { ...u.params, version: s } : u.params = { version: s }, this.inpageProvider.request(u);
    });
    ye(this, "on", (t, n) => (this.inpageProvider.on(t, n), this));
    ye(this, "once", (t, n) => (this.inpageProvider.on(t, n), this));
    ye(this, "off", (t, n) => (this.inpageProvider.off(t, n), this));
    ye(this, "removeListener", (t, n) => (this.inpageProvider.removeListener(t, n), this));
    ye(this, "removeAllListeners", (t) => (this.inpageProvider.removeAllListeners(t), this));
    ye(this, "emit", (t, ...n) => this.inpageProvider.emit(t, ...n));
    ye(this, "getVaultPreviews", () => this.inpageProvider.getVaultPreviews());
    ye(this, "getIsUnlocked", () => this.inpageProvider.getIsUnlocked());
    ye(this, "getActiveVault", () => this.inpageProvider.getActiveVault());
    this.inpageProvider = t;
  }
}
function wu(e = 3e3) {
  let t = !1;
  return new Promise((n) => {
    window.cede ? s() : (window.addEventListener("cede#initialized", s, {
      once: !0
    }), setTimeout(() => {
      s();
    }, e));
    function s() {
      if (t) {
        const d = window.cede, l = new en(d);
        n(l);
        return;
      }
      t = !0, window.removeEventListener("cede#initialized", s);
      const { cede: u } = window;
      if (u) {
        const d = window.cede, l = new en(d);
        n(l);
      } else
        n(null);
    }
  });
}
function Qi(e) {
  return JSON.parse(JSON.stringify(e));
}
var te = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Tn(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ut = {}, Sr = { exports: {} }, J = {}, ct = {}, Dt = {};
Dt.byteLength = ro;
Dt.toByteArray = io;
Dt.fromByteArray = so;
var ke = [], Me = [], eo = typeof Uint8Array < "u" ? Uint8Array : Array, er = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Ze = 0, to = er.length; Ze < to; ++Ze)
  ke[Ze] = er[Ze], Me[er.charCodeAt(Ze)] = Ze;
Me["-".charCodeAt(0)] = 62;
Me["_".charCodeAt(0)] = 63;
function Mn(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n = e.indexOf("=");
  n === -1 && (n = t);
  var s = n === t ? 0 : 4 - n % 4;
  return [n, s];
}
function ro(e) {
  var t = Mn(e), n = t[0], s = t[1];
  return (n + s) * 3 / 4 - s;
}
function no(e, t, n) {
  return (t + n) * 3 / 4 - n;
}
function io(e) {
  var t, n = Mn(e), s = n[0], u = n[1], d = new eo(no(e, s, u)), l = 0, f = u > 0 ? s - 4 : s, g;
  for (g = 0; g < f; g += 4)
    t = Me[e.charCodeAt(g)] << 18 | Me[e.charCodeAt(g + 1)] << 12 | Me[e.charCodeAt(g + 2)] << 6 | Me[e.charCodeAt(g + 3)], d[l++] = t >> 16 & 255, d[l++] = t >> 8 & 255, d[l++] = t & 255;
  return u === 2 && (t = Me[e.charCodeAt(g)] << 2 | Me[e.charCodeAt(g + 1)] >> 4, d[l++] = t & 255), u === 1 && (t = Me[e.charCodeAt(g)] << 10 | Me[e.charCodeAt(g + 1)] << 4 | Me[e.charCodeAt(g + 2)] >> 2, d[l++] = t >> 8 & 255, d[l++] = t & 255), d;
}
function oo(e) {
  return ke[e >> 18 & 63] + ke[e >> 12 & 63] + ke[e >> 6 & 63] + ke[e & 63];
}
function ao(e, t, n) {
  for (var s, u = [], d = t; d < n; d += 3)
    s = (e[d] << 16 & 16711680) + (e[d + 1] << 8 & 65280) + (e[d + 2] & 255), u.push(oo(s));
  return u.join("");
}
function so(e) {
  for (var t, n = e.length, s = n % 3, u = [], d = 16383, l = 0, f = n - s; l < f; l += d)
    u.push(ao(e, l, l + d > f ? f : l + d));
  return s === 1 ? (t = e[n - 1], u.push(
    ke[t >> 2] + ke[t << 4 & 63] + "=="
  )) : s === 2 && (t = (e[n - 2] << 8) + e[n - 1], u.push(
    ke[t >> 10] + ke[t >> 4 & 63] + ke[t << 2 & 63] + "="
  )), u.join("");
}
var Ur = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Ur.read = function(e, t, n, s, u) {
  var d, l, f = u * 8 - s - 1, g = (1 << f) - 1, T = g >> 1, F = -7, E = n ? u - 1 : 0, j = n ? -1 : 1, U = e[t + E];
  for (E += j, d = U & (1 << -F) - 1, U >>= -F, F += f; F > 0; d = d * 256 + e[t + E], E += j, F -= 8)
    ;
  for (l = d & (1 << -F) - 1, d >>= -F, F += s; F > 0; l = l * 256 + e[t + E], E += j, F -= 8)
    ;
  if (d === 0)
    d = 1 - T;
  else {
    if (d === g)
      return l ? NaN : (U ? -1 : 1) * (1 / 0);
    l = l + Math.pow(2, s), d = d - T;
  }
  return (U ? -1 : 1) * l * Math.pow(2, d - s);
};
Ur.write = function(e, t, n, s, u, d) {
  var l, f, g, T = d * 8 - u - 1, F = (1 << T) - 1, E = F >> 1, j = u === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, U = s ? 0 : d - 1, q = s ? 1 : -1, N = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (f = isNaN(t) ? 1 : 0, l = F) : (l = Math.floor(Math.log(t) / Math.LN2), t * (g = Math.pow(2, -l)) < 1 && (l--, g *= 2), l + E >= 1 ? t += j / g : t += j * Math.pow(2, 1 - E), t * g >= 2 && (l++, g /= 2), l + E >= F ? (f = 0, l = F) : l + E >= 1 ? (f = (t * g - 1) * Math.pow(2, u), l = l + E) : (f = t * Math.pow(2, E - 1) * Math.pow(2, u), l = 0)); u >= 8; e[n + U] = f & 255, U += q, f /= 256, u -= 8)
    ;
  for (l = l << u | f, T += u; T > 0; e[n + U] = l & 255, U += q, l /= 256, T -= 8)
    ;
  e[n + U - q] |= N * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  const t = Dt, n = Ur, s = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = f, e.SlowBuffer = R, e.INSPECT_MAX_BYTES = 50;
  const u = 2147483647;
  e.kMaxLength = u, f.TYPED_ARRAY_SUPPORT = d(), !f.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function d() {
    try {
      const c = new Uint8Array(1), r = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(c, r), c.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(f.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (f.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(f.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (f.isBuffer(this))
        return this.byteOffset;
    }
  });
  function l(c) {
    if (c > u)
      throw new RangeError('The value "' + c + '" is invalid for option "size"');
    const r = new Uint8Array(c);
    return Object.setPrototypeOf(r, f.prototype), r;
  }
  function f(c, r, i) {
    if (typeof c == "number") {
      if (typeof r == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return E(c);
    }
    return g(c, r, i);
  }
  f.poolSize = 8192;
  function g(c, r, i) {
    if (typeof c == "string")
      return j(c, r);
    if (ArrayBuffer.isView(c))
      return q(c);
    if (c == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof c
      );
    if (pe(c, ArrayBuffer) || c && pe(c.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (pe(c, SharedArrayBuffer) || c && pe(c.buffer, SharedArrayBuffer)))
      return N(c, r, i);
    if (typeof c == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const p = c.valueOf && c.valueOf();
    if (p != null && p !== c)
      return f.from(p, r, i);
    const v = Q(c);
    if (v)
      return v;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof c[Symbol.toPrimitive] == "function")
      return f.from(c[Symbol.toPrimitive]("string"), r, i);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof c
    );
  }
  f.from = function(c, r, i) {
    return g(c, r, i);
  }, Object.setPrototypeOf(f.prototype, Uint8Array.prototype), Object.setPrototypeOf(f, Uint8Array);
  function T(c) {
    if (typeof c != "number")
      throw new TypeError('"size" argument must be of type number');
    if (c < 0)
      throw new RangeError('The value "' + c + '" is invalid for option "size"');
  }
  function F(c, r, i) {
    return T(c), c <= 0 ? l(c) : r !== void 0 ? typeof i == "string" ? l(c).fill(r, i) : l(c).fill(r) : l(c);
  }
  f.alloc = function(c, r, i) {
    return F(c, r, i);
  };
  function E(c) {
    return T(c), l(c < 0 ? 0 : x(c) | 0);
  }
  f.allocUnsafe = function(c) {
    return E(c);
  }, f.allocUnsafeSlow = function(c) {
    return E(c);
  };
  function j(c, r) {
    if ((typeof r != "string" || r === "") && (r = "utf8"), !f.isEncoding(r))
      throw new TypeError("Unknown encoding: " + r);
    const i = L(c, r) | 0;
    let p = l(i);
    const v = p.write(c, r);
    return v !== i && (p = p.slice(0, v)), p;
  }
  function U(c) {
    const r = c.length < 0 ? 0 : x(c.length) | 0, i = l(r);
    for (let p = 0; p < r; p += 1)
      i[p] = c[p] & 255;
    return i;
  }
  function q(c) {
    if (pe(c, Uint8Array)) {
      const r = new Uint8Array(c);
      return N(r.buffer, r.byteOffset, r.byteLength);
    }
    return U(c);
  }
  function N(c, r, i) {
    if (r < 0 || c.byteLength < r)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (c.byteLength < r + (i || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let p;
    return r === void 0 && i === void 0 ? p = new Uint8Array(c) : i === void 0 ? p = new Uint8Array(c, r) : p = new Uint8Array(c, r, i), Object.setPrototypeOf(p, f.prototype), p;
  }
  function Q(c) {
    if (f.isBuffer(c)) {
      const r = x(c.length) | 0, i = l(r);
      return i.length === 0 || c.copy(i, 0, 0, r), i;
    }
    if (c.length !== void 0)
      return typeof c.length != "number" || be(c.length) ? l(0) : U(c);
    if (c.type === "Buffer" && Array.isArray(c.data))
      return U(c.data);
  }
  function x(c) {
    if (c >= u)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + u.toString(16) + " bytes");
    return c | 0;
  }
  function R(c) {
    return +c != c && (c = 0), f.alloc(+c);
  }
  f.isBuffer = function(r) {
    return r != null && r._isBuffer === !0 && r !== f.prototype;
  }, f.compare = function(r, i) {
    if (pe(r, Uint8Array) && (r = f.from(r, r.offset, r.byteLength)), pe(i, Uint8Array) && (i = f.from(i, i.offset, i.byteLength)), !f.isBuffer(r) || !f.isBuffer(i))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (r === i)
      return 0;
    let p = r.length, v = i.length;
    for (let S = 0, M = Math.min(p, v); S < M; ++S)
      if (r[S] !== i[S]) {
        p = r[S], v = i[S];
        break;
      }
    return p < v ? -1 : v < p ? 1 : 0;
  }, f.isEncoding = function(r) {
    switch (String(r).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, f.concat = function(r, i) {
    if (!Array.isArray(r))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (r.length === 0)
      return f.alloc(0);
    let p;
    if (i === void 0)
      for (i = 0, p = 0; p < r.length; ++p)
        i += r[p].length;
    const v = f.allocUnsafe(i);
    let S = 0;
    for (p = 0; p < r.length; ++p) {
      let M = r[p];
      if (pe(M, Uint8Array))
        S + M.length > v.length ? (f.isBuffer(M) || (M = f.from(M)), M.copy(v, S)) : Uint8Array.prototype.set.call(
          v,
          M,
          S
        );
      else if (f.isBuffer(M))
        M.copy(v, S);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      S += M.length;
    }
    return v;
  };
  function L(c, r) {
    if (f.isBuffer(c))
      return c.length;
    if (ArrayBuffer.isView(c) || pe(c, ArrayBuffer))
      return c.byteLength;
    if (typeof c != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof c
      );
    const i = c.length, p = arguments.length > 2 && arguments[2] === !0;
    if (!p && i === 0)
      return 0;
    let v = !1;
    for (; ; )
      switch (r) {
        case "ascii":
        case "latin1":
        case "binary":
          return i;
        case "utf8":
        case "utf-8":
          return Ne(c).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return i * 2;
        case "hex":
          return i >>> 1;
        case "base64":
          return xe(c).length;
        default:
          if (v)
            return p ? -1 : Ne(c).length;
          r = ("" + r).toLowerCase(), v = !0;
      }
  }
  f.byteLength = L;
  function z(c, r, i) {
    let p = !1;
    if ((r === void 0 || r < 0) && (r = 0), r > this.length || ((i === void 0 || i > this.length) && (i = this.length), i <= 0) || (i >>>= 0, r >>>= 0, i <= r))
      return "";
    for (c || (c = "utf8"); ; )
      switch (c) {
        case "hex":
          return b(this, r, i);
        case "utf8":
        case "utf-8":
          return K(this, r, i);
        case "ascii":
          return h(this, r, i);
        case "latin1":
        case "binary":
          return y(this, r, i);
        case "base64":
          return ve(this, r, i);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return P(this, r, i);
        default:
          if (p)
            throw new TypeError("Unknown encoding: " + c);
          c = (c + "").toLowerCase(), p = !0;
      }
  }
  f.prototype._isBuffer = !0;
  function V(c, r, i) {
    const p = c[r];
    c[r] = c[i], c[i] = p;
  }
  f.prototype.swap16 = function() {
    const r = this.length;
    if (r % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let i = 0; i < r; i += 2)
      V(this, i, i + 1);
    return this;
  }, f.prototype.swap32 = function() {
    const r = this.length;
    if (r % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let i = 0; i < r; i += 4)
      V(this, i, i + 3), V(this, i + 1, i + 2);
    return this;
  }, f.prototype.swap64 = function() {
    const r = this.length;
    if (r % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let i = 0; i < r; i += 8)
      V(this, i, i + 7), V(this, i + 1, i + 6), V(this, i + 2, i + 5), V(this, i + 3, i + 4);
    return this;
  }, f.prototype.toString = function() {
    const r = this.length;
    return r === 0 ? "" : arguments.length === 0 ? K(this, 0, r) : z.apply(this, arguments);
  }, f.prototype.toLocaleString = f.prototype.toString, f.prototype.equals = function(r) {
    if (!f.isBuffer(r))
      throw new TypeError("Argument must be a Buffer");
    return this === r ? !0 : f.compare(this, r) === 0;
  }, f.prototype.inspect = function() {
    let r = "";
    const i = e.INSPECT_MAX_BYTES;
    return r = this.toString("hex", 0, i).replace(/(.{2})/g, "$1 ").trim(), this.length > i && (r += " ... "), "<Buffer " + r + ">";
  }, s && (f.prototype[s] = f.prototype.inspect), f.prototype.compare = function(r, i, p, v, S) {
    if (pe(r, Uint8Array) && (r = f.from(r, r.offset, r.byteLength)), !f.isBuffer(r))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r
      );
    if (i === void 0 && (i = 0), p === void 0 && (p = r ? r.length : 0), v === void 0 && (v = 0), S === void 0 && (S = this.length), i < 0 || p > r.length || v < 0 || S > this.length)
      throw new RangeError("out of range index");
    if (v >= S && i >= p)
      return 0;
    if (v >= S)
      return -1;
    if (i >= p)
      return 1;
    if (i >>>= 0, p >>>= 0, v >>>= 0, S >>>= 0, this === r)
      return 0;
    let M = S - v, H = p - i;
    const ae = Math.min(M, H), ne = this.slice(v, S), se = r.slice(i, p);
    for (let Y = 0; Y < ae; ++Y)
      if (ne[Y] !== se[Y]) {
        M = ne[Y], H = se[Y];
        break;
      }
    return M < H ? -1 : H < M ? 1 : 0;
  };
  function Ee(c, r, i, p, v) {
    if (c.length === 0)
      return -1;
    if (typeof i == "string" ? (p = i, i = 0) : i > 2147483647 ? i = 2147483647 : i < -2147483648 && (i = -2147483648), i = +i, be(i) && (i = v ? 0 : c.length - 1), i < 0 && (i = c.length + i), i >= c.length) {
      if (v)
        return -1;
      i = c.length - 1;
    } else if (i < 0)
      if (v)
        i = 0;
      else
        return -1;
    if (typeof r == "string" && (r = f.from(r, p)), f.isBuffer(r))
      return r.length === 0 ? -1 : ie(c, r, i, p, v);
    if (typeof r == "number")
      return r = r & 255, typeof Uint8Array.prototype.indexOf == "function" ? v ? Uint8Array.prototype.indexOf.call(c, r, i) : Uint8Array.prototype.lastIndexOf.call(c, r, i) : ie(c, [r], i, p, v);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ie(c, r, i, p, v) {
    let S = 1, M = c.length, H = r.length;
    if (p !== void 0 && (p = String(p).toLowerCase(), p === "ucs2" || p === "ucs-2" || p === "utf16le" || p === "utf-16le")) {
      if (c.length < 2 || r.length < 2)
        return -1;
      S = 2, M /= 2, H /= 2, i /= 2;
    }
    function ae(se, Y) {
      return S === 1 ? se[Y] : se.readUInt16BE(Y * S);
    }
    let ne;
    if (v) {
      let se = -1;
      for (ne = i; ne < M; ne++)
        if (ae(c, ne) === ae(r, se === -1 ? 0 : ne - se)) {
          if (se === -1 && (se = ne), ne - se + 1 === H)
            return se * S;
        } else
          se !== -1 && (ne -= ne - se), se = -1;
    } else
      for (i + H > M && (i = M - H), ne = i; ne >= 0; ne--) {
        let se = !0;
        for (let Y = 0; Y < H; Y++)
          if (ae(c, ne + Y) !== ae(r, Y)) {
            se = !1;
            break;
          }
        if (se)
          return ne;
      }
    return -1;
  }
  f.prototype.includes = function(r, i, p) {
    return this.indexOf(r, i, p) !== -1;
  }, f.prototype.indexOf = function(r, i, p) {
    return Ee(this, r, i, p, !0);
  }, f.prototype.lastIndexOf = function(r, i, p) {
    return Ee(this, r, i, p, !1);
  };
  function de(c, r, i, p) {
    i = Number(i) || 0;
    const v = c.length - i;
    p ? (p = Number(p), p > v && (p = v)) : p = v;
    const S = r.length;
    p > S / 2 && (p = S / 2);
    let M;
    for (M = 0; M < p; ++M) {
      const H = parseInt(r.substr(M * 2, 2), 16);
      if (be(H))
        return M;
      c[i + M] = H;
    }
    return M;
  }
  function ce(c, r, i, p) {
    return Ae(Ne(r, c.length - i), c, i, p);
  }
  function he(c, r, i, p) {
    return Ae(Be(r), c, i, p);
  }
  function ee(c, r, i, p) {
    return Ae(xe(r), c, i, p);
  }
  function ue(c, r, i, p) {
    return Ae(O(r, c.length - i), c, i, p);
  }
  f.prototype.write = function(r, i, p, v) {
    if (i === void 0)
      v = "utf8", p = this.length, i = 0;
    else if (p === void 0 && typeof i == "string")
      v = i, p = this.length, i = 0;
    else if (isFinite(i))
      i = i >>> 0, isFinite(p) ? (p = p >>> 0, v === void 0 && (v = "utf8")) : (v = p, p = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const S = this.length - i;
    if ((p === void 0 || p > S) && (p = S), r.length > 0 && (p < 0 || i < 0) || i > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    v || (v = "utf8");
    let M = !1;
    for (; ; )
      switch (v) {
        case "hex":
          return de(this, r, i, p);
        case "utf8":
        case "utf-8":
          return ce(this, r, i, p);
        case "ascii":
        case "latin1":
        case "binary":
          return he(this, r, i, p);
        case "base64":
          return ee(this, r, i, p);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ue(this, r, i, p);
        default:
          if (M)
            throw new TypeError("Unknown encoding: " + v);
          v = ("" + v).toLowerCase(), M = !0;
      }
  }, f.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function ve(c, r, i) {
    return r === 0 && i === c.length ? t.fromByteArray(c) : t.fromByteArray(c.slice(r, i));
  }
  function K(c, r, i) {
    i = Math.min(c.length, i);
    const p = [];
    let v = r;
    for (; v < i; ) {
      const S = c[v];
      let M = null, H = S > 239 ? 4 : S > 223 ? 3 : S > 191 ? 2 : 1;
      if (v + H <= i) {
        let ae, ne, se, Y;
        switch (H) {
          case 1:
            S < 128 && (M = S);
            break;
          case 2:
            ae = c[v + 1], (ae & 192) === 128 && (Y = (S & 31) << 6 | ae & 63, Y > 127 && (M = Y));
            break;
          case 3:
            ae = c[v + 1], ne = c[v + 2], (ae & 192) === 128 && (ne & 192) === 128 && (Y = (S & 15) << 12 | (ae & 63) << 6 | ne & 63, Y > 2047 && (Y < 55296 || Y > 57343) && (M = Y));
            break;
          case 4:
            ae = c[v + 1], ne = c[v + 2], se = c[v + 3], (ae & 192) === 128 && (ne & 192) === 128 && (se & 192) === 128 && (Y = (S & 15) << 18 | (ae & 63) << 12 | (ne & 63) << 6 | se & 63, Y > 65535 && Y < 1114112 && (M = Y));
        }
      }
      M === null ? (M = 65533, H = 1) : M > 65535 && (M -= 65536, p.push(M >>> 10 & 1023 | 55296), M = 56320 | M & 1023), p.push(M), v += H;
    }
    return me(p);
  }
  const ge = 4096;
  function me(c) {
    const r = c.length;
    if (r <= ge)
      return String.fromCharCode.apply(String, c);
    let i = "", p = 0;
    for (; p < r; )
      i += String.fromCharCode.apply(
        String,
        c.slice(p, p += ge)
      );
    return i;
  }
  function h(c, r, i) {
    let p = "";
    i = Math.min(c.length, i);
    for (let v = r; v < i; ++v)
      p += String.fromCharCode(c[v] & 127);
    return p;
  }
  function y(c, r, i) {
    let p = "";
    i = Math.min(c.length, i);
    for (let v = r; v < i; ++v)
      p += String.fromCharCode(c[v]);
    return p;
  }
  function b(c, r, i) {
    const p = c.length;
    (!r || r < 0) && (r = 0), (!i || i < 0 || i > p) && (i = p);
    let v = "";
    for (let S = r; S < i; ++S)
      v += _e[c[S]];
    return v;
  }
  function P(c, r, i) {
    const p = c.slice(r, i);
    let v = "";
    for (let S = 0; S < p.length - 1; S += 2)
      v += String.fromCharCode(p[S] + p[S + 1] * 256);
    return v;
  }
  f.prototype.slice = function(r, i) {
    const p = this.length;
    r = ~~r, i = i === void 0 ? p : ~~i, r < 0 ? (r += p, r < 0 && (r = 0)) : r > p && (r = p), i < 0 ? (i += p, i < 0 && (i = 0)) : i > p && (i = p), i < r && (i = r);
    const v = this.subarray(r, i);
    return Object.setPrototypeOf(v, f.prototype), v;
  };
  function I(c, r, i) {
    if (c % 1 !== 0 || c < 0)
      throw new RangeError("offset is not uint");
    if (c + r > i)
      throw new RangeError("Trying to access beyond buffer length");
  }
  f.prototype.readUintLE = f.prototype.readUIntLE = function(r, i, p) {
    r = r >>> 0, i = i >>> 0, p || I(r, i, this.length);
    let v = this[r], S = 1, M = 0;
    for (; ++M < i && (S *= 256); )
      v += this[r + M] * S;
    return v;
  }, f.prototype.readUintBE = f.prototype.readUIntBE = function(r, i, p) {
    r = r >>> 0, i = i >>> 0, p || I(r, i, this.length);
    let v = this[r + --i], S = 1;
    for (; i > 0 && (S *= 256); )
      v += this[r + --i] * S;
    return v;
  }, f.prototype.readUint8 = f.prototype.readUInt8 = function(r, i) {
    return r = r >>> 0, i || I(r, 1, this.length), this[r];
  }, f.prototype.readUint16LE = f.prototype.readUInt16LE = function(r, i) {
    return r = r >>> 0, i || I(r, 2, this.length), this[r] | this[r + 1] << 8;
  }, f.prototype.readUint16BE = f.prototype.readUInt16BE = function(r, i) {
    return r = r >>> 0, i || I(r, 2, this.length), this[r] << 8 | this[r + 1];
  }, f.prototype.readUint32LE = f.prototype.readUInt32LE = function(r, i) {
    return r = r >>> 0, i || I(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216;
  }, f.prototype.readUint32BE = f.prototype.readUInt32BE = function(r, i) {
    return r = r >>> 0, i || I(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
  }, f.prototype.readBigUInt64LE = le(function(r) {
    r = r >>> 0, k(r, "offset");
    const i = this[r], p = this[r + 7];
    (i === void 0 || p === void 0) && oe(r, this.length - 8);
    const v = i + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24, S = this[++r] + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + p * 2 ** 24;
    return BigInt(v) + (BigInt(S) << BigInt(32));
  }), f.prototype.readBigUInt64BE = le(function(r) {
    r = r >>> 0, k(r, "offset");
    const i = this[r], p = this[r + 7];
    (i === void 0 || p === void 0) && oe(r, this.length - 8);
    const v = i * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r], S = this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + p;
    return (BigInt(v) << BigInt(32)) + BigInt(S);
  }), f.prototype.readIntLE = function(r, i, p) {
    r = r >>> 0, i = i >>> 0, p || I(r, i, this.length);
    let v = this[r], S = 1, M = 0;
    for (; ++M < i && (S *= 256); )
      v += this[r + M] * S;
    return S *= 128, v >= S && (v -= Math.pow(2, 8 * i)), v;
  }, f.prototype.readIntBE = function(r, i, p) {
    r = r >>> 0, i = i >>> 0, p || I(r, i, this.length);
    let v = i, S = 1, M = this[r + --v];
    for (; v > 0 && (S *= 256); )
      M += this[r + --v] * S;
    return S *= 128, M >= S && (M -= Math.pow(2, 8 * i)), M;
  }, f.prototype.readInt8 = function(r, i) {
    return r = r >>> 0, i || I(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r];
  }, f.prototype.readInt16LE = function(r, i) {
    r = r >>> 0, i || I(r, 2, this.length);
    const p = this[r] | this[r + 1] << 8;
    return p & 32768 ? p | 4294901760 : p;
  }, f.prototype.readInt16BE = function(r, i) {
    r = r >>> 0, i || I(r, 2, this.length);
    const p = this[r + 1] | this[r] << 8;
    return p & 32768 ? p | 4294901760 : p;
  }, f.prototype.readInt32LE = function(r, i) {
    return r = r >>> 0, i || I(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
  }, f.prototype.readInt32BE = function(r, i) {
    return r = r >>> 0, i || I(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
  }, f.prototype.readBigInt64LE = le(function(r) {
    r = r >>> 0, k(r, "offset");
    const i = this[r], p = this[r + 7];
    (i === void 0 || p === void 0) && oe(r, this.length - 8);
    const v = this[r + 4] + this[r + 5] * 2 ** 8 + this[r + 6] * 2 ** 16 + (p << 24);
    return (BigInt(v) << BigInt(32)) + BigInt(i + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24);
  }), f.prototype.readBigInt64BE = le(function(r) {
    r = r >>> 0, k(r, "offset");
    const i = this[r], p = this[r + 7];
    (i === void 0 || p === void 0) && oe(r, this.length - 8);
    const v = (i << 24) + // Overflow
    this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r];
    return (BigInt(v) << BigInt(32)) + BigInt(this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + p);
  }), f.prototype.readFloatLE = function(r, i) {
    return r = r >>> 0, i || I(r, 4, this.length), n.read(this, r, !0, 23, 4);
  }, f.prototype.readFloatBE = function(r, i) {
    return r = r >>> 0, i || I(r, 4, this.length), n.read(this, r, !1, 23, 4);
  }, f.prototype.readDoubleLE = function(r, i) {
    return r = r >>> 0, i || I(r, 8, this.length), n.read(this, r, !0, 52, 8);
  }, f.prototype.readDoubleBE = function(r, i) {
    return r = r >>> 0, i || I(r, 8, this.length), n.read(this, r, !1, 52, 8);
  };
  function m(c, r, i, p, v, S) {
    if (!f.isBuffer(c))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (r > v || r < S)
      throw new RangeError('"value" argument is out of bounds');
    if (i + p > c.length)
      throw new RangeError("Index out of range");
  }
  f.prototype.writeUintLE = f.prototype.writeUIntLE = function(r, i, p, v) {
    if (r = +r, i = i >>> 0, p = p >>> 0, !v) {
      const H = Math.pow(2, 8 * p) - 1;
      m(this, r, i, p, H, 0);
    }
    let S = 1, M = 0;
    for (this[i] = r & 255; ++M < p && (S *= 256); )
      this[i + M] = r / S & 255;
    return i + p;
  }, f.prototype.writeUintBE = f.prototype.writeUIntBE = function(r, i, p, v) {
    if (r = +r, i = i >>> 0, p = p >>> 0, !v) {
      const H = Math.pow(2, 8 * p) - 1;
      m(this, r, i, p, H, 0);
    }
    let S = p - 1, M = 1;
    for (this[i + S] = r & 255; --S >= 0 && (M *= 256); )
      this[i + S] = r / M & 255;
    return i + p;
  }, f.prototype.writeUint8 = f.prototype.writeUInt8 = function(r, i, p) {
    return r = +r, i = i >>> 0, p || m(this, r, i, 1, 255, 0), this[i] = r & 255, i + 1;
  }, f.prototype.writeUint16LE = f.prototype.writeUInt16LE = function(r, i, p) {
    return r = +r, i = i >>> 0, p || m(this, r, i, 2, 65535, 0), this[i] = r & 255, this[i + 1] = r >>> 8, i + 2;
  }, f.prototype.writeUint16BE = f.prototype.writeUInt16BE = function(r, i, p) {
    return r = +r, i = i >>> 0, p || m(this, r, i, 2, 65535, 0), this[i] = r >>> 8, this[i + 1] = r & 255, i + 2;
  }, f.prototype.writeUint32LE = f.prototype.writeUInt32LE = function(r, i, p) {
    return r = +r, i = i >>> 0, p || m(this, r, i, 4, 4294967295, 0), this[i + 3] = r >>> 24, this[i + 2] = r >>> 16, this[i + 1] = r >>> 8, this[i] = r & 255, i + 4;
  }, f.prototype.writeUint32BE = f.prototype.writeUInt32BE = function(r, i, p) {
    return r = +r, i = i >>> 0, p || m(this, r, i, 4, 4294967295, 0), this[i] = r >>> 24, this[i + 1] = r >>> 16, this[i + 2] = r >>> 8, this[i + 3] = r & 255, i + 4;
  };
  function A(c, r, i, p, v) {
    C(r, p, v, c, i, 7);
    let S = Number(r & BigInt(4294967295));
    c[i++] = S, S = S >> 8, c[i++] = S, S = S >> 8, c[i++] = S, S = S >> 8, c[i++] = S;
    let M = Number(r >> BigInt(32) & BigInt(4294967295));
    return c[i++] = M, M = M >> 8, c[i++] = M, M = M >> 8, c[i++] = M, M = M >> 8, c[i++] = M, i;
  }
  function B(c, r, i, p, v) {
    C(r, p, v, c, i, 7);
    let S = Number(r & BigInt(4294967295));
    c[i + 7] = S, S = S >> 8, c[i + 6] = S, S = S >> 8, c[i + 5] = S, S = S >> 8, c[i + 4] = S;
    let M = Number(r >> BigInt(32) & BigInt(4294967295));
    return c[i + 3] = M, M = M >> 8, c[i + 2] = M, M = M >> 8, c[i + 1] = M, M = M >> 8, c[i] = M, i + 8;
  }
  f.prototype.writeBigUInt64LE = le(function(r, i = 0) {
    return A(this, r, i, BigInt(0), BigInt("0xffffffffffffffff"));
  }), f.prototype.writeBigUInt64BE = le(function(r, i = 0) {
    return B(this, r, i, BigInt(0), BigInt("0xffffffffffffffff"));
  }), f.prototype.writeIntLE = function(r, i, p, v) {
    if (r = +r, i = i >>> 0, !v) {
      const ae = Math.pow(2, 8 * p - 1);
      m(this, r, i, p, ae - 1, -ae);
    }
    let S = 0, M = 1, H = 0;
    for (this[i] = r & 255; ++S < p && (M *= 256); )
      r < 0 && H === 0 && this[i + S - 1] !== 0 && (H = 1), this[i + S] = (r / M >> 0) - H & 255;
    return i + p;
  }, f.prototype.writeIntBE = function(r, i, p, v) {
    if (r = +r, i = i >>> 0, !v) {
      const ae = Math.pow(2, 8 * p - 1);
      m(this, r, i, p, ae - 1, -ae);
    }
    let S = p - 1, M = 1, H = 0;
    for (this[i + S] = r & 255; --S >= 0 && (M *= 256); )
      r < 0 && H === 0 && this[i + S + 1] !== 0 && (H = 1), this[i + S] = (r / M >> 0) - H & 255;
    return i + p;
  }, f.prototype.writeInt8 = function(r, i, p) {
    return r = +r, i = i >>> 0, p || m(this, r, i, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[i] = r & 255, i + 1;
  }, f.prototype.writeInt16LE = function(r, i, p) {
    return r = +r, i = i >>> 0, p || m(this, r, i, 2, 32767, -32768), this[i] = r & 255, this[i + 1] = r >>> 8, i + 2;
  }, f.prototype.writeInt16BE = function(r, i, p) {
    return r = +r, i = i >>> 0, p || m(this, r, i, 2, 32767, -32768), this[i] = r >>> 8, this[i + 1] = r & 255, i + 2;
  }, f.prototype.writeInt32LE = function(r, i, p) {
    return r = +r, i = i >>> 0, p || m(this, r, i, 4, 2147483647, -2147483648), this[i] = r & 255, this[i + 1] = r >>> 8, this[i + 2] = r >>> 16, this[i + 3] = r >>> 24, i + 4;
  }, f.prototype.writeInt32BE = function(r, i, p) {
    return r = +r, i = i >>> 0, p || m(this, r, i, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[i] = r >>> 24, this[i + 1] = r >>> 16, this[i + 2] = r >>> 8, this[i + 3] = r & 255, i + 4;
  }, f.prototype.writeBigInt64LE = le(function(r, i = 0) {
    return A(this, r, i, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), f.prototype.writeBigInt64BE = le(function(r, i = 0) {
    return B(this, r, i, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function D(c, r, i, p, v, S) {
    if (i + p > c.length)
      throw new RangeError("Index out of range");
    if (i < 0)
      throw new RangeError("Index out of range");
  }
  function W(c, r, i, p, v) {
    return r = +r, i = i >>> 0, v || D(c, r, i, 4), n.write(c, r, i, p, 23, 4), i + 4;
  }
  f.prototype.writeFloatLE = function(r, i, p) {
    return W(this, r, i, !0, p);
  }, f.prototype.writeFloatBE = function(r, i, p) {
    return W(this, r, i, !1, p);
  };
  function o(c, r, i, p, v) {
    return r = +r, i = i >>> 0, v || D(c, r, i, 8), n.write(c, r, i, p, 52, 8), i + 8;
  }
  f.prototype.writeDoubleLE = function(r, i, p) {
    return o(this, r, i, !0, p);
  }, f.prototype.writeDoubleBE = function(r, i, p) {
    return o(this, r, i, !1, p);
  }, f.prototype.copy = function(r, i, p, v) {
    if (!f.isBuffer(r))
      throw new TypeError("argument should be a Buffer");
    if (p || (p = 0), !v && v !== 0 && (v = this.length), i >= r.length && (i = r.length), i || (i = 0), v > 0 && v < p && (v = p), v === p || r.length === 0 || this.length === 0)
      return 0;
    if (i < 0)
      throw new RangeError("targetStart out of bounds");
    if (p < 0 || p >= this.length)
      throw new RangeError("Index out of range");
    if (v < 0)
      throw new RangeError("sourceEnd out of bounds");
    v > this.length && (v = this.length), r.length - i < v - p && (v = r.length - i + p);
    const S = v - p;
    return this === r && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(i, p, v) : Uint8Array.prototype.set.call(
      r,
      this.subarray(p, v),
      i
    ), S;
  }, f.prototype.fill = function(r, i, p, v) {
    if (typeof r == "string") {
      if (typeof i == "string" ? (v = i, i = 0, p = this.length) : typeof p == "string" && (v = p, p = this.length), v !== void 0 && typeof v != "string")
        throw new TypeError("encoding must be a string");
      if (typeof v == "string" && !f.isEncoding(v))
        throw new TypeError("Unknown encoding: " + v);
      if (r.length === 1) {
        const M = r.charCodeAt(0);
        (v === "utf8" && M < 128 || v === "latin1") && (r = M);
      }
    } else
      typeof r == "number" ? r = r & 255 : typeof r == "boolean" && (r = Number(r));
    if (i < 0 || this.length < i || this.length < p)
      throw new RangeError("Out of range index");
    if (p <= i)
      return this;
    i = i >>> 0, p = p === void 0 ? this.length : p >>> 0, r || (r = 0);
    let S;
    if (typeof r == "number")
      for (S = i; S < p; ++S)
        this[S] = r;
    else {
      const M = f.isBuffer(r) ? r : f.from(r, v), H = M.length;
      if (H === 0)
        throw new TypeError('The value "' + r + '" is invalid for argument "value"');
      for (S = 0; S < p - i; ++S)
        this[S + i] = M[S % H];
    }
    return this;
  };
  const a = {};
  function w(c, r, i) {
    a[c] = class extends i {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: r.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${c}]`, this.stack, delete this.name;
      }
      get code() {
        return c;
      }
      set code(v) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: v,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${c}]: ${this.message}`;
      }
    };
  }
  w(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(c) {
      return c ? `${c} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), w(
    "ERR_INVALID_ARG_TYPE",
    function(c, r) {
      return `The "${c}" argument must be of type number. Received type ${typeof r}`;
    },
    TypeError
  ), w(
    "ERR_OUT_OF_RANGE",
    function(c, r, i) {
      let p = `The value of "${c}" is out of range.`, v = i;
      return Number.isInteger(i) && Math.abs(i) > 2 ** 32 ? v = _(String(i)) : typeof i == "bigint" && (v = String(i), (i > BigInt(2) ** BigInt(32) || i < -(BigInt(2) ** BigInt(32))) && (v = _(v)), v += "n"), p += ` It must be ${r}. Received ${v}`, p;
    },
    RangeError
  );
  function _(c) {
    let r = "", i = c.length;
    const p = c[0] === "-" ? 1 : 0;
    for (; i >= p + 4; i -= 3)
      r = `_${c.slice(i - 3, i)}${r}`;
    return `${c.slice(0, i)}${r}`;
  }
  function $(c, r, i) {
    k(r, "offset"), (c[r] === void 0 || c[r + i] === void 0) && oe(r, c.length - (i + 1));
  }
  function C(c, r, i, p, v, S) {
    if (c > i || c < r) {
      const M = typeof r == "bigint" ? "n" : "";
      let H;
      throw S > 3 ? r === 0 || r === BigInt(0) ? H = `>= 0${M} and < 2${M} ** ${(S + 1) * 8}${M}` : H = `>= -(2${M} ** ${(S + 1) * 8 - 1}${M}) and < 2 ** ${(S + 1) * 8 - 1}${M}` : H = `>= ${r}${M} and <= ${i}${M}`, new a.ERR_OUT_OF_RANGE("value", H, c);
    }
    $(p, v, S);
  }
  function k(c, r) {
    if (typeof c != "number")
      throw new a.ERR_INVALID_ARG_TYPE(r, "number", c);
  }
  function oe(c, r, i) {
    throw Math.floor(c) !== c ? (k(c, i), new a.ERR_OUT_OF_RANGE(i || "offset", "an integer", c)) : r < 0 ? new a.ERR_BUFFER_OUT_OF_BOUNDS() : new a.ERR_OUT_OF_RANGE(
      i || "offset",
      `>= ${i ? 1 : 0} and <= ${r}`,
      c
    );
  }
  const Se = /[^+/0-9A-Za-z-_]/g;
  function Ce(c) {
    if (c = c.split("=")[0], c = c.trim().replace(Se, ""), c.length < 2)
      return "";
    for (; c.length % 4 !== 0; )
      c = c + "=";
    return c;
  }
  function Ne(c, r) {
    r = r || 1 / 0;
    let i;
    const p = c.length;
    let v = null;
    const S = [];
    for (let M = 0; M < p; ++M) {
      if (i = c.charCodeAt(M), i > 55295 && i < 57344) {
        if (!v) {
          if (i > 56319) {
            (r -= 3) > -1 && S.push(239, 191, 189);
            continue;
          } else if (M + 1 === p) {
            (r -= 3) > -1 && S.push(239, 191, 189);
            continue;
          }
          v = i;
          continue;
        }
        if (i < 56320) {
          (r -= 3) > -1 && S.push(239, 191, 189), v = i;
          continue;
        }
        i = (v - 55296 << 10 | i - 56320) + 65536;
      } else
        v && (r -= 3) > -1 && S.push(239, 191, 189);
      if (v = null, i < 128) {
        if ((r -= 1) < 0)
          break;
        S.push(i);
      } else if (i < 2048) {
        if ((r -= 2) < 0)
          break;
        S.push(
          i >> 6 | 192,
          i & 63 | 128
        );
      } else if (i < 65536) {
        if ((r -= 3) < 0)
          break;
        S.push(
          i >> 12 | 224,
          i >> 6 & 63 | 128,
          i & 63 | 128
        );
      } else if (i < 1114112) {
        if ((r -= 4) < 0)
          break;
        S.push(
          i >> 18 | 240,
          i >> 12 & 63 | 128,
          i >> 6 & 63 | 128,
          i & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return S;
  }
  function Be(c) {
    const r = [];
    for (let i = 0; i < c.length; ++i)
      r.push(c.charCodeAt(i) & 255);
    return r;
  }
  function O(c, r) {
    let i, p, v;
    const S = [];
    for (let M = 0; M < c.length && !((r -= 2) < 0); ++M)
      i = c.charCodeAt(M), p = i >> 8, v = i % 256, S.push(v), S.push(p);
    return S;
  }
  function xe(c) {
    return t.toByteArray(Ce(c));
  }
  function Ae(c, r, i, p) {
    let v;
    for (v = 0; v < p && !(v + i >= r.length || v >= c.length); ++v)
      r[v + i] = c[v];
    return v;
  }
  function pe(c, r) {
    return c instanceof r || c != null && c.constructor != null && c.constructor.name != null && c.constructor.name === r.name;
  }
  function be(c) {
    return c !== c;
  }
  const _e = function() {
    const c = "0123456789abcdef", r = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const p = i * 16;
      for (let v = 0; v < 16; ++v)
        r[p + v] = c[i] + c[v];
    }
    return r;
  }();
  function le(c) {
    return typeof BigInt > "u" ? Ji : c;
  }
  function Ji() {
    throw new Error("BigInt not supported");
  }
})(ct);
var Bn = { exports: {} }, fe = Bn.exports = {}, Ie, je;
function Ar() {
  throw new Error("setTimeout has not been defined");
}
function xr() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Ie = setTimeout : Ie = Ar;
  } catch {
    Ie = Ar;
  }
  try {
    typeof clearTimeout == "function" ? je = clearTimeout : je = xr;
  } catch {
    je = xr;
  }
})();
function On(e) {
  if (Ie === setTimeout)
    return setTimeout(e, 0);
  if ((Ie === Ar || !Ie) && setTimeout)
    return Ie = setTimeout, setTimeout(e, 0);
  try {
    return Ie(e, 0);
  } catch {
    try {
      return Ie.call(null, e, 0);
    } catch {
      return Ie.call(this, e, 0);
    }
  }
}
function uo(e) {
  if (je === clearTimeout)
    return clearTimeout(e);
  if ((je === xr || !je) && clearTimeout)
    return je = clearTimeout, clearTimeout(e);
  try {
    return je(e);
  } catch {
    try {
      return je.call(null, e);
    } catch {
      return je.call(this, e);
    }
  }
}
var De = [], rt = !1, ze, Tt = -1;
function fo() {
  !rt || !ze || (rt = !1, ze.length ? De = ze.concat(De) : Tt = -1, De.length && Pn());
}
function Pn() {
  if (!rt) {
    var e = On(fo);
    rt = !0;
    for (var t = De.length; t; ) {
      for (ze = De, De = []; ++Tt < t; )
        ze && ze[Tt].run();
      Tt = -1, t = De.length;
    }
    ze = null, rt = !1, uo(e);
  }
}
fe.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var n = 1; n < arguments.length; n++)
      t[n - 1] = arguments[n];
  De.push(new Cn(e, t)), De.length === 1 && !rt && On(Pn);
};
function Cn(e, t) {
  this.fun = e, this.array = t;
}
Cn.prototype.run = function() {
  this.fun.apply(null, this.array);
};
fe.title = "browser";
fe.browser = !0;
fe.env = {};
fe.argv = [];
fe.version = "";
fe.versions = {};
function We() {
}
fe.on = We;
fe.addListener = We;
fe.once = We;
fe.off = We;
fe.removeListener = We;
fe.removeAllListeners = We;
fe.emit = We;
fe.prependListener = We;
fe.prependOnceListener = We;
fe.listeners = function(e) {
  return [];
};
fe.binding = function(e) {
  throw new Error("process.binding is not supported");
};
fe.cwd = function() {
  return "/";
};
fe.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
fe.umask = function() {
  return 0;
};
var co = Bn.exports;
(function(e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
  const t = ct, n = co, s = (l) => l && l.__esModule ? l : { default: l }, u = s(n), d = globalThis || void 0 || self;
  Object.defineProperty(e, "Buffer", { enumerable: !0, get: () => t.Buffer }), Object.defineProperty(e, "process", { enumerable: !0, get: () => u.default }), e.global = d;
})(J);
var Rr = { exports: {} };
typeof J.process > "u" || !J.process.version || J.process.version.indexOf("v0.") === 0 || J.process.version.indexOf("v1.") === 0 && J.process.version.indexOf("v1.8.") !== 0 ? Rr.exports = { nextTick: lo } : Rr.exports = J.process;
function lo(e, t, n, s) {
  if (typeof e != "function")
    throw new TypeError('"callback" argument must be a function');
  var u = arguments.length, d, l;
  switch (u) {
    case 0:
    case 1:
      return J.process.nextTick(e);
    case 2:
      return J.process.nextTick(function() {
        e.call(null, t);
      });
    case 3:
      return J.process.nextTick(function() {
        e.call(null, t, n);
      });
    case 4:
      return J.process.nextTick(function() {
        e.call(null, t, n, s);
      });
    default:
      for (d = new Array(u - 1), l = 0; l < d.length; )
        d[l++] = arguments[l];
      return J.process.nextTick(function() {
        e.apply(null, d);
      });
  }
}
var Ge = Rr.exports, ho = {}.toString, po = Array.isArray || function(e) {
  return ho.call(e) == "[object Array]";
}, Dr = { exports: {} }, nt = typeof Reflect == "object" ? Reflect : null, tn = nt && typeof nt.apply == "function" ? nt.apply : function(t, n, s) {
  return Function.prototype.apply.call(t, n, s);
}, Mt;
nt && typeof nt.ownKeys == "function" ? Mt = nt.ownKeys : Object.getOwnPropertySymbols ? Mt = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : Mt = function(t) {
  return Object.getOwnPropertyNames(t);
};
function yo(e) {
  console && console.warn && console.warn(e);
}
var In = Number.isNaN || function(t) {
  return t !== t;
};
function X() {
  X.init.call(this);
}
Dr.exports = X;
Dr.exports.once = vo;
X.EventEmitter = X;
X.prototype._events = void 0;
X.prototype._eventsCount = 0;
X.prototype._maxListeners = void 0;
var rn = 10;
function Lt(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(X, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return rn;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || In(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    rn = e;
  }
});
X.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
X.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || In(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function jn(e) {
  return e._maxListeners === void 0 ? X.defaultMaxListeners : e._maxListeners;
}
X.prototype.getMaxListeners = function() {
  return jn(this);
};
X.prototype.emit = function(t) {
  for (var n = [], s = 1; s < arguments.length; s++)
    n.push(arguments[s]);
  var u = t === "error", d = this._events;
  if (d !== void 0)
    u = u && d.error === void 0;
  else if (!u)
    return !1;
  if (u) {
    var l;
    if (n.length > 0 && (l = n[0]), l instanceof Error)
      throw l;
    var f = new Error("Unhandled error." + (l ? " (" + l.message + ")" : ""));
    throw f.context = l, f;
  }
  var g = d[t];
  if (g === void 0)
    return !1;
  if (typeof g == "function")
    tn(g, this, n);
  else
    for (var T = g.length, F = Un(g, T), s = 0; s < T; ++s)
      tn(F[s], this, n);
  return !0;
};
function Fn(e, t, n, s) {
  var u, d, l;
  if (Lt(n), d = e._events, d === void 0 ? (d = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (d.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    n.listener ? n.listener : n
  ), d = e._events), l = d[t]), l === void 0)
    l = d[t] = n, ++e._eventsCount;
  else if (typeof l == "function" ? l = d[t] = s ? [n, l] : [l, n] : s ? l.unshift(n) : l.push(n), u = jn(e), u > 0 && l.length > u && !l.warned) {
    l.warned = !0;
    var f = new Error("Possible EventEmitter memory leak detected. " + l.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    f.name = "MaxListenersExceededWarning", f.emitter = e, f.type = t, f.count = l.length, yo(f);
  }
  return e;
}
X.prototype.addListener = function(t, n) {
  return Fn(this, t, n, !1);
};
X.prototype.on = X.prototype.addListener;
X.prototype.prependListener = function(t, n) {
  return Fn(this, t, n, !0);
};
function go() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function kn(e, t, n) {
  var s = { fired: !1, wrapFn: void 0, target: e, type: t, listener: n }, u = go.bind(s);
  return u.listener = n, s.wrapFn = u, u;
}
X.prototype.once = function(t, n) {
  return Lt(n), this.on(t, kn(this, t, n)), this;
};
X.prototype.prependOnceListener = function(t, n) {
  return Lt(n), this.prependListener(t, kn(this, t, n)), this;
};
X.prototype.removeListener = function(t, n) {
  var s, u, d, l, f;
  if (Lt(n), u = this._events, u === void 0)
    return this;
  if (s = u[t], s === void 0)
    return this;
  if (s === n || s.listener === n)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete u[t], u.removeListener && this.emit("removeListener", t, s.listener || n));
  else if (typeof s != "function") {
    for (d = -1, l = s.length - 1; l >= 0; l--)
      if (s[l] === n || s[l].listener === n) {
        f = s[l].listener, d = l;
        break;
      }
    if (d < 0)
      return this;
    d === 0 ? s.shift() : mo(s, d), s.length === 1 && (u[t] = s[0]), u.removeListener !== void 0 && this.emit("removeListener", t, f || n);
  }
  return this;
};
X.prototype.off = X.prototype.removeListener;
X.prototype.removeAllListeners = function(t) {
  var n, s, u;
  if (s = this._events, s === void 0)
    return this;
  if (s.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : s[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete s[t]), this;
  if (arguments.length === 0) {
    var d = Object.keys(s), l;
    for (u = 0; u < d.length; ++u)
      l = d[u], l !== "removeListener" && this.removeAllListeners(l);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (n = s[t], typeof n == "function")
    this.removeListener(t, n);
  else if (n !== void 0)
    for (u = n.length - 1; u >= 0; u--)
      this.removeListener(t, n[u]);
  return this;
};
function $n(e, t, n) {
  var s = e._events;
  if (s === void 0)
    return [];
  var u = s[t];
  return u === void 0 ? [] : typeof u == "function" ? n ? [u.listener || u] : [u] : n ? wo(u) : Un(u, u.length);
}
X.prototype.listeners = function(t) {
  return $n(this, t, !0);
};
X.prototype.rawListeners = function(t) {
  return $n(this, t, !1);
};
X.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : Nn.call(e, t);
};
X.prototype.listenerCount = Nn;
function Nn(e) {
  var t = this._events;
  if (t !== void 0) {
    var n = t[e];
    if (typeof n == "function")
      return 1;
    if (n !== void 0)
      return n.length;
  }
  return 0;
}
X.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Mt(this._events) : [];
};
function Un(e, t) {
  for (var n = new Array(t), s = 0; s < t; ++s)
    n[s] = e[s];
  return n;
}
function mo(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function wo(e) {
  for (var t = new Array(e.length), n = 0; n < t.length; ++n)
    t[n] = e[n].listener || e[n];
  return t;
}
function vo(e, t) {
  return new Promise(function(n, s) {
    function u(l) {
      e.removeListener(t, d), s(l);
    }
    function d() {
      typeof e.removeListener == "function" && e.removeListener("error", u), n([].slice.call(arguments));
    }
    Dn(e, t, d, { once: !0 }), t !== "error" && bo(e, u, { once: !0 });
  });
}
function bo(e, t, n) {
  typeof e.on == "function" && Dn(e, "error", t, n);
}
function Dn(e, t, n, s) {
  if (typeof e.on == "function")
    s.once ? e.once(t, n) : e.on(t, n);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function u(d) {
      s.once && e.removeEventListener(t, u), n(d);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var lt = Dr.exports, Ln = lt.EventEmitter, Tr = { exports: {} };
(function(e, t) {
  var n = ct, s = n.Buffer;
  function u(l, f) {
    for (var g in l)
      f[g] = l[g];
  }
  s.from && s.alloc && s.allocUnsafe && s.allocUnsafeSlow ? e.exports = n : (u(n, t), t.Buffer = d);
  function d(l, f, g) {
    return s(l, f, g);
  }
  u(s, d), d.from = function(l, f, g) {
    if (typeof l == "number")
      throw new TypeError("Argument must not be a number");
    return s(l, f, g);
  }, d.alloc = function(l, f, g) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    var T = s(l);
    return f !== void 0 ? typeof g == "string" ? T.fill(f, g) : T.fill(f) : T.fill(0), T;
  }, d.allocUnsafe = function(l) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    return s(l);
  }, d.allocUnsafeSlow = function(l) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    return n.SlowBuffer(l);
  };
})(Tr, Tr.exports);
var Lr = Tr.exports, re = {};
function _o(e) {
  return Array.isArray ? Array.isArray(e) : qt(e) === "[object Array]";
}
re.isArray = _o;
function Eo(e) {
  return typeof e == "boolean";
}
re.isBoolean = Eo;
function So(e) {
  return e === null;
}
re.isNull = So;
function Ao(e) {
  return e == null;
}
re.isNullOrUndefined = Ao;
function xo(e) {
  return typeof e == "number";
}
re.isNumber = xo;
function Ro(e) {
  return typeof e == "string";
}
re.isString = Ro;
function To(e) {
  return typeof e == "symbol";
}
re.isSymbol = To;
function Mo(e) {
  return e === void 0;
}
re.isUndefined = Mo;
function Bo(e) {
  return qt(e) === "[object RegExp]";
}
re.isRegExp = Bo;
function Oo(e) {
  return typeof e == "object" && e !== null;
}
re.isObject = Oo;
function Po(e) {
  return qt(e) === "[object Date]";
}
re.isDate = Po;
function Co(e) {
  return qt(e) === "[object Error]" || e instanceof Error;
}
re.isError = Co;
function Io(e) {
  return typeof e == "function";
}
re.isFunction = Io;
function jo(e) {
  return e === null || typeof e == "boolean" || typeof e == "number" || typeof e == "string" || typeof e == "symbol" || // ES6 symbol
  typeof e > "u";
}
re.isPrimitive = jo;
re.isBuffer = ct.Buffer.isBuffer;
function qt(e) {
  return Object.prototype.toString.call(e);
}
var Mr = { exports: {} };
typeof Object.create == "function" ? Mr.exports = function(t, n) {
  n && (t.super_ = n, t.prototype = Object.create(n.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : Mr.exports = function(t, n) {
  if (n) {
    t.super_ = n;
    var s = function() {
    };
    s.prototype = n.prototype, t.prototype = new s(), t.prototype.constructor = t;
  }
};
var Pe = Mr.exports, wt = {}, qn = {}, Wn = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var t = {}, n = Symbol("test"), s = Object(n);
  if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(s) !== "[object Symbol]")
    return !1;
  var u = 42;
  t[n] = u;
  for (n in t)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
    return !1;
  var d = Object.getOwnPropertySymbols(t);
  if (d.length !== 1 || d[0] !== n || !Object.prototype.propertyIsEnumerable.call(t, n))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var l = Object.getOwnPropertyDescriptor(t, n);
    if (l.value !== u || l.enumerable !== !0)
      return !1;
  }
  return !0;
}, Fo = Wn, Wt = function() {
  return Fo() && !!Symbol.toStringTag;
}, nn = typeof Symbol < "u" && Symbol, ko = Wn, $o = function() {
  return typeof nn != "function" || typeof Symbol != "function" || typeof nn("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : ko();
}, No = "Function.prototype.bind called on incompatible ", tr = Array.prototype.slice, Uo = Object.prototype.toString, Do = "[object Function]", Lo = function(t) {
  var n = this;
  if (typeof n != "function" || Uo.call(n) !== Do)
    throw new TypeError(No + n);
  for (var s = tr.call(arguments, 1), u, d = function() {
    if (this instanceof u) {
      var F = n.apply(
        this,
        s.concat(tr.call(arguments))
      );
      return Object(F) === F ? F : this;
    } else
      return n.apply(
        t,
        s.concat(tr.call(arguments))
      );
  }, l = Math.max(0, n.length - s.length), f = [], g = 0; g < l; g++)
    f.push("$" + g);
  if (u = Function("binder", "return function (" + f.join(",") + "){ return binder.apply(this,arguments); }")(d), n.prototype) {
    var T = function() {
    };
    T.prototype = n.prototype, u.prototype = new T(), T.prototype = null;
  }
  return u;
}, qo = Lo, qr = Function.prototype.bind || qo, Wo = qr, Vo = Wo.call(Function.call, Object.prototype.hasOwnProperty), G, st = SyntaxError, Vn = Function, it = TypeError, rr = function(e) {
  try {
    return Vn('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, Xe = Object.getOwnPropertyDescriptor;
if (Xe)
  try {
    Xe({}, "");
  } catch {
    Xe = null;
  }
var nr = function() {
  throw new it();
}, Ho = Xe ? function() {
  try {
    return arguments.callee, nr;
  } catch {
    try {
      return Xe(arguments, "callee").get;
    } catch {
      return nr;
    }
  }
}() : nr, Qe = $o(), Fe = Object.getPrototypeOf || function(e) {
  return e.__proto__;
}, et = {}, Go = typeof Uint8Array > "u" ? G : Fe(Uint8Array), Ke = {
  "%AggregateError%": typeof AggregateError > "u" ? G : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? G : ArrayBuffer,
  "%ArrayIteratorPrototype%": Qe ? Fe([][Symbol.iterator]()) : G,
  "%AsyncFromSyncIteratorPrototype%": G,
  "%AsyncFunction%": et,
  "%AsyncGenerator%": et,
  "%AsyncGeneratorFunction%": et,
  "%AsyncIteratorPrototype%": et,
  "%Atomics%": typeof Atomics > "u" ? G : Atomics,
  "%BigInt%": typeof BigInt > "u" ? G : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? G : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? G : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? G : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? G : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? G : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? G : FinalizationRegistry,
  "%Function%": Vn,
  "%GeneratorFunction%": et,
  "%Int8Array%": typeof Int8Array > "u" ? G : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? G : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? G : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": Qe ? Fe(Fe([][Symbol.iterator]())) : G,
  "%JSON%": typeof JSON == "object" ? JSON : G,
  "%Map%": typeof Map > "u" ? G : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !Qe ? G : Fe((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? G : Promise,
  "%Proxy%": typeof Proxy > "u" ? G : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? G : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? G : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !Qe ? G : Fe((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? G : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": Qe ? Fe(""[Symbol.iterator]()) : G,
  "%Symbol%": Qe ? Symbol : G,
  "%SyntaxError%": st,
  "%ThrowTypeError%": Ho,
  "%TypedArray%": Go,
  "%TypeError%": it,
  "%Uint8Array%": typeof Uint8Array > "u" ? G : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? G : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? G : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? G : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap > "u" ? G : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? G : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? G : WeakSet
};
try {
  null.error;
} catch (e) {
  var zo = Fe(Fe(e));
  Ke["%Error.prototype%"] = zo;
}
var Jo = function e(t) {
  var n;
  if (t === "%AsyncFunction%")
    n = rr("async function () {}");
  else if (t === "%GeneratorFunction%")
    n = rr("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    n = rr("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var s = e("%AsyncGeneratorFunction%");
    s && (n = s.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var u = e("%AsyncGenerator%");
    u && (n = Fe(u.prototype));
  }
  return Ke[t] = n, n;
}, on = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, vt = qr, jt = Vo, Xo = vt.call(Function.call, Array.prototype.concat), Ko = vt.call(Function.apply, Array.prototype.splice), an = vt.call(Function.call, String.prototype.replace), Ft = vt.call(Function.call, String.prototype.slice), Yo = vt.call(Function.call, RegExp.prototype.exec), Zo = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Qo = /\\(\\)?/g, ea = function(t) {
  var n = Ft(t, 0, 1), s = Ft(t, -1);
  if (n === "%" && s !== "%")
    throw new st("invalid intrinsic syntax, expected closing `%`");
  if (s === "%" && n !== "%")
    throw new st("invalid intrinsic syntax, expected opening `%`");
  var u = [];
  return an(t, Zo, function(d, l, f, g) {
    u[u.length] = f ? an(g, Qo, "$1") : l || d;
  }), u;
}, ta = function(t, n) {
  var s = t, u;
  if (jt(on, s) && (u = on[s], s = "%" + u[0] + "%"), jt(Ke, s)) {
    var d = Ke[s];
    if (d === et && (d = Jo(s)), typeof d > "u" && !n)
      throw new it("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: u,
      name: s,
      value: d
    };
  }
  throw new st("intrinsic " + t + " does not exist!");
}, Wr = function(t, n) {
  if (typeof t != "string" || t.length === 0)
    throw new it("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof n != "boolean")
    throw new it('"allowMissing" argument must be a boolean');
  if (Yo(/^%?[^%]*%?$/, t) === null)
    throw new st("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var s = ea(t), u = s.length > 0 ? s[0] : "", d = ta("%" + u + "%", n), l = d.name, f = d.value, g = !1, T = d.alias;
  T && (u = T[0], Ko(s, Xo([0, 1], T)));
  for (var F = 1, E = !0; F < s.length; F += 1) {
    var j = s[F], U = Ft(j, 0, 1), q = Ft(j, -1);
    if ((U === '"' || U === "'" || U === "`" || q === '"' || q === "'" || q === "`") && U !== q)
      throw new st("property names with quotes must have matching quotes");
    if ((j === "constructor" || !E) && (g = !0), u += "." + j, l = "%" + u + "%", jt(Ke, l))
      f = Ke[l];
    else if (f != null) {
      if (!(j in f)) {
        if (!n)
          throw new it("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (Xe && F + 1 >= s.length) {
        var N = Xe(f, j);
        E = !!N, E && "get" in N && !("originalValue" in N.get) ? f = N.get : f = f[j];
      } else
        E = jt(f, j), f = f[j];
      E && !g && (Ke[l] = f);
    }
  }
  return f;
}, Hn = { exports: {} };
(function(e) {
  var t = qr, n = Wr, s = n("%Function.prototype.apply%"), u = n("%Function.prototype.call%"), d = n("%Reflect.apply%", !0) || t.call(u, s), l = n("%Object.getOwnPropertyDescriptor%", !0), f = n("%Object.defineProperty%", !0), g = n("%Math.max%");
  if (f)
    try {
      f({}, "a", { value: 1 });
    } catch {
      f = null;
    }
  e.exports = function(E) {
    var j = d(t, u, arguments);
    if (l && f) {
      var U = l(j, "length");
      U.configurable && f(
        j,
        "length",
        { value: 1 + g(0, E.length - (arguments.length - 1)) }
      );
    }
    return j;
  };
  var T = function() {
    return d(t, s, arguments);
  };
  f ? f(e.exports, "apply", { value: T }) : e.exports.apply = T;
})(Hn);
var ra = Hn.exports, Gn = Wr, zn = ra, na = zn(Gn("String.prototype.indexOf")), Vr = function(t, n) {
  var s = Gn(t, !!n);
  return typeof s == "function" && na(t, ".prototype.") > -1 ? zn(s) : s;
}, ia = Wt(), oa = Vr, Br = oa("Object.prototype.toString"), Vt = function(t) {
  return ia && t && typeof t == "object" && Symbol.toStringTag in t ? !1 : Br(t) === "[object Arguments]";
}, Jn = function(t) {
  return Vt(t) ? !0 : t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && Br(t) !== "[object Array]" && Br(t.callee) === "[object Function]";
}, aa = function() {
  return Vt(arguments);
}();
Vt.isLegacyArguments = Jn;
var sa = aa ? Vt : Jn, ua = Object.prototype.toString, fa = Function.prototype.toString, ca = /^\s*(?:function)?\*/, Xn = Wt(), ir = Object.getPrototypeOf, la = function() {
  if (!Xn)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, or, da = function(t) {
  if (typeof t != "function")
    return !1;
  if (ca.test(fa.call(t)))
    return !0;
  if (!Xn) {
    var n = ua.call(t);
    return n === "[object GeneratorFunction]";
  }
  if (!ir)
    return !1;
  if (typeof or > "u") {
    var s = la();
    or = s ? ir(s) : !1;
  }
  return ir(t) === or;
}, Kn = Function.prototype.toString, tt = typeof Reflect == "object" && Reflect !== null && Reflect.apply, Or, Bt;
if (typeof tt == "function" && typeof Object.defineProperty == "function")
  try {
    Or = Object.defineProperty({}, "length", {
      get: function() {
        throw Bt;
      }
    }), Bt = {}, tt(function() {
      throw 42;
    }, null, Or);
  } catch (e) {
    e !== Bt && (tt = null);
  }
else
  tt = null;
var ha = /^\s*class\b/, Pr = function(t) {
  try {
    var n = Kn.call(t);
    return ha.test(n);
  } catch {
    return !1;
  }
}, ar = function(t) {
  try {
    return Pr(t) ? !1 : (Kn.call(t), !0);
  } catch {
    return !1;
  }
}, Ot = Object.prototype.toString, pa = "[object Object]", ya = "[object Function]", ga = "[object GeneratorFunction]", ma = "[object HTMLAllCollection]", wa = "[object HTML document.all class]", va = "[object HTMLCollection]", ba = typeof Symbol == "function" && !!Symbol.toStringTag, _a = !(0 in [,]), Cr = function() {
  return !1;
};
if (typeof document == "object") {
  var Ea = document.all;
  Ot.call(Ea) === Ot.call(document.all) && (Cr = function(t) {
    if ((_a || !t) && (typeof t > "u" || typeof t == "object"))
      try {
        var n = Ot.call(t);
        return (n === ma || n === wa || n === va || n === pa) && t("") == null;
      } catch {
      }
    return !1;
  });
}
var Sa = tt ? function(t) {
  if (Cr(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  try {
    tt(t, null, Or);
  } catch (n) {
    if (n !== Bt)
      return !1;
  }
  return !Pr(t) && ar(t);
} : function(t) {
  if (Cr(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  if (ba)
    return ar(t);
  if (Pr(t))
    return !1;
  var n = Ot.call(t);
  return n !== ya && n !== ga && !/^\[object HTML/.test(n) ? !1 : ar(t);
}, Aa = Sa, xa = Object.prototype.toString, Yn = Object.prototype.hasOwnProperty, Ra = function(t, n, s) {
  for (var u = 0, d = t.length; u < d; u++)
    Yn.call(t, u) && (s == null ? n(t[u], u, t) : n.call(s, t[u], u, t));
}, Ta = function(t, n, s) {
  for (var u = 0, d = t.length; u < d; u++)
    s == null ? n(t.charAt(u), u, t) : n.call(s, t.charAt(u), u, t);
}, Ma = function(t, n, s) {
  for (var u in t)
    Yn.call(t, u) && (s == null ? n(t[u], u, t) : n.call(s, t[u], u, t));
}, Ba = function(t, n, s) {
  if (!Aa(n))
    throw new TypeError("iterator must be a function");
  var u;
  arguments.length >= 3 && (u = s), xa.call(t) === "[object Array]" ? Ra(t, n, u) : typeof t == "string" ? Ta(t, n, u) : Ma(t, n, u);
}, Zn = Ba, sr = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
], Oa = typeof globalThis > "u" ? te : globalThis, Qn = function() {
  for (var t = [], n = 0; n < sr.length; n++)
    typeof Oa[sr[n]] == "function" && (t[t.length] = sr[n]);
  return t;
}, Pa = Wr, Pt = Pa("%Object.getOwnPropertyDescriptor%", !0);
if (Pt)
  try {
    Pt([], "length");
  } catch {
    Pt = null;
  }
var ei = Pt, ti = Zn, Ca = Qn, Hr = Vr, Ia = Hr("Object.prototype.toString"), ri = Wt(), Ct = ei, ja = typeof globalThis > "u" ? te : globalThis, ni = Ca(), Fa = Hr("Array.prototype.indexOf", !0) || function(t, n) {
  for (var s = 0; s < t.length; s += 1)
    if (t[s] === n)
      return s;
  return -1;
}, ka = Hr("String.prototype.slice"), ii = {}, ur = Object.getPrototypeOf;
ri && Ct && ur && ti(ni, function(e) {
  var t = new ja[e]();
  if (Symbol.toStringTag in t) {
    var n = ur(t), s = Ct(n, Symbol.toStringTag);
    if (!s) {
      var u = ur(n);
      s = Ct(u, Symbol.toStringTag);
    }
    ii[e] = s.get;
  }
});
var $a = function(t) {
  var n = !1;
  return ti(ii, function(s, u) {
    if (!n)
      try {
        n = s.call(t) === u;
      } catch {
      }
  }), n;
}, oi = function(t) {
  if (!t || typeof t != "object")
    return !1;
  if (!ri || !(Symbol.toStringTag in t)) {
    var n = ka(Ia(t), 8, -1);
    return Fa(ni, n) > -1;
  }
  return Ct ? $a(t) : !1;
}, ai = Zn, Na = Qn, si = Vr, fr = ei, Ua = si("Object.prototype.toString"), ui = Wt(), sn = typeof globalThis > "u" ? te : globalThis, Da = Na(), La = si("String.prototype.slice"), fi = {}, cr = Object.getPrototypeOf;
ui && fr && cr && ai(Da, function(e) {
  if (typeof sn[e] == "function") {
    var t = new sn[e]();
    if (Symbol.toStringTag in t) {
      var n = cr(t), s = fr(n, Symbol.toStringTag);
      if (!s) {
        var u = cr(n);
        s = fr(u, Symbol.toStringTag);
      }
      fi[e] = s.get;
    }
  }
});
var qa = function(t) {
  var n = !1;
  return ai(fi, function(s, u) {
    if (!n)
      try {
        var d = s.call(t);
        d === u && (n = d);
      } catch {
      }
  }), n;
}, Wa = oi, Va = function(t) {
  return Wa(t) ? !ui || !(Symbol.toStringTag in t) ? La(Ua(t), 8, -1) : qa(t) : !1;
};
(function(e) {
  var t = sa, n = da, s = Va, u = oi;
  function d(O) {
    return O.call.bind(O);
  }
  var l = typeof BigInt < "u", f = typeof Symbol < "u", g = d(Object.prototype.toString), T = d(Number.prototype.valueOf), F = d(String.prototype.valueOf), E = d(Boolean.prototype.valueOf);
  if (l)
    var j = d(BigInt.prototype.valueOf);
  if (f)
    var U = d(Symbol.prototype.valueOf);
  function q(O, xe) {
    if (typeof O != "object")
      return !1;
    try {
      return xe(O), !0;
    } catch {
      return !1;
    }
  }
  e.isArgumentsObject = t, e.isGeneratorFunction = n, e.isTypedArray = u;
  function N(O) {
    return typeof Promise < "u" && O instanceof Promise || O !== null && typeof O == "object" && typeof O.then == "function" && typeof O.catch == "function";
  }
  e.isPromise = N;
  function Q(O) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(O) : u(O) || A(O);
  }
  e.isArrayBufferView = Q;
  function x(O) {
    return s(O) === "Uint8Array";
  }
  e.isUint8Array = x;
  function R(O) {
    return s(O) === "Uint8ClampedArray";
  }
  e.isUint8ClampedArray = R;
  function L(O) {
    return s(O) === "Uint16Array";
  }
  e.isUint16Array = L;
  function z(O) {
    return s(O) === "Uint32Array";
  }
  e.isUint32Array = z;
  function V(O) {
    return s(O) === "Int8Array";
  }
  e.isInt8Array = V;
  function Ee(O) {
    return s(O) === "Int16Array";
  }
  e.isInt16Array = Ee;
  function ie(O) {
    return s(O) === "Int32Array";
  }
  e.isInt32Array = ie;
  function de(O) {
    return s(O) === "Float32Array";
  }
  e.isFloat32Array = de;
  function ce(O) {
    return s(O) === "Float64Array";
  }
  e.isFloat64Array = ce;
  function he(O) {
    return s(O) === "BigInt64Array";
  }
  e.isBigInt64Array = he;
  function ee(O) {
    return s(O) === "BigUint64Array";
  }
  e.isBigUint64Array = ee;
  function ue(O) {
    return g(O) === "[object Map]";
  }
  ue.working = typeof Map < "u" && ue(/* @__PURE__ */ new Map());
  function ve(O) {
    return typeof Map > "u" ? !1 : ue.working ? ue(O) : O instanceof Map;
  }
  e.isMap = ve;
  function K(O) {
    return g(O) === "[object Set]";
  }
  K.working = typeof Set < "u" && K(/* @__PURE__ */ new Set());
  function ge(O) {
    return typeof Set > "u" ? !1 : K.working ? K(O) : O instanceof Set;
  }
  e.isSet = ge;
  function me(O) {
    return g(O) === "[object WeakMap]";
  }
  me.working = typeof WeakMap < "u" && me(/* @__PURE__ */ new WeakMap());
  function h(O) {
    return typeof WeakMap > "u" ? !1 : me.working ? me(O) : O instanceof WeakMap;
  }
  e.isWeakMap = h;
  function y(O) {
    return g(O) === "[object WeakSet]";
  }
  y.working = typeof WeakSet < "u" && y(/* @__PURE__ */ new WeakSet());
  function b(O) {
    return y(O);
  }
  e.isWeakSet = b;
  function P(O) {
    return g(O) === "[object ArrayBuffer]";
  }
  P.working = typeof ArrayBuffer < "u" && P(new ArrayBuffer());
  function I(O) {
    return typeof ArrayBuffer > "u" ? !1 : P.working ? P(O) : O instanceof ArrayBuffer;
  }
  e.isArrayBuffer = I;
  function m(O) {
    return g(O) === "[object DataView]";
  }
  m.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && m(new DataView(new ArrayBuffer(1), 0, 1));
  function A(O) {
    return typeof DataView > "u" ? !1 : m.working ? m(O) : O instanceof DataView;
  }
  e.isDataView = A;
  var B = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function D(O) {
    return g(O) === "[object SharedArrayBuffer]";
  }
  function W(O) {
    return typeof B > "u" ? !1 : (typeof D.working > "u" && (D.working = D(new B())), D.working ? D(O) : O instanceof B);
  }
  e.isSharedArrayBuffer = W;
  function o(O) {
    return g(O) === "[object AsyncFunction]";
  }
  e.isAsyncFunction = o;
  function a(O) {
    return g(O) === "[object Map Iterator]";
  }
  e.isMapIterator = a;
  function w(O) {
    return g(O) === "[object Set Iterator]";
  }
  e.isSetIterator = w;
  function _(O) {
    return g(O) === "[object Generator]";
  }
  e.isGeneratorObject = _;
  function $(O) {
    return g(O) === "[object WebAssembly.Module]";
  }
  e.isWebAssemblyCompiledModule = $;
  function C(O) {
    return q(O, T);
  }
  e.isNumberObject = C;
  function k(O) {
    return q(O, F);
  }
  e.isStringObject = k;
  function oe(O) {
    return q(O, E);
  }
  e.isBooleanObject = oe;
  function Se(O) {
    return l && q(O, j);
  }
  e.isBigIntObject = Se;
  function Ce(O) {
    return f && q(O, U);
  }
  e.isSymbolObject = Ce;
  function Ne(O) {
    return C(O) || k(O) || oe(O) || Se(O) || Ce(O);
  }
  e.isBoxedPrimitive = Ne;
  function Be(O) {
    return typeof Uint8Array < "u" && (I(O) || W(O));
  }
  e.isAnyArrayBuffer = Be, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(O) {
    Object.defineProperty(e, O, {
      enumerable: !1,
      value: function() {
        throw new Error(O + " is not supported in userland");
      }
    });
  });
})(qn);
var Ha = function(t) {
  return t && typeof t == "object" && typeof t.copy == "function" && typeof t.fill == "function" && typeof t.readUInt8 == "function";
};
(function(e) {
  var t = Object.getOwnPropertyDescriptors || function(A) {
    for (var B = Object.keys(A), D = {}, W = 0; W < B.length; W++)
      D[B[W]] = Object.getOwnPropertyDescriptor(A, B[W]);
    return D;
  }, n = /%[sdj%]/g;
  e.format = function(m) {
    if (!V(m)) {
      for (var A = [], B = 0; B < arguments.length; B++)
        A.push(l(arguments[B]));
      return A.join(" ");
    }
    for (var B = 1, D = arguments, W = D.length, o = String(m).replace(n, function(w) {
      if (w === "%%")
        return "%";
      if (B >= W)
        return w;
      switch (w) {
        case "%s":
          return String(D[B++]);
        case "%d":
          return Number(D[B++]);
        case "%j":
          try {
            return JSON.stringify(D[B++]);
          } catch {
            return "[Circular]";
          }
        default:
          return w;
      }
    }), a = D[B]; B < W; a = D[++B])
      R(a) || !ce(a) ? o += " " + a : o += " " + l(a);
    return o;
  }, e.deprecate = function(m, A) {
    if (typeof J.process < "u" && J.process.noDeprecation === !0)
      return m;
    if (typeof J.process > "u")
      return function() {
        return e.deprecate(m, A).apply(this, arguments);
      };
    var B = !1;
    function D() {
      if (!B) {
        if (J.process.throwDeprecation)
          throw new Error(A);
        J.process.traceDeprecation ? console.trace(A) : console.error(A), B = !0;
      }
      return m.apply(this, arguments);
    }
    return D;
  };
  var s = {}, u = /^$/;
  if (J.process.env.NODE_DEBUG) {
    var d = J.process.env.NODE_DEBUG;
    d = d.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), u = new RegExp("^" + d + "$", "i");
  }
  e.debuglog = function(m) {
    if (m = m.toUpperCase(), !s[m])
      if (u.test(m)) {
        var A = J.process.pid;
        s[m] = function() {
          var B = e.format.apply(e, arguments);
          console.error("%s %d: %s", m, A, B);
        };
      } else
        s[m] = function() {
        };
    return s[m];
  };
  function l(m, A) {
    var B = {
      seen: [],
      stylize: g
    };
    return arguments.length >= 3 && (B.depth = arguments[2]), arguments.length >= 4 && (B.colors = arguments[3]), x(A) ? B.showHidden = A : A && e._extend(B, A), ie(B.showHidden) && (B.showHidden = !1), ie(B.depth) && (B.depth = 2), ie(B.colors) && (B.colors = !1), ie(B.customInspect) && (B.customInspect = !0), B.colors && (B.stylize = f), F(B, m, B.depth);
  }
  e.inspect = l, l.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, l.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function f(m, A) {
    var B = l.styles[A];
    return B ? "\x1B[" + l.colors[B][0] + "m" + m + "\x1B[" + l.colors[B][1] + "m" : m;
  }
  function g(m, A) {
    return m;
  }
  function T(m) {
    var A = {};
    return m.forEach(function(B, D) {
      A[B] = !0;
    }), A;
  }
  function F(m, A, B) {
    if (m.customInspect && A && ue(A.inspect) && // Filter out the util module, it's inspect function is special
    A.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
    !(A.constructor && A.constructor.prototype === A)) {
      var D = A.inspect(B, m);
      return V(D) || (D = F(m, D, B)), D;
    }
    var W = E(m, A);
    if (W)
      return W;
    var o = Object.keys(A), a = T(o);
    if (m.showHidden && (o = Object.getOwnPropertyNames(A)), ee(A) && (o.indexOf("message") >= 0 || o.indexOf("description") >= 0))
      return j(A);
    if (o.length === 0) {
      if (ue(A)) {
        var w = A.name ? ": " + A.name : "";
        return m.stylize("[Function" + w + "]", "special");
      }
      if (de(A))
        return m.stylize(RegExp.prototype.toString.call(A), "regexp");
      if (he(A))
        return m.stylize(Date.prototype.toString.call(A), "date");
      if (ee(A))
        return j(A);
    }
    var _ = "", $ = !1, C = ["{", "}"];
    if (Q(A) && ($ = !0, C = ["[", "]"]), ue(A)) {
      var k = A.name ? ": " + A.name : "";
      _ = " [Function" + k + "]";
    }
    if (de(A) && (_ = " " + RegExp.prototype.toString.call(A)), he(A) && (_ = " " + Date.prototype.toUTCString.call(A)), ee(A) && (_ = " " + j(A)), o.length === 0 && (!$ || A.length == 0))
      return C[0] + _ + C[1];
    if (B < 0)
      return de(A) ? m.stylize(RegExp.prototype.toString.call(A), "regexp") : m.stylize("[Object]", "special");
    m.seen.push(A);
    var oe;
    return $ ? oe = U(m, A, B, a, o) : oe = o.map(function(Se) {
      return q(m, A, B, a, Se, $);
    }), m.seen.pop(), N(oe, _, C);
  }
  function E(m, A) {
    if (ie(A))
      return m.stylize("undefined", "undefined");
    if (V(A)) {
      var B = "'" + JSON.stringify(A).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return m.stylize(B, "string");
    }
    if (z(A))
      return m.stylize("" + A, "number");
    if (x(A))
      return m.stylize("" + A, "boolean");
    if (R(A))
      return m.stylize("null", "null");
  }
  function j(m) {
    return "[" + Error.prototype.toString.call(m) + "]";
  }
  function U(m, A, B, D, W) {
    for (var o = [], a = 0, w = A.length; a < w; ++a)
      y(A, String(a)) ? o.push(q(
        m,
        A,
        B,
        D,
        String(a),
        !0
      )) : o.push("");
    return W.forEach(function(_) {
      _.match(/^\d+$/) || o.push(q(
        m,
        A,
        B,
        D,
        _,
        !0
      ));
    }), o;
  }
  function q(m, A, B, D, W, o) {
    var a, w, _;
    if (_ = Object.getOwnPropertyDescriptor(A, W) || { value: A[W] }, _.get ? _.set ? w = m.stylize("[Getter/Setter]", "special") : w = m.stylize("[Getter]", "special") : _.set && (w = m.stylize("[Setter]", "special")), y(D, W) || (a = "[" + W + "]"), w || (m.seen.indexOf(_.value) < 0 ? (R(B) ? w = F(m, _.value, null) : w = F(m, _.value, B - 1), w.indexOf(`
`) > -1 && (o ? w = w.split(`
`).map(function($) {
      return "  " + $;
    }).join(`
`).slice(2) : w = `
` + w.split(`
`).map(function($) {
      return "   " + $;
    }).join(`
`))) : w = m.stylize("[Circular]", "special")), ie(a)) {
      if (o && W.match(/^\d+$/))
        return w;
      a = JSON.stringify("" + W), a.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (a = a.slice(1, -1), a = m.stylize(a, "name")) : (a = a.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), a = m.stylize(a, "string"));
    }
    return a + ": " + w;
  }
  function N(m, A, B) {
    var D = m.reduce(function(W, o) {
      return o.indexOf(`
`) >= 0, W + o.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return D > 60 ? B[0] + (A === "" ? "" : A + `
 `) + " " + m.join(`,
  `) + " " + B[1] : B[0] + A + " " + m.join(", ") + " " + B[1];
  }
  e.types = qn;
  function Q(m) {
    return Array.isArray(m);
  }
  e.isArray = Q;
  function x(m) {
    return typeof m == "boolean";
  }
  e.isBoolean = x;
  function R(m) {
    return m === null;
  }
  e.isNull = R;
  function L(m) {
    return m == null;
  }
  e.isNullOrUndefined = L;
  function z(m) {
    return typeof m == "number";
  }
  e.isNumber = z;
  function V(m) {
    return typeof m == "string";
  }
  e.isString = V;
  function Ee(m) {
    return typeof m == "symbol";
  }
  e.isSymbol = Ee;
  function ie(m) {
    return m === void 0;
  }
  e.isUndefined = ie;
  function de(m) {
    return ce(m) && K(m) === "[object RegExp]";
  }
  e.isRegExp = de, e.types.isRegExp = de;
  function ce(m) {
    return typeof m == "object" && m !== null;
  }
  e.isObject = ce;
  function he(m) {
    return ce(m) && K(m) === "[object Date]";
  }
  e.isDate = he, e.types.isDate = he;
  function ee(m) {
    return ce(m) && (K(m) === "[object Error]" || m instanceof Error);
  }
  e.isError = ee, e.types.isNativeError = ee;
  function ue(m) {
    return typeof m == "function";
  }
  e.isFunction = ue;
  function ve(m) {
    return m === null || typeof m == "boolean" || typeof m == "number" || typeof m == "string" || typeof m == "symbol" || // ES6 symbol
    typeof m > "u";
  }
  e.isPrimitive = ve, e.isBuffer = Ha;
  function K(m) {
    return Object.prototype.toString.call(m);
  }
  function ge(m) {
    return m < 10 ? "0" + m.toString(10) : m.toString(10);
  }
  var me = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function h() {
    var m = /* @__PURE__ */ new Date(), A = [
      ge(m.getHours()),
      ge(m.getMinutes()),
      ge(m.getSeconds())
    ].join(":");
    return [m.getDate(), me[m.getMonth()], A].join(" ");
  }
  e.log = function() {
    console.log("%s - %s", h(), e.format.apply(e, arguments));
  }, e.inherits = Pe, e._extend = function(m, A) {
    if (!A || !ce(A))
      return m;
    for (var B = Object.keys(A), D = B.length; D--; )
      m[B[D]] = A[B[D]];
    return m;
  };
  function y(m, A) {
    return Object.prototype.hasOwnProperty.call(m, A);
  }
  var b = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  e.promisify = function(A) {
    if (typeof A != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (b && A[b]) {
      var B = A[b];
      if (typeof B != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(B, b, {
        value: B,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), B;
    }
    function B() {
      for (var D, W, o = new Promise(function(_, $) {
        D = _, W = $;
      }), a = [], w = 0; w < arguments.length; w++)
        a.push(arguments[w]);
      a.push(function(_, $) {
        _ ? W(_) : D($);
      });
      try {
        A.apply(this, a);
      } catch (_) {
        W(_);
      }
      return o;
    }
    return Object.setPrototypeOf(B, Object.getPrototypeOf(A)), b && Object.defineProperty(B, b, {
      value: B,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      B,
      t(A)
    );
  }, e.promisify.custom = b;
  function P(m, A) {
    if (!m) {
      var B = new Error("Promise was rejected with a falsy value");
      B.reason = m, m = B;
    }
    return A(m);
  }
  function I(m) {
    if (typeof m != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function A() {
      for (var B = [], D = 0; D < arguments.length; D++)
        B.push(arguments[D]);
      var W = B.pop();
      if (typeof W != "function")
        throw new TypeError("The last argument must be of type Function");
      var o = this, a = function() {
        return W.apply(o, arguments);
      };
      m.apply(this, B).then(
        function(w) {
          J.process.nextTick(a.bind(null, null, w));
        },
        function(w) {
          J.process.nextTick(P.bind(null, w, a));
        }
      );
    }
    return Object.setPrototypeOf(A, Object.getPrototypeOf(m)), Object.defineProperties(
      A,
      t(m)
    ), A;
  }
  e.callbackify = I;
})(wt);
var lr = { exports: {} }, un;
function Ga() {
  return un || (un = 1, function(e) {
    function t(d, l) {
      if (!(d instanceof l))
        throw new TypeError("Cannot call a class as a function");
    }
    var n = Lr.Buffer, s = wt;
    function u(d, l, f) {
      d.copy(l, f);
    }
    e.exports = function() {
      function d() {
        t(this, d), this.head = null, this.tail = null, this.length = 0;
      }
      return d.prototype.push = function(f) {
        var g = { data: f, next: null };
        this.length > 0 ? this.tail.next = g : this.head = g, this.tail = g, ++this.length;
      }, d.prototype.unshift = function(f) {
        var g = { data: f, next: this.head };
        this.length === 0 && (this.tail = g), this.head = g, ++this.length;
      }, d.prototype.shift = function() {
        if (this.length !== 0) {
          var f = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, f;
        }
      }, d.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, d.prototype.join = function(f) {
        if (this.length === 0)
          return "";
        for (var g = this.head, T = "" + g.data; g = g.next; )
          T += f + g.data;
        return T;
      }, d.prototype.concat = function(f) {
        if (this.length === 0)
          return n.alloc(0);
        for (var g = n.allocUnsafe(f >>> 0), T = this.head, F = 0; T; )
          u(T.data, g, F), F += T.data.length, T = T.next;
        return g;
      }, d;
    }(), s && s.inspect && s.inspect.custom && (e.exports.prototype[s.inspect.custom] = function() {
      var d = s.inspect({ length: this.length });
      return this.constructor.name + " " + d;
    });
  }(lr)), lr.exports;
}
var Et = Ge;
function za(e, t) {
  var n = this, s = this._readableState && this._readableState.destroyed, u = this._writableState && this._writableState.destroyed;
  return s || u ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, Et.nextTick(St, this, e)) : Et.nextTick(St, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(d) {
    !t && d ? n._writableState ? n._writableState.errorEmitted || (n._writableState.errorEmitted = !0, Et.nextTick(St, n, d)) : Et.nextTick(St, n, d) : t && t(d);
  }), this);
}
function Ja() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function St(e, t) {
  e.emit("error", t);
}
var ci = {
  destroy: za,
  undestroy: Ja
}, li = Xa;
function Xa(e, t) {
  if (dr("noDeprecation"))
    return e;
  var n = !1;
  function s() {
    if (!n) {
      if (dr("throwDeprecation"))
        throw new Error(t);
      dr("traceDeprecation") ? console.trace(t) : console.warn(t), n = !0;
    }
    return e.apply(this, arguments);
  }
  return s;
}
function dr(e) {
  try {
    if (!te.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var t = te.localStorage[e];
  return t == null ? !1 : String(t).toLowerCase() === "true";
}
var hr, fn;
function di() {
  if (fn)
    return hr;
  fn = 1;
  var e = Ge;
  hr = N;
  function t(h) {
    var y = this;
    this.next = null, this.entry = null, this.finish = function() {
      me(y, h);
    };
  }
  var n = !J.process.browser && ["v0.10", "v0.9."].indexOf(J.process.version.slice(0, 5)) > -1 ? setImmediate : e.nextTick, s;
  N.WritableState = U;
  var u = Object.create(re);
  u.inherits = Pe;
  var d = {
    deprecate: li
  }, l = Ln, f = Lr.Buffer, g = (typeof te < "u" ? te : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function T(h) {
    return f.from(h);
  }
  function F(h) {
    return f.isBuffer(h) || h instanceof g;
  }
  var E = ci;
  u.inherits(N, l);
  function j() {
  }
  function U(h, y) {
    s = s || ut(), h = h || {};
    var b = y instanceof s;
    this.objectMode = !!h.objectMode, b && (this.objectMode = this.objectMode || !!h.writableObjectMode);
    var P = h.highWaterMark, I = h.writableHighWaterMark, m = this.objectMode ? 16 : 16 * 1024;
    P || P === 0 ? this.highWaterMark = P : b && (I || I === 0) ? this.highWaterMark = I : this.highWaterMark = m, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var A = h.decodeStrings === !1;
    this.decodeStrings = !A, this.defaultEncoding = h.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(B) {
      ie(y, B);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  U.prototype.getBuffer = function() {
    for (var y = this.bufferedRequest, b = []; y; )
      b.push(y), y = y.next;
    return b;
  }, function() {
    try {
      Object.defineProperty(U.prototype, "buffer", {
        get: d.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var q;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (q = Function.prototype[Symbol.hasInstance], Object.defineProperty(N, Symbol.hasInstance, {
    value: function(h) {
      return q.call(this, h) ? !0 : this !== N ? !1 : h && h._writableState instanceof U;
    }
  })) : q = function(h) {
    return h instanceof this;
  };
  function N(h) {
    if (s = s || ut(), !q.call(N, this) && !(this instanceof s))
      return new N(h);
    this._writableState = new U(h, this), this.writable = !0, h && (typeof h.write == "function" && (this._write = h.write), typeof h.writev == "function" && (this._writev = h.writev), typeof h.destroy == "function" && (this._destroy = h.destroy), typeof h.final == "function" && (this._final = h.final)), l.call(this);
  }
  N.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function Q(h, y) {
    var b = new Error("write after end");
    h.emit("error", b), e.nextTick(y, b);
  }
  function x(h, y, b, P) {
    var I = !0, m = !1;
    return b === null ? m = new TypeError("May not write null values to stream") : typeof b != "string" && b !== void 0 && !y.objectMode && (m = new TypeError("Invalid non-string/buffer chunk")), m && (h.emit("error", m), e.nextTick(P, m), I = !1), I;
  }
  N.prototype.write = function(h, y, b) {
    var P = this._writableState, I = !1, m = !P.objectMode && F(h);
    return m && !f.isBuffer(h) && (h = T(h)), typeof y == "function" && (b = y, y = null), m ? y = "buffer" : y || (y = P.defaultEncoding), typeof b != "function" && (b = j), P.ended ? Q(this, b) : (m || x(this, P, h, b)) && (P.pendingcb++, I = L(this, P, m, h, y, b)), I;
  }, N.prototype.cork = function() {
    var h = this._writableState;
    h.corked++;
  }, N.prototype.uncork = function() {
    var h = this._writableState;
    h.corked && (h.corked--, !h.writing && !h.corked && !h.bufferProcessing && h.bufferedRequest && he(this, h));
  }, N.prototype.setDefaultEncoding = function(y) {
    if (typeof y == "string" && (y = y.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((y + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + y);
    return this._writableState.defaultEncoding = y, this;
  };
  function R(h, y, b) {
    return !h.objectMode && h.decodeStrings !== !1 && typeof y == "string" && (y = f.from(y, b)), y;
  }
  Object.defineProperty(N.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function L(h, y, b, P, I, m) {
    if (!b) {
      var A = R(y, P, I);
      P !== A && (b = !0, I = "buffer", P = A);
    }
    var B = y.objectMode ? 1 : P.length;
    y.length += B;
    var D = y.length < y.highWaterMark;
    if (D || (y.needDrain = !0), y.writing || y.corked) {
      var W = y.lastBufferedRequest;
      y.lastBufferedRequest = {
        chunk: P,
        encoding: I,
        isBuf: b,
        callback: m,
        next: null
      }, W ? W.next = y.lastBufferedRequest : y.bufferedRequest = y.lastBufferedRequest, y.bufferedRequestCount += 1;
    } else
      z(h, y, !1, B, P, I, m);
    return D;
  }
  function z(h, y, b, P, I, m, A) {
    y.writelen = P, y.writecb = A, y.writing = !0, y.sync = !0, b ? h._writev(I, y.onwrite) : h._write(I, m, y.onwrite), y.sync = !1;
  }
  function V(h, y, b, P, I) {
    --y.pendingcb, b ? (e.nextTick(I, P), e.nextTick(K, h, y), h._writableState.errorEmitted = !0, h.emit("error", P)) : (I(P), h._writableState.errorEmitted = !0, h.emit("error", P), K(h, y));
  }
  function Ee(h) {
    h.writing = !1, h.writecb = null, h.length -= h.writelen, h.writelen = 0;
  }
  function ie(h, y) {
    var b = h._writableState, P = b.sync, I = b.writecb;
    if (Ee(b), y)
      V(h, b, P, y, I);
    else {
      var m = ee(b);
      !m && !b.corked && !b.bufferProcessing && b.bufferedRequest && he(h, b), P ? n(de, h, b, m, I) : de(h, b, m, I);
    }
  }
  function de(h, y, b, P) {
    b || ce(h, y), y.pendingcb--, P(), K(h, y);
  }
  function ce(h, y) {
    y.length === 0 && y.needDrain && (y.needDrain = !1, h.emit("drain"));
  }
  function he(h, y) {
    y.bufferProcessing = !0;
    var b = y.bufferedRequest;
    if (h._writev && b && b.next) {
      var P = y.bufferedRequestCount, I = new Array(P), m = y.corkedRequestsFree;
      m.entry = b;
      for (var A = 0, B = !0; b; )
        I[A] = b, b.isBuf || (B = !1), b = b.next, A += 1;
      I.allBuffers = B, z(h, y, !0, y.length, I, "", m.finish), y.pendingcb++, y.lastBufferedRequest = null, m.next ? (y.corkedRequestsFree = m.next, m.next = null) : y.corkedRequestsFree = new t(y), y.bufferedRequestCount = 0;
    } else {
      for (; b; ) {
        var D = b.chunk, W = b.encoding, o = b.callback, a = y.objectMode ? 1 : D.length;
        if (z(h, y, !1, a, D, W, o), b = b.next, y.bufferedRequestCount--, y.writing)
          break;
      }
      b === null && (y.lastBufferedRequest = null);
    }
    y.bufferedRequest = b, y.bufferProcessing = !1;
  }
  N.prototype._write = function(h, y, b) {
    b(new Error("_write() is not implemented"));
  }, N.prototype._writev = null, N.prototype.end = function(h, y, b) {
    var P = this._writableState;
    typeof h == "function" ? (b = h, h = null, y = null) : typeof y == "function" && (b = y, y = null), h != null && this.write(h, y), P.corked && (P.corked = 1, this.uncork()), P.ending || ge(this, P, b);
  };
  function ee(h) {
    return h.ending && h.length === 0 && h.bufferedRequest === null && !h.finished && !h.writing;
  }
  function ue(h, y) {
    h._final(function(b) {
      y.pendingcb--, b && h.emit("error", b), y.prefinished = !0, h.emit("prefinish"), K(h, y);
    });
  }
  function ve(h, y) {
    !y.prefinished && !y.finalCalled && (typeof h._final == "function" ? (y.pendingcb++, y.finalCalled = !0, e.nextTick(ue, h, y)) : (y.prefinished = !0, h.emit("prefinish")));
  }
  function K(h, y) {
    var b = ee(y);
    return b && (ve(h, y), y.pendingcb === 0 && (y.finished = !0, h.emit("finish"))), b;
  }
  function ge(h, y, b) {
    y.ending = !0, K(h, y), b && (y.finished ? e.nextTick(b) : h.once("finish", b)), y.ended = !0, h.writable = !1;
  }
  function me(h, y, b) {
    var P = h.entry;
    for (h.entry = null; P; ) {
      var I = P.callback;
      y.pendingcb--, I(b), P = P.next;
    }
    y.corkedRequestsFree.next = h;
  }
  return Object.defineProperty(N.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(h) {
      this._writableState && (this._writableState.destroyed = h);
    }
  }), N.prototype.destroy = E.destroy, N.prototype._undestroy = E.undestroy, N.prototype._destroy = function(h, y) {
    this.end(), y(h);
  }, hr;
}
var pr, cn;
function ut() {
  if (cn)
    return pr;
  cn = 1;
  var e = Ge, t = Object.keys || function(E) {
    var j = [];
    for (var U in E)
      j.push(U);
    return j;
  };
  pr = g;
  var n = Object.create(re);
  n.inherits = Pe;
  var s = hi(), u = di();
  n.inherits(g, s);
  for (var d = t(u.prototype), l = 0; l < d.length; l++) {
    var f = d[l];
    g.prototype[f] || (g.prototype[f] = u.prototype[f]);
  }
  function g(E) {
    if (!(this instanceof g))
      return new g(E);
    s.call(this, E), u.call(this, E), E && E.readable === !1 && (this.readable = !1), E && E.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, E && E.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", T);
  }
  Object.defineProperty(g.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function T() {
    this.allowHalfOpen || this._writableState.ended || e.nextTick(F, this);
  }
  function F(E) {
    E.end();
  }
  return Object.defineProperty(g.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(E) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = E, this._writableState.destroyed = E);
    }
  }), g.prototype._destroy = function(E, j) {
    this.push(null), this.end(), e.nextTick(j, E);
  }, pr;
}
var yr = {}, At = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var ln;
function Ka() {
  return ln || (ln = 1, function(e, t) {
    var n = ct, s = n.Buffer;
    function u(l, f) {
      for (var g in l)
        f[g] = l[g];
    }
    s.from && s.alloc && s.allocUnsafe && s.allocUnsafeSlow ? e.exports = n : (u(n, t), t.Buffer = d);
    function d(l, f, g) {
      return s(l, f, g);
    }
    d.prototype = Object.create(s.prototype), u(s, d), d.from = function(l, f, g) {
      if (typeof l == "number")
        throw new TypeError("Argument must not be a number");
      return s(l, f, g);
    }, d.alloc = function(l, f, g) {
      if (typeof l != "number")
        throw new TypeError("Argument must be a number");
      var T = s(l);
      return f !== void 0 ? typeof g == "string" ? T.fill(f, g) : T.fill(f) : T.fill(0), T;
    }, d.allocUnsafe = function(l) {
      if (typeof l != "number")
        throw new TypeError("Argument must be a number");
      return s(l);
    }, d.allocUnsafeSlow = function(l) {
      if (typeof l != "number")
        throw new TypeError("Argument must be a number");
      return n.SlowBuffer(l);
    };
  }(At, At.exports)), At.exports;
}
var dn;
function kt() {
  if (dn)
    return yr;
  dn = 1;
  var e = Ka().Buffer, t = e.isEncoding || function(x) {
    switch (x = "" + x, x && x.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function n(x) {
    if (!x)
      return "utf8";
    for (var R; ; )
      switch (x) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return x;
        default:
          if (R)
            return;
          x = ("" + x).toLowerCase(), R = !0;
      }
  }
  function s(x) {
    var R = n(x);
    if (typeof R != "string" && (e.isEncoding === t || !t(x)))
      throw new Error("Unknown encoding: " + x);
    return R || x;
  }
  yr.StringDecoder = u;
  function u(x) {
    this.encoding = s(x);
    var R;
    switch (this.encoding) {
      case "utf16le":
        this.text = E, this.end = j, R = 4;
        break;
      case "utf8":
        this.fillLast = g, R = 4;
        break;
      case "base64":
        this.text = U, this.end = q, R = 3;
        break;
      default:
        this.write = N, this.end = Q;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(R);
  }
  u.prototype.write = function(x) {
    if (x.length === 0)
      return "";
    var R, L;
    if (this.lastNeed) {
      if (R = this.fillLast(x), R === void 0)
        return "";
      L = this.lastNeed, this.lastNeed = 0;
    } else
      L = 0;
    return L < x.length ? R ? R + this.text(x, L) : this.text(x, L) : R || "";
  }, u.prototype.end = F, u.prototype.text = T, u.prototype.fillLast = function(x) {
    if (this.lastNeed <= x.length)
      return x.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    x.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, x.length), this.lastNeed -= x.length;
  };
  function d(x) {
    return x <= 127 ? 0 : x >> 5 === 6 ? 2 : x >> 4 === 14 ? 3 : x >> 3 === 30 ? 4 : x >> 6 === 2 ? -1 : -2;
  }
  function l(x, R, L) {
    var z = R.length - 1;
    if (z < L)
      return 0;
    var V = d(R[z]);
    return V >= 0 ? (V > 0 && (x.lastNeed = V - 1), V) : --z < L || V === -2 ? 0 : (V = d(R[z]), V >= 0 ? (V > 0 && (x.lastNeed = V - 2), V) : --z < L || V === -2 ? 0 : (V = d(R[z]), V >= 0 ? (V > 0 && (V === 2 ? V = 0 : x.lastNeed = V - 3), V) : 0));
  }
  function f(x, R, L) {
    if ((R[0] & 192) !== 128)
      return x.lastNeed = 0, "�";
    if (x.lastNeed > 1 && R.length > 1) {
      if ((R[1] & 192) !== 128)
        return x.lastNeed = 1, "�";
      if (x.lastNeed > 2 && R.length > 2 && (R[2] & 192) !== 128)
        return x.lastNeed = 2, "�";
    }
  }
  function g(x) {
    var R = this.lastTotal - this.lastNeed, L = f(this, x);
    if (L !== void 0)
      return L;
    if (this.lastNeed <= x.length)
      return x.copy(this.lastChar, R, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    x.copy(this.lastChar, R, 0, x.length), this.lastNeed -= x.length;
  }
  function T(x, R) {
    var L = l(this, x, R);
    if (!this.lastNeed)
      return x.toString("utf8", R);
    this.lastTotal = L;
    var z = x.length - (L - this.lastNeed);
    return x.copy(this.lastChar, 0, z), x.toString("utf8", R, z);
  }
  function F(x) {
    var R = x && x.length ? this.write(x) : "";
    return this.lastNeed ? R + "�" : R;
  }
  function E(x, R) {
    if ((x.length - R) % 2 === 0) {
      var L = x.toString("utf16le", R);
      if (L) {
        var z = L.charCodeAt(L.length - 1);
        if (z >= 55296 && z <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = x[x.length - 2], this.lastChar[1] = x[x.length - 1], L.slice(0, -1);
      }
      return L;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = x[x.length - 1], x.toString("utf16le", R, x.length - 1);
  }
  function j(x) {
    var R = x && x.length ? this.write(x) : "";
    if (this.lastNeed) {
      var L = this.lastTotal - this.lastNeed;
      return R + this.lastChar.toString("utf16le", 0, L);
    }
    return R;
  }
  function U(x, R) {
    var L = (x.length - R) % 3;
    return L === 0 ? x.toString("base64", R) : (this.lastNeed = 3 - L, this.lastTotal = 3, L === 1 ? this.lastChar[0] = x[x.length - 1] : (this.lastChar[0] = x[x.length - 2], this.lastChar[1] = x[x.length - 1]), x.toString("base64", R, x.length - L));
  }
  function q(x) {
    var R = x && x.length ? this.write(x) : "";
    return this.lastNeed ? R + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : R;
  }
  function N(x) {
    return x.toString(this.encoding);
  }
  function Q(x) {
    return x && x.length ? this.write(x) : "";
  }
  return yr;
}
var gr, hn;
function hi() {
  if (hn)
    return gr;
  hn = 1;
  var e = Ge;
  gr = R;
  var t = po, n;
  R.ReadableState = x, lt.EventEmitter;
  var s = function(o, a) {
    return o.listeners(a).length;
  }, u = Ln, d = Lr.Buffer, l = (typeof te < "u" ? te : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function f(o) {
    return d.from(o);
  }
  function g(o) {
    return d.isBuffer(o) || o instanceof l;
  }
  var T = Object.create(re);
  T.inherits = Pe;
  var F = wt, E = void 0;
  F && F.debuglog ? E = F.debuglog("stream") : E = function() {
  };
  var j = Ga(), U = ci, q;
  T.inherits(R, u);
  var N = ["error", "close", "destroy", "pause", "resume"];
  function Q(o, a, w) {
    if (typeof o.prependListener == "function")
      return o.prependListener(a, w);
    !o._events || !o._events[a] ? o.on(a, w) : t(o._events[a]) ? o._events[a].unshift(w) : o._events[a] = [w, o._events[a]];
  }
  function x(o, a) {
    n = n || ut(), o = o || {};
    var w = a instanceof n;
    this.objectMode = !!o.objectMode, w && (this.objectMode = this.objectMode || !!o.readableObjectMode);
    var _ = o.highWaterMark, $ = o.readableHighWaterMark, C = this.objectMode ? 16 : 16 * 1024;
    _ || _ === 0 ? this.highWaterMark = _ : w && ($ || $ === 0) ? this.highWaterMark = $ : this.highWaterMark = C, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new j(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = o.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, o.encoding && (q || (q = kt().StringDecoder), this.decoder = new q(o.encoding), this.encoding = o.encoding);
  }
  function R(o) {
    if (n = n || ut(), !(this instanceof R))
      return new R(o);
    this._readableState = new x(o, this), this.readable = !0, o && (typeof o.read == "function" && (this._read = o.read), typeof o.destroy == "function" && (this._destroy = o.destroy)), u.call(this);
  }
  Object.defineProperty(R.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(o) {
      this._readableState && (this._readableState.destroyed = o);
    }
  }), R.prototype.destroy = U.destroy, R.prototype._undestroy = U.undestroy, R.prototype._destroy = function(o, a) {
    this.push(null), a(o);
  }, R.prototype.push = function(o, a) {
    var w = this._readableState, _;
    return w.objectMode ? _ = !0 : typeof o == "string" && (a = a || w.defaultEncoding, a !== w.encoding && (o = d.from(o, a), a = ""), _ = !0), L(this, o, a, !1, _);
  }, R.prototype.unshift = function(o) {
    return L(this, o, null, !0, !1);
  };
  function L(o, a, w, _, $) {
    var C = o._readableState;
    if (a === null)
      C.reading = !1, he(o, C);
    else {
      var k;
      $ || (k = V(C, a)), k ? o.emit("error", k) : C.objectMode || a && a.length > 0 ? (typeof a != "string" && !C.objectMode && Object.getPrototypeOf(a) !== d.prototype && (a = f(a)), _ ? C.endEmitted ? o.emit("error", new Error("stream.unshift() after end event")) : z(o, C, a, !0) : C.ended ? o.emit("error", new Error("stream.push() after EOF")) : (C.reading = !1, C.decoder && !w ? (a = C.decoder.write(a), C.objectMode || a.length !== 0 ? z(o, C, a, !1) : ve(o, C)) : z(o, C, a, !1))) : _ || (C.reading = !1);
    }
    return Ee(C);
  }
  function z(o, a, w, _) {
    a.flowing && a.length === 0 && !a.sync ? (o.emit("data", w), o.read(0)) : (a.length += a.objectMode ? 1 : w.length, _ ? a.buffer.unshift(w) : a.buffer.push(w), a.needReadable && ee(o)), ve(o, a);
  }
  function V(o, a) {
    var w;
    return !g(a) && typeof a != "string" && a !== void 0 && !o.objectMode && (w = new TypeError("Invalid non-string/buffer chunk")), w;
  }
  function Ee(o) {
    return !o.ended && (o.needReadable || o.length < o.highWaterMark || o.length === 0);
  }
  R.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, R.prototype.setEncoding = function(o) {
    return q || (q = kt().StringDecoder), this._readableState.decoder = new q(o), this._readableState.encoding = o, this;
  };
  var ie = 8388608;
  function de(o) {
    return o >= ie ? o = ie : (o--, o |= o >>> 1, o |= o >>> 2, o |= o >>> 4, o |= o >>> 8, o |= o >>> 16, o++), o;
  }
  function ce(o, a) {
    return o <= 0 || a.length === 0 && a.ended ? 0 : a.objectMode ? 1 : o !== o ? a.flowing && a.length ? a.buffer.head.data.length : a.length : (o > a.highWaterMark && (a.highWaterMark = de(o)), o <= a.length ? o : a.ended ? a.length : (a.needReadable = !0, 0));
  }
  R.prototype.read = function(o) {
    E("read", o), o = parseInt(o, 10);
    var a = this._readableState, w = o;
    if (o !== 0 && (a.emittedReadable = !1), o === 0 && a.needReadable && (a.length >= a.highWaterMark || a.ended))
      return E("read: emitReadable", a.length, a.ended), a.length === 0 && a.ended ? B(this) : ee(this), null;
    if (o = ce(o, a), o === 0 && a.ended)
      return a.length === 0 && B(this), null;
    var _ = a.needReadable;
    E("need readable", _), (a.length === 0 || a.length - o < a.highWaterMark) && (_ = !0, E("length less than watermark", _)), a.ended || a.reading ? (_ = !1, E("reading or ended", _)) : _ && (E("do read"), a.reading = !0, a.sync = !0, a.length === 0 && (a.needReadable = !0), this._read(a.highWaterMark), a.sync = !1, a.reading || (o = ce(w, a)));
    var $;
    return o > 0 ? $ = P(o, a) : $ = null, $ === null ? (a.needReadable = !0, o = 0) : a.length -= o, a.length === 0 && (a.ended || (a.needReadable = !0), w !== o && a.ended && B(this)), $ !== null && this.emit("data", $), $;
  };
  function he(o, a) {
    if (!a.ended) {
      if (a.decoder) {
        var w = a.decoder.end();
        w && w.length && (a.buffer.push(w), a.length += a.objectMode ? 1 : w.length);
      }
      a.ended = !0, ee(o);
    }
  }
  function ee(o) {
    var a = o._readableState;
    a.needReadable = !1, a.emittedReadable || (E("emitReadable", a.flowing), a.emittedReadable = !0, a.sync ? e.nextTick(ue, o) : ue(o));
  }
  function ue(o) {
    E("emit readable"), o.emit("readable"), b(o);
  }
  function ve(o, a) {
    a.readingMore || (a.readingMore = !0, e.nextTick(K, o, a));
  }
  function K(o, a) {
    for (var w = a.length; !a.reading && !a.flowing && !a.ended && a.length < a.highWaterMark && (E("maybeReadMore read 0"), o.read(0), w !== a.length); )
      w = a.length;
    a.readingMore = !1;
  }
  R.prototype._read = function(o) {
    this.emit("error", new Error("_read() is not implemented"));
  }, R.prototype.pipe = function(o, a) {
    var w = this, _ = this._readableState;
    switch (_.pipesCount) {
      case 0:
        _.pipes = o;
        break;
      case 1:
        _.pipes = [_.pipes, o];
        break;
      default:
        _.pipes.push(o);
        break;
    }
    _.pipesCount += 1, E("pipe count=%d opts=%j", _.pipesCount, a);
    var $ = (!a || a.end !== !1) && o !== J.process.stdout && o !== J.process.stderr, C = $ ? oe : be;
    _.endEmitted ? e.nextTick(C) : w.once("end", C), o.on("unpipe", k);
    function k(_e, le) {
      E("onunpipe"), _e === w && le && le.hasUnpiped === !1 && (le.hasUnpiped = !0, Ne());
    }
    function oe() {
      E("onend"), o.end();
    }
    var Se = ge(w);
    o.on("drain", Se);
    var Ce = !1;
    function Ne() {
      E("cleanup"), o.removeListener("close", Ae), o.removeListener("finish", pe), o.removeListener("drain", Se), o.removeListener("error", xe), o.removeListener("unpipe", k), w.removeListener("end", oe), w.removeListener("end", be), w.removeListener("data", O), Ce = !0, _.awaitDrain && (!o._writableState || o._writableState.needDrain) && Se();
    }
    var Be = !1;
    w.on("data", O);
    function O(_e) {
      E("ondata"), Be = !1;
      var le = o.write(_e);
      le === !1 && !Be && ((_.pipesCount === 1 && _.pipes === o || _.pipesCount > 1 && W(_.pipes, o) !== -1) && !Ce && (E("false write response, pause", _.awaitDrain), _.awaitDrain++, Be = !0), w.pause());
    }
    function xe(_e) {
      E("onerror", _e), be(), o.removeListener("error", xe), s(o, "error") === 0 && o.emit("error", _e);
    }
    Q(o, "error", xe);
    function Ae() {
      o.removeListener("finish", pe), be();
    }
    o.once("close", Ae);
    function pe() {
      E("onfinish"), o.removeListener("close", Ae), be();
    }
    o.once("finish", pe);
    function be() {
      E("unpipe"), w.unpipe(o);
    }
    return o.emit("pipe", w), _.flowing || (E("pipe resume"), w.resume()), o;
  };
  function ge(o) {
    return function() {
      var a = o._readableState;
      E("pipeOnDrain", a.awaitDrain), a.awaitDrain && a.awaitDrain--, a.awaitDrain === 0 && s(o, "data") && (a.flowing = !0, b(o));
    };
  }
  R.prototype.unpipe = function(o) {
    var a = this._readableState, w = { hasUnpiped: !1 };
    if (a.pipesCount === 0)
      return this;
    if (a.pipesCount === 1)
      return o && o !== a.pipes ? this : (o || (o = a.pipes), a.pipes = null, a.pipesCount = 0, a.flowing = !1, o && o.emit("unpipe", this, w), this);
    if (!o) {
      var _ = a.pipes, $ = a.pipesCount;
      a.pipes = null, a.pipesCount = 0, a.flowing = !1;
      for (var C = 0; C < $; C++)
        _[C].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var k = W(a.pipes, o);
    return k === -1 ? this : (a.pipes.splice(k, 1), a.pipesCount -= 1, a.pipesCount === 1 && (a.pipes = a.pipes[0]), o.emit("unpipe", this, w), this);
  }, R.prototype.on = function(o, a) {
    var w = u.prototype.on.call(this, o, a);
    if (o === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (o === "readable") {
      var _ = this._readableState;
      !_.endEmitted && !_.readableListening && (_.readableListening = _.needReadable = !0, _.emittedReadable = !1, _.reading ? _.length && ee(this) : e.nextTick(me, this));
    }
    return w;
  }, R.prototype.addListener = R.prototype.on;
  function me(o) {
    E("readable nexttick read 0"), o.read(0);
  }
  R.prototype.resume = function() {
    var o = this._readableState;
    return o.flowing || (E("resume"), o.flowing = !0, h(this, o)), this;
  };
  function h(o, a) {
    a.resumeScheduled || (a.resumeScheduled = !0, e.nextTick(y, o, a));
  }
  function y(o, a) {
    a.reading || (E("resume read 0"), o.read(0)), a.resumeScheduled = !1, a.awaitDrain = 0, o.emit("resume"), b(o), a.flowing && !a.reading && o.read(0);
  }
  R.prototype.pause = function() {
    return E("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (E("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function b(o) {
    var a = o._readableState;
    for (E("flow", a.flowing); a.flowing && o.read() !== null; )
      ;
  }
  R.prototype.wrap = function(o) {
    var a = this, w = this._readableState, _ = !1;
    o.on("end", function() {
      if (E("wrapped end"), w.decoder && !w.ended) {
        var k = w.decoder.end();
        k && k.length && a.push(k);
      }
      a.push(null);
    }), o.on("data", function(k) {
      if (E("wrapped data"), w.decoder && (k = w.decoder.write(k)), !(w.objectMode && k == null) && !(!w.objectMode && (!k || !k.length))) {
        var oe = a.push(k);
        oe || (_ = !0, o.pause());
      }
    });
    for (var $ in o)
      this[$] === void 0 && typeof o[$] == "function" && (this[$] = function(k) {
        return function() {
          return o[k].apply(o, arguments);
        };
      }($));
    for (var C = 0; C < N.length; C++)
      o.on(N[C], this.emit.bind(this, N[C]));
    return this._read = function(k) {
      E("wrapped _read", k), _ && (_ = !1, o.resume());
    }, this;
  }, Object.defineProperty(R.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), R._fromList = P;
  function P(o, a) {
    if (a.length === 0)
      return null;
    var w;
    return a.objectMode ? w = a.buffer.shift() : !o || o >= a.length ? (a.decoder ? w = a.buffer.join("") : a.buffer.length === 1 ? w = a.buffer.head.data : w = a.buffer.concat(a.length), a.buffer.clear()) : w = I(o, a.buffer, a.decoder), w;
  }
  function I(o, a, w) {
    var _;
    return o < a.head.data.length ? (_ = a.head.data.slice(0, o), a.head.data = a.head.data.slice(o)) : o === a.head.data.length ? _ = a.shift() : _ = w ? m(o, a) : A(o, a), _;
  }
  function m(o, a) {
    var w = a.head, _ = 1, $ = w.data;
    for (o -= $.length; w = w.next; ) {
      var C = w.data, k = o > C.length ? C.length : o;
      if (k === C.length ? $ += C : $ += C.slice(0, o), o -= k, o === 0) {
        k === C.length ? (++_, w.next ? a.head = w.next : a.head = a.tail = null) : (a.head = w, w.data = C.slice(k));
        break;
      }
      ++_;
    }
    return a.length -= _, $;
  }
  function A(o, a) {
    var w = d.allocUnsafe(o), _ = a.head, $ = 1;
    for (_.data.copy(w), o -= _.data.length; _ = _.next; ) {
      var C = _.data, k = o > C.length ? C.length : o;
      if (C.copy(w, w.length - o, 0, k), o -= k, o === 0) {
        k === C.length ? (++$, _.next ? a.head = _.next : a.head = a.tail = null) : (a.head = _, _.data = C.slice(k));
        break;
      }
      ++$;
    }
    return a.length -= $, w;
  }
  function B(o) {
    var a = o._readableState;
    if (a.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    a.endEmitted || (a.ended = !0, e.nextTick(D, a, o));
  }
  function D(o, a) {
    !o.endEmitted && o.length === 0 && (o.endEmitted = !0, a.readable = !1, a.emit("end"));
  }
  function W(o, a) {
    for (var w = 0, _ = o.length; w < _; w++)
      if (o[w] === a)
        return w;
    return -1;
  }
  return gr;
}
var pi = Le, Ht = ut(), yi = Object.create(re);
yi.inherits = Pe;
yi.inherits(Le, Ht);
function Ya(e, t) {
  var n = this._transformState;
  n.transforming = !1;
  var s = n.writecb;
  if (!s)
    return this.emit("error", new Error("write callback called multiple times"));
  n.writechunk = null, n.writecb = null, t != null && this.push(t), s(e);
  var u = this._readableState;
  u.reading = !1, (u.needReadable || u.length < u.highWaterMark) && this._read(u.highWaterMark);
}
function Le(e) {
  if (!(this instanceof Le))
    return new Le(e);
  Ht.call(this, e), this._transformState = {
    afterTransform: Ya.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", Za);
}
function Za() {
  var e = this;
  typeof this._flush == "function" ? this._flush(function(t, n) {
    pn(e, t, n);
  }) : pn(this, null, null);
}
Le.prototype.push = function(e, t) {
  return this._transformState.needTransform = !1, Ht.prototype.push.call(this, e, t);
};
Le.prototype._transform = function(e, t, n) {
  throw new Error("_transform() is not implemented");
};
Le.prototype._write = function(e, t, n) {
  var s = this._transformState;
  if (s.writecb = n, s.writechunk = e, s.writeencoding = t, !s.transforming) {
    var u = this._readableState;
    (s.needTransform || u.needReadable || u.length < u.highWaterMark) && this._read(u.highWaterMark);
  }
};
Le.prototype._read = function(e) {
  var t = this._transformState;
  t.writechunk !== null && t.writecb && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
};
Le.prototype._destroy = function(e, t) {
  var n = this;
  Ht.prototype._destroy.call(this, e, function(s) {
    t(s), n.emit("close");
  });
};
function pn(e, t, n) {
  if (t)
    return e.emit("error", t);
  if (n != null && e.push(n), e._writableState.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (e._transformState.transforming)
    throw new Error("Calling transform done when still transforming");
  return e.push(null);
}
var Qa = pt, gi = pi, mi = Object.create(re);
mi.inherits = Pe;
mi.inherits(pt, gi);
function pt(e) {
  if (!(this instanceof pt))
    return new pt(e);
  gi.call(this, e);
}
pt.prototype._transform = function(e, t, n) {
  n(null, e);
};
(function(e, t) {
  t = e.exports = hi(), t.Stream = t, t.Readable = t, t.Writable = di(), t.Duplex = ut(), t.Transform = pi, t.PassThrough = Qa;
})(Sr, Sr.exports);
var wi = Sr.exports, Gr = { exports: {} }, es = vi;
function vi(e, t) {
  if (e && t)
    return vi(e)(t);
  if (typeof e != "function")
    throw new TypeError("need wrapper function");
  return Object.keys(e).forEach(function(s) {
    n[s] = e[s];
  }), n;
  function n() {
    for (var s = new Array(arguments.length), u = 0; u < s.length; u++)
      s[u] = arguments[u];
    var d = e.apply(this, s), l = s[s.length - 1];
    return typeof d == "function" && d !== l && Object.keys(l).forEach(function(f) {
      d[f] = l[f];
    }), d;
  }
}
var bi = es;
Gr.exports = bi(It);
Gr.exports.strict = bi(_i);
It.proto = It(function() {
  Object.defineProperty(Function.prototype, "once", {
    value: function() {
      return It(this);
    },
    configurable: !0
  }), Object.defineProperty(Function.prototype, "onceStrict", {
    value: function() {
      return _i(this);
    },
    configurable: !0
  });
});
function It(e) {
  var t = function() {
    return t.called ? t.value : (t.called = !0, t.value = e.apply(this, arguments));
  };
  return t.called = !1, t;
}
function _i(e) {
  var t = function() {
    if (t.called)
      throw new Error(t.onceError);
    return t.called = !0, t.value = e.apply(this, arguments);
  }, n = e.name || "Function wrapped with `once`";
  return t.onceError = n + " shouldn't be called more than once", t.called = !1, t;
}
var zr = Gr.exports, ts = zr, rs = function() {
}, ns = function(e) {
  return e.setHeader && typeof e.abort == "function";
}, is = function(e) {
  return e.stdio && Array.isArray(e.stdio) && e.stdio.length === 3;
}, Ei = function(e, t, n) {
  if (typeof t == "function")
    return Ei(e, null, t);
  t || (t = {}), n = ts(n || rs);
  var s = e._writableState, u = e._readableState, d = t.readable || t.readable !== !1 && e.readable, l = t.writable || t.writable !== !1 && e.writable, f = !1, g = function() {
    e.writable || T();
  }, T = function() {
    l = !1, d || n.call(e);
  }, F = function() {
    d = !1, l || n.call(e);
  }, E = function(Q) {
    n.call(e, Q ? new Error("exited with error code: " + Q) : null);
  }, j = function(Q) {
    n.call(e, Q);
  }, U = function() {
    J.process.nextTick(q);
  }, q = function() {
    if (!f) {
      if (d && !(u && u.ended && !u.destroyed))
        return n.call(e, new Error("premature close"));
      if (l && !(s && s.ended && !s.destroyed))
        return n.call(e, new Error("premature close"));
    }
  }, N = function() {
    e.req.on("finish", T);
  };
  return ns(e) ? (e.on("complete", T), e.on("abort", U), e.req ? N() : e.on("request", N)) : l && !s && (e.on("end", g), e.on("close", g)), is(e) && e.on("exit", E), e.on("end", F), e.on("finish", T), t.error !== !1 && e.on("error", j), e.on("close", U), function() {
    f = !0, e.removeListener("complete", T), e.removeListener("abort", U), e.removeListener("request", N), e.req && e.req.removeListener("finish", T), e.removeListener("end", g), e.removeListener("close", g), e.removeListener("finish", T), e.removeListener("exit", E), e.removeListener("end", F), e.removeListener("error", j), e.removeListener("close", U);
  };
}, Si = Ei, Gt = {};
Object.defineProperty(Gt, "__esModule", { value: !0 });
Gt.Substream = void 0;
const os = wi;
class as extends os.Duplex {
  constructor({ parent: t, name: n }) {
    super({ objectMode: !0 }), this._parent = t, this._name = n;
  }
  /**
   * Explicitly sets read operations to a no-op.
   */
  _read() {
  }
  /**
   * Called when data should be written to this writable stream.
   *
   * @param chunk - Arbitrary object to write
   * @param encoding - Encoding to use when writing payload
   * @param callback - Called when writing is complete or an error occurs
   */
  _write(t, n, s) {
    this._parent.push({
      name: this._name,
      data: t
    }), s();
  }
}
Gt.Substream = as;
var Ai = te && te.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Ut, "__esModule", { value: !0 });
Ut.ObjectMultiplex = void 0;
const ss = wi, yn = Ai(Si), us = Ai(zr), fs = Gt, gn = Symbol("IGNORE_SUBSTREAM");
let cs = class extends ss.Duplex {
  constructor(t = {}) {
    super(Object.assign(Object.assign({}, t), { objectMode: !0 })), this._substreams = {};
  }
  createStream(t) {
    if (this.destroyed)
      throw new Error(`ObjectMultiplex - parent stream for name "${t}" already destroyed`);
    if (this._readableState.ended || this._writableState.ended)
      throw new Error(`ObjectMultiplex - parent stream for name "${t}" already ended`);
    if (!t)
      throw new Error("ObjectMultiplex - name must not be empty");
    if (this._substreams[t])
      throw new Error(`ObjectMultiplex - Substream for name "${t}" already exists`);
    const n = new fs.Substream({ parent: this, name: t });
    return this._substreams[t] = n, ls(this, (s) => n.destroy(s || void 0)), n;
  }
  // ignore streams (dont display orphaned data warning)
  ignoreStream(t) {
    if (!t)
      throw new Error("ObjectMultiplex - name must not be empty");
    if (this._substreams[t])
      throw new Error(`ObjectMultiplex - Substream for name "${t}" already exists`);
    this._substreams[t] = gn;
  }
  _read() {
  }
  _write(t, n, s) {
    const { name: u, data: d } = t;
    if (!u)
      return console.warn(`ObjectMultiplex - malformed chunk without name "${t}"`), s();
    const l = this._substreams[u];
    return l ? (l !== gn && l.push(d), s()) : (console.warn(`ObjectMultiplex - orphaned data for stream "${u}"`), s());
  }
};
Ut.ObjectMultiplex = cs;
function ls(e, t) {
  const n = us.default(t);
  yn.default(e, { readable: !1 }, n), yn.default(e, { writable: !1 }, n);
}
const ds = Ut;
var hs = ds.ObjectMultiplex;
const ps = /* @__PURE__ */ Tn(hs);
var xi = {};
Object.defineProperty(xi, "__esModule", { value: !0 });
const ys = {
  errors: {
    disconnected: () => "MetaMask: Disconnected from chain. Attempting to connect.",
    permanentlyDisconnected: () => "MetaMask: Disconnected from MetaMask background. Page reload required.",
    sendSiteMetadata: () => "MetaMask: Failed to send site metadata. This is an internal error, please report this bug.",
    unsupportedSync: (e) => `MetaMask: The MetaMask Ethereum provider does not support synchronous methods like ${e} without a callback parameter.`,
    invalidDuplexStream: () => "Must provide a Node.js-style duplex stream.",
    invalidRequestArgs: () => "Expected a single, non-array, object argument.",
    invalidRequestMethod: () => "'args.method' must be a non-empty string.",
    invalidRequestParams: () => "'args.params' must be an object or array if provided.",
    invalidLoggerObject: () => "'args.logger' must be an object if provided.",
    invalidLoggerMethod: (e) => `'args.logger' must include required method '${e}'.`
  },
  info: {
    connected: (e) => `MetaMask: Connected to chain with ID "${e}".`
  },
  warnings: {
    // deprecated methods
    enableDeprecation: `MetaMask: 'ethereum.enable()' is deprecated and may be removed in the future. Please use the 'eth_requestAccounts' RPC method instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1102`,
    sendDeprecation: `MetaMask: 'ethereum.send(...)' is deprecated and may be removed in the future. Please use 'ethereum.sendAsync(...)' or 'ethereum.request(...)' instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1193`,
    // deprecated events
    events: {
      close: `MetaMask: The event 'close' is deprecated and may be removed in the future. Please use 'disconnect' instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1193#disconnect`,
      data: `MetaMask: The event 'data' is deprecated and will be removed in the future. Use 'message' instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1193#message`,
      networkChanged: `MetaMask: The event 'networkChanged' is deprecated and may be removed in the future. Use 'chainChanged' instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1193#chainchanged`,
      notification: `MetaMask: The event 'notification' is deprecated and may be removed in the future. Use 'message' instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1193#message`
    },
    // misc
    experimentalMethods: "MetaMask: 'ethereum._metamask' exposes non-standard, experimental methods. They may be removed or changed without warning."
  }
};
var dt = xi.default = ys, Oe = {}, ot = {}, Ve = {}, gs = yt;
yt.default = yt;
yt.stable = Mi;
yt.stableStringify = Mi;
var $t = "[...]", Ri = "[Circular]", Ye = [], Je = [];
function Ti() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function yt(e, t, n, s) {
  typeof s > "u" && (s = Ti()), Ir(e, "", 0, [], void 0, 0, s);
  var u;
  try {
    Je.length === 0 ? u = JSON.stringify(e, t, n) : u = JSON.stringify(e, Bi(t), n);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; Ye.length !== 0; ) {
      var d = Ye.pop();
      d.length === 4 ? Object.defineProperty(d[0], d[1], d[3]) : d[0][d[1]] = d[2];
    }
  }
  return u;
}
function at(e, t, n, s) {
  var u = Object.getOwnPropertyDescriptor(s, n);
  u.get !== void 0 ? u.configurable ? (Object.defineProperty(s, n, { value: e }), Ye.push([s, n, t, u])) : Je.push([t, n, e]) : (s[n] = e, Ye.push([s, n, t]));
}
function Ir(e, t, n, s, u, d, l) {
  d += 1;
  var f;
  if (typeof e == "object" && e !== null) {
    for (f = 0; f < s.length; f++)
      if (s[f] === e) {
        at(Ri, e, t, u);
        return;
      }
    if (typeof l.depthLimit < "u" && d > l.depthLimit) {
      at($t, e, t, u);
      return;
    }
    if (typeof l.edgesLimit < "u" && n + 1 > l.edgesLimit) {
      at($t, e, t, u);
      return;
    }
    if (s.push(e), Array.isArray(e))
      for (f = 0; f < e.length; f++)
        Ir(e[f], f, f, s, e, d, l);
    else {
      var g = Object.keys(e);
      for (f = 0; f < g.length; f++) {
        var T = g[f];
        Ir(e[T], T, f, s, e, d, l);
      }
    }
    s.pop();
  }
}
function ms(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function Mi(e, t, n, s) {
  typeof s > "u" && (s = Ti());
  var u = jr(e, "", 0, [], void 0, 0, s) || e, d;
  try {
    Je.length === 0 ? d = JSON.stringify(u, t, n) : d = JSON.stringify(u, Bi(t), n);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; Ye.length !== 0; ) {
      var l = Ye.pop();
      l.length === 4 ? Object.defineProperty(l[0], l[1], l[3]) : l[0][l[1]] = l[2];
    }
  }
  return d;
}
function jr(e, t, n, s, u, d, l) {
  d += 1;
  var f;
  if (typeof e == "object" && e !== null) {
    for (f = 0; f < s.length; f++)
      if (s[f] === e) {
        at(Ri, e, t, u);
        return;
      }
    try {
      if (typeof e.toJSON == "function")
        return;
    } catch {
      return;
    }
    if (typeof l.depthLimit < "u" && d > l.depthLimit) {
      at($t, e, t, u);
      return;
    }
    if (typeof l.edgesLimit < "u" && n + 1 > l.edgesLimit) {
      at($t, e, t, u);
      return;
    }
    if (s.push(e), Array.isArray(e))
      for (f = 0; f < e.length; f++)
        jr(e[f], f, f, s, e, d, l);
    else {
      var g = {}, T = Object.keys(e).sort(ms);
      for (f = 0; f < T.length; f++) {
        var F = T[f];
        jr(e[F], F, f, s, e, d, l), g[F] = e[F];
      }
      if (typeof u < "u")
        Ye.push([u, t, e]), u[t] = g;
      else
        return g;
    }
    s.pop();
  }
}
function Bi(e) {
  return e = typeof e < "u" ? e : function(t, n) {
    return n;
  }, function(t, n) {
    if (Je.length > 0)
      for (var s = 0; s < Je.length; s++) {
        var u = Je[s];
        if (u[1] === t && u[0] === n) {
          n = u[2], Je.splice(s, 1);
          break;
        }
      }
    return e.call(this, t, n);
  };
}
Object.defineProperty(Ve, "__esModule", { value: !0 });
Ve.EthereumProviderError = Ve.EthereumRpcError = void 0;
const ws = gs;
class Oi extends Error {
  constructor(t, n, s) {
    if (!Number.isInteger(t))
      throw new Error('"code" must be an integer.');
    if (!n || typeof n != "string")
      throw new Error('"message" must be a nonempty string.');
    super(n), this.code = t, s !== void 0 && (this.data = s);
  }
  /**
   * Returns a plain object with all public class properties.
   */
  serialize() {
    const t = {
      code: this.code,
      message: this.message
    };
    return this.data !== void 0 && (t.data = this.data), this.stack && (t.stack = this.stack), t;
  }
  /**
   * Return a string representation of the serialized error, omitting
   * any circular references.
   */
  toString() {
    return ws.default(this.serialize(), _s, 2);
  }
}
Ve.EthereumRpcError = Oi;
class vs extends Oi {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(t, n, s) {
    if (!bs(t))
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(t, n, s);
  }
}
Ve.EthereumProviderError = vs;
function bs(e) {
  return Number.isInteger(e) && e >= 1e3 && e <= 4999;
}
function _s(e, t) {
  if (t !== "[Circular]")
    return t;
}
var Jr = {}, He = {};
Object.defineProperty(He, "__esModule", { value: !0 });
He.errorValues = He.errorCodes = void 0;
He.errorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901
  }
};
He.errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  4001: {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  4100: {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  4200: {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  4900: {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  4901: {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.serializeError = e.isValidCode = e.getMessageFromCode = e.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const t = He, n = Ve, s = t.errorCodes.rpc.internal, u = "Unspecified error message. This is a bug, please report it.", d = {
    code: s,
    message: l(s)
  };
  e.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
  function l(j, U = u) {
    if (Number.isInteger(j)) {
      const q = j.toString();
      if (E(t.errorValues, q))
        return t.errorValues[q].message;
      if (T(j))
        return e.JSON_RPC_SERVER_ERROR_MESSAGE;
    }
    return U;
  }
  e.getMessageFromCode = l;
  function f(j) {
    if (!Number.isInteger(j))
      return !1;
    const U = j.toString();
    return !!(t.errorValues[U] || T(j));
  }
  e.isValidCode = f;
  function g(j, { fallbackError: U = d, shouldIncludeStack: q = !1 } = {}) {
    var N, Q;
    if (!U || !Number.isInteger(U.code) || typeof U.message != "string")
      throw new Error("Must provide fallback error with integer number code and string message.");
    if (j instanceof n.EthereumRpcError)
      return j.serialize();
    const x = {};
    if (j && typeof j == "object" && !Array.isArray(j) && E(j, "code") && f(j.code)) {
      const L = j;
      x.code = L.code, L.message && typeof L.message == "string" ? (x.message = L.message, E(L, "data") && (x.data = L.data)) : (x.message = l(x.code), x.data = { originalError: F(j) });
    } else {
      x.code = U.code;
      const L = (N = j) === null || N === void 0 ? void 0 : N.message;
      x.message = L && typeof L == "string" ? L : U.message, x.data = { originalError: F(j) };
    }
    const R = (Q = j) === null || Q === void 0 ? void 0 : Q.stack;
    return q && j && R && typeof R == "string" && (x.stack = R), x;
  }
  e.serializeError = g;
  function T(j) {
    return j >= -32099 && j <= -32e3;
  }
  function F(j) {
    return j && typeof j == "object" && !Array.isArray(j) ? Object.assign({}, j) : j;
  }
  function E(j, U) {
    return Object.prototype.hasOwnProperty.call(j, U);
  }
})(Jr);
var zt = {};
Object.defineProperty(zt, "__esModule", { value: !0 });
zt.ethErrors = void 0;
const Xr = Ve, Pi = Jr, we = He;
zt.ethErrors = {
  rpc: {
    /**
     * Get a JSON RPC 2.0 Parse (-32700) error.
     */
    parse: (e) => Re(we.errorCodes.rpc.parse, e),
    /**
     * Get a JSON RPC 2.0 Invalid Request (-32600) error.
     */
    invalidRequest: (e) => Re(we.errorCodes.rpc.invalidRequest, e),
    /**
     * Get a JSON RPC 2.0 Invalid Params (-32602) error.
     */
    invalidParams: (e) => Re(we.errorCodes.rpc.invalidParams, e),
    /**
     * Get a JSON RPC 2.0 Method Not Found (-32601) error.
     */
    methodNotFound: (e) => Re(we.errorCodes.rpc.methodNotFound, e),
    /**
     * Get a JSON RPC 2.0 Internal (-32603) error.
     */
    internal: (e) => Re(we.errorCodes.rpc.internal, e),
    /**
     * Get a JSON RPC 2.0 Server error.
     * Permits integer error codes in the [ -32099 <= -32005 ] range.
     * Codes -32000 through -32004 are reserved by EIP-1474.
     */
    server: (e) => {
      if (!e || typeof e != "object" || Array.isArray(e))
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      const { code: t } = e;
      if (!Number.isInteger(t) || t > -32005 || t < -32099)
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      return Re(t, e);
    },
    /**
     * Get an Ethereum JSON RPC Invalid Input (-32000) error.
     */
    invalidInput: (e) => Re(we.errorCodes.rpc.invalidInput, e),
    /**
     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
     */
    resourceNotFound: (e) => Re(we.errorCodes.rpc.resourceNotFound, e),
    /**
     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
     */
    resourceUnavailable: (e) => Re(we.errorCodes.rpc.resourceUnavailable, e),
    /**
     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
     */
    transactionRejected: (e) => Re(we.errorCodes.rpc.transactionRejected, e),
    /**
     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
     */
    methodNotSupported: (e) => Re(we.errorCodes.rpc.methodNotSupported, e),
    /**
     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
     */
    limitExceeded: (e) => Re(we.errorCodes.rpc.limitExceeded, e)
  },
  provider: {
    /**
     * Get an Ethereum Provider User Rejected Request (4001) error.
     */
    userRejectedRequest: (e) => ht(we.errorCodes.provider.userRejectedRequest, e),
    /**
     * Get an Ethereum Provider Unauthorized (4100) error.
     */
    unauthorized: (e) => ht(we.errorCodes.provider.unauthorized, e),
    /**
     * Get an Ethereum Provider Unsupported Method (4200) error.
     */
    unsupportedMethod: (e) => ht(we.errorCodes.provider.unsupportedMethod, e),
    /**
     * Get an Ethereum Provider Not Connected (4900) error.
     */
    disconnected: (e) => ht(we.errorCodes.provider.disconnected, e),
    /**
     * Get an Ethereum Provider Chain Not Connected (4901) error.
     */
    chainDisconnected: (e) => ht(we.errorCodes.provider.chainDisconnected, e),
    /**
     * Get a custom Ethereum Provider error.
     */
    custom: (e) => {
      if (!e || typeof e != "object" || Array.isArray(e))
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      const { code: t, message: n, data: s } = e;
      if (!n || typeof n != "string")
        throw new Error('"message" must be a nonempty string');
      return new Xr.EthereumProviderError(t, n, s);
    }
  }
};
function Re(e, t) {
  const [n, s] = Ci(t);
  return new Xr.EthereumRpcError(e, n || Pi.getMessageFromCode(e), s);
}
function ht(e, t) {
  const [n, s] = Ci(t);
  return new Xr.EthereumProviderError(e, n || Pi.getMessageFromCode(e), s);
}
function Ci(e) {
  if (e) {
    if (typeof e == "string")
      return [e];
    if (typeof e == "object" && !Array.isArray(e)) {
      const { message: t, data: n } = e;
      if (t && typeof t != "string")
        throw new Error("Must specify string message.");
      return [t || void 0, n];
    }
  }
  return [];
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getMessageFromCode = e.serializeError = e.EthereumProviderError = e.EthereumRpcError = e.ethErrors = e.errorCodes = void 0;
  const t = Ve;
  Object.defineProperty(e, "EthereumRpcError", { enumerable: !0, get: function() {
    return t.EthereumRpcError;
  } }), Object.defineProperty(e, "EthereumProviderError", { enumerable: !0, get: function() {
    return t.EthereumProviderError;
  } });
  const n = Jr;
  Object.defineProperty(e, "serializeError", { enumerable: !0, get: function() {
    return n.serializeError;
  } }), Object.defineProperty(e, "getMessageFromCode", { enumerable: !0, get: function() {
    return n.getMessageFromCode;
  } });
  const s = zt;
  Object.defineProperty(e, "ethErrors", { enumerable: !0, get: function() {
    return s.ethErrors;
  } });
  const u = He;
  Object.defineProperty(e, "errorCodes", { enumerable: !0, get: function() {
    return u.errorCodes;
  } });
})(ot);
Object.defineProperty(Oe, "__esModule", { value: !0 });
var Ii = Oe.EMITTED_NOTIFICATIONS = Oe.NOOP = Oe.logStreamDisconnectWarning = ji = Oe.getRpcPromiseCallback = Oe.createErrorMiddleware = void 0;
const Es = ot;
function Ss(e) {
  return (t, n, s) => {
    (typeof t.method != "string" || !t.method) && (n.error = Es.ethErrors.rpc.invalidRequest({
      message: "The request 'method' must be a non-empty string.",
      data: t
    })), s((u) => {
      const { error: d } = n;
      return d && e.error(`MetaMask - RPC Error: ${d.message}`, d), u();
    });
  };
}
Oe.createErrorMiddleware = Ss;
const As = (e, t, n = !0) => (s, u) => {
  s || u.error ? t(s || u.error) : !n || Array.isArray(u) ? e(u) : e(u.result);
};
var ji = Oe.getRpcPromiseCallback = As;
function xs(e, t, n, s) {
  let u = `MetaMask: Lost connection to "${t}".`;
  n != null && n.stack && (u += `
${n.stack}`), e.warn(u), s && s.listenerCount("error") > 0 && s.emit("error", u);
}
Oe.logStreamDisconnectWarning = xs;
const Rs = () => {
};
Oe.NOOP = Rs;
Ii = Oe.EMITTED_NOTIFICATIONS = [
  "eth_subscription"
  // per eth-json-rpc-filters/subscriptionManager
];
var Fi = {};
Object.defineProperty(Fi, "__esModule", { value: !0 });
const Ts = lt;
function mn(e, t, n) {
  try {
    Reflect.apply(e, t, n);
  } catch (s) {
    setTimeout(() => {
      throw s;
    });
  }
}
function Ms(e) {
  const t = e.length, n = new Array(t);
  for (let s = 0; s < t; s += 1)
    n[s] = e[s];
  return n;
}
let Bs = class extends Ts.EventEmitter {
  emit(t, ...n) {
    let s = t === "error";
    const u = this._events;
    if (u !== void 0)
      s = s && u.error === void 0;
    else if (!s)
      return !1;
    if (s) {
      let l;
      if (n.length > 0 && ([l] = n), l instanceof Error)
        throw l;
      const f = new Error(`Unhandled error.${l ? ` (${l.message})` : ""}`);
      throw f.context = l, f;
    }
    const d = u[t];
    if (d === void 0)
      return !1;
    if (typeof d == "function")
      mn(d, this, n);
    else {
      const l = d.length, f = Ms(d);
      for (let g = 0; g < l; g += 1)
        mn(f[g], this, n);
    }
    return !0;
  }
};
var Os = Fi.default = Bs;
const $e = (e) => e !== null && typeof e == "object" && typeof e.pipe == "function";
$e.writable = (e) => $e(e) && e.writable !== !1 && typeof e._write == "function" && typeof e._writableState == "object";
$e.readable = (e) => $e(e) && e.readable !== !1 && typeof e._read == "function" && typeof e._readableState == "object";
$e.duplex = (e) => $e.writable(e) && $e.readable(e);
$e.transform = (e) => $e.duplex(e) && typeof e._transform == "function";
var Ps = $e, Fr = {}, Jt = {}, bt = {};
Object.defineProperty(bt, "__esModule", { value: !0 });
bt.getUniqueId = void 0;
const ki = 4294967295;
let mr = Math.floor(Math.random() * ki);
function Cs() {
  return mr = (mr + 1) % ki, mr;
}
bt.getUniqueId = Cs;
Object.defineProperty(Jt, "__esModule", { value: !0 });
Jt.createIdRemapMiddleware = void 0;
const Is = bt;
function js() {
  return (e, t, n, s) => {
    const u = e.id, d = Is.getUniqueId();
    e.id = d, t.id = d, n((l) => {
      e.id = u, t.id = u, l();
    });
  };
}
Jt.createIdRemapMiddleware = js;
var Xt = {};
Object.defineProperty(Xt, "__esModule", { value: !0 });
Xt.createAsyncMiddleware = void 0;
function Fs(e) {
  return async (t, n, s, u) => {
    let d;
    const l = new Promise((F) => {
      d = F;
    });
    let f = null, g = !1;
    const T = async () => {
      g = !0, s((F) => {
        f = F, d();
      }), await l;
    };
    try {
      await e(t, n, T), g ? (await l, f(null)) : u(null);
    } catch (F) {
      f ? f(F) : u(F);
    }
  };
}
Xt.createAsyncMiddleware = Fs;
var Kt = {};
Object.defineProperty(Kt, "__esModule", { value: !0 });
Kt.createScaffoldMiddleware = void 0;
function ks(e) {
  return (t, n, s, u) => {
    const d = e[t.method];
    return d === void 0 ? s() : typeof d == "function" ? d(t, n, s, u) : (n.result = d, u());
  };
}
Kt.createScaffoldMiddleware = ks;
var _t = {}, Yt = {};
Object.defineProperty(Yt, "__esModule", { value: !0 });
const $s = lt;
function wn(e, t, n) {
  try {
    Reflect.apply(e, t, n);
  } catch (s) {
    setTimeout(() => {
      throw s;
    });
  }
}
function Ns(e) {
  const t = e.length, n = new Array(t);
  for (let s = 0; s < t; s += 1)
    n[s] = e[s];
  return n;
}
class Us extends $s.EventEmitter {
  emit(t, ...n) {
    let s = t === "error";
    const u = this._events;
    if (u !== void 0)
      s = s && u.error === void 0;
    else if (!s)
      return !1;
    if (s) {
      let l;
      if (n.length > 0 && ([l] = n), l instanceof Error)
        throw l;
      const f = new Error(`Unhandled error.${l ? ` (${l.message})` : ""}`);
      throw f.context = l, f;
    }
    const d = u[t];
    if (d === void 0)
      return !1;
    if (typeof d == "function")
      wn(d, this, n);
    else {
      const l = d.length, f = Ns(d);
      for (let g = 0; g < l; g += 1)
        wn(f[g], this, n);
    }
    return !0;
  }
}
Yt.default = Us;
var Ds = te && te.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(_t, "__esModule", { value: !0 });
_t.JsonRpcEngine = void 0;
const Ls = Ds(Yt), Te = ot;
class Ue extends Ls.default {
  constructor() {
    super(), this._middleware = [];
  }
  /**
   * Add a middleware function to the engine's middleware stack.
   *
   * @param middleware - The middleware function to add.
   */
  push(t) {
    this._middleware.push(t);
  }
  handle(t, n) {
    if (n && typeof n != "function")
      throw new Error('"callback" must be a function if provided.');
    return Array.isArray(t) ? n ? this._handleBatch(t, n) : this._handleBatch(t) : n ? this._handle(t, n) : this._promiseHandle(t);
  }
  /**
   * Returns this engine as a middleware function that can be pushed to other
   * engines.
   *
   * @returns This engine as a middleware function.
   */
  asMiddleware() {
    return async (t, n, s, u) => {
      try {
        const [d, l, f] = await Ue._runAllMiddleware(t, n, this._middleware);
        return l ? (await Ue._runReturnHandlers(f), u(d)) : s(async (g) => {
          try {
            await Ue._runReturnHandlers(f);
          } catch (T) {
            return g(T);
          }
          return g();
        });
      } catch (d) {
        return u(d);
      }
    };
  }
  async _handleBatch(t, n) {
    try {
      const s = await Promise.all(
        // 1. Begin executing each request in the order received
        t.map(this._promiseHandle.bind(this))
      );
      return n ? n(null, s) : s;
    } catch (s) {
      if (n)
        return n(s);
      throw s;
    }
  }
  /**
   * A promise-wrapped _handle.
   */
  _promiseHandle(t) {
    return new Promise((n) => {
      this._handle(t, (s, u) => {
        n(u);
      });
    });
  }
  /**
   * Ensures that the request object is valid, processes it, and passes any
   * error and the response object to the given callback.
   *
   * Does not reject.
   */
  async _handle(t, n) {
    if (!t || Array.isArray(t) || typeof t != "object") {
      const l = new Te.EthereumRpcError(Te.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof t}`, { request: t });
      return n(l, { id: void 0, jsonrpc: "2.0", error: l });
    }
    if (typeof t.method != "string") {
      const l = new Te.EthereumRpcError(Te.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof t.method}`, { request: t });
      return n(l, { id: t.id, jsonrpc: "2.0", error: l });
    }
    const s = Object.assign({}, t), u = {
      id: s.id,
      jsonrpc: s.jsonrpc
    };
    let d = null;
    try {
      await this._processRequest(s, u);
    } catch (l) {
      d = l;
    }
    return d && (delete u.result, u.error || (u.error = Te.serializeError(d))), n(d, u);
  }
  /**
   * For the given request and response, runs all middleware and their return
   * handlers, if any, and ensures that internal request processing semantics
   * are satisfied.
   */
  async _processRequest(t, n) {
    const [s, u, d] = await Ue._runAllMiddleware(t, n, this._middleware);
    if (Ue._checkForCompletion(t, n, u), await Ue._runReturnHandlers(d), s)
      throw s;
  }
  /**
   * Serially executes the given stack of middleware.
   *
   * @returns An array of any error encountered during middleware execution,
   * a boolean indicating whether the request was completed, and an array of
   * middleware-defined return handlers.
   */
  static async _runAllMiddleware(t, n, s) {
    const u = [];
    let d = null, l = !1;
    for (const f of s)
      if ([d, l] = await Ue._runMiddleware(t, n, f, u), l)
        break;
    return [d, l, u.reverse()];
  }
  /**
   * Runs an individual middleware.
   *
   * @returns An array of any error encountered during middleware exection,
   * and a boolean indicating whether the request should end.
   */
  static _runMiddleware(t, n, s, u) {
    return new Promise((d) => {
      const l = (g) => {
        const T = g || n.error;
        T && (n.error = Te.serializeError(T)), d([T, !0]);
      }, f = (g) => {
        n.error ? l(n.error) : (g && (typeof g != "function" && l(new Te.EthereumRpcError(Te.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof g}" for request:
${wr(t)}`, { request: t })), u.push(g)), d([null, !1]));
      };
      try {
        s(t, n, f, l);
      } catch (g) {
        l(g);
      }
    });
  }
  /**
   * Serially executes array of return handlers. The request and response are
   * assumed to be in their scope.
   */
  static async _runReturnHandlers(t) {
    for (const n of t)
      await new Promise((s, u) => {
        n((d) => d ? u(d) : s());
      });
  }
  /**
   * Throws an error if the response has neither a result nor an error, or if
   * the "isComplete" flag is falsy.
   */
  static _checkForCompletion(t, n, s) {
    if (!("result" in n) && !("error" in n))
      throw new Te.EthereumRpcError(Te.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${wr(t)}`, { request: t });
    if (!s)
      throw new Te.EthereumRpcError(Te.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${wr(t)}`, { request: t });
  }
}
_t.JsonRpcEngine = Ue;
function wr(e) {
  return JSON.stringify(e, null, 2);
}
var Zt = {};
Object.defineProperty(Zt, "__esModule", { value: !0 });
Zt.mergeMiddleware = void 0;
const qs = _t;
function Ws(e) {
  const t = new qs.JsonRpcEngine();
  return e.forEach((n) => t.push(n)), t.asMiddleware();
}
Zt.mergeMiddleware = Ws;
(function(e) {
  var t = te && te.__createBinding || (Object.create ? function(s, u, d, l) {
    l === void 0 && (l = d), Object.defineProperty(s, l, { enumerable: !0, get: function() {
      return u[d];
    } });
  } : function(s, u, d, l) {
    l === void 0 && (l = d), s[l] = u[d];
  }), n = te && te.__exportStar || function(s, u) {
    for (var d in s)
      d !== "default" && !Object.prototype.hasOwnProperty.call(u, d) && t(u, s, d);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), n(Jt, e), n(Xt, e), n(Kt, e), n(bt, e), n(_t, e), n(Zt, e);
})(Fr);
var gt = {}, Kr = {}, kr = { exports: {} }, Vs = {}.toString, Hs = Array.isArray || function(e) {
  return Vs.call(e) == "[object Array]";
}, $i = lt.EventEmitter, $r = { exports: {} };
(function(e, t) {
  var n = ct, s = n.Buffer;
  function u(l, f) {
    for (var g in l)
      f[g] = l[g];
  }
  s.from && s.alloc && s.allocUnsafe && s.allocUnsafeSlow ? e.exports = n : (u(n, t), t.Buffer = d);
  function d(l, f, g) {
    return s(l, f, g);
  }
  u(s, d), d.from = function(l, f, g) {
    if (typeof l == "number")
      throw new TypeError("Argument must not be a number");
    return s(l, f, g);
  }, d.alloc = function(l, f, g) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    var T = s(l);
    return f !== void 0 ? typeof g == "string" ? T.fill(f, g) : T.fill(f) : T.fill(0), T;
  }, d.allocUnsafe = function(l) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    return s(l);
  }, d.allocUnsafeSlow = function(l) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    return n.SlowBuffer(l);
  };
})($r, $r.exports);
var Yr = $r.exports, vr = { exports: {} }, vn;
function Gs() {
  return vn || (vn = 1, function(e) {
    function t(d, l) {
      if (!(d instanceof l))
        throw new TypeError("Cannot call a class as a function");
    }
    var n = Yr.Buffer, s = wt;
    function u(d, l, f) {
      d.copy(l, f);
    }
    e.exports = function() {
      function d() {
        t(this, d), this.head = null, this.tail = null, this.length = 0;
      }
      return d.prototype.push = function(f) {
        var g = { data: f, next: null };
        this.length > 0 ? this.tail.next = g : this.head = g, this.tail = g, ++this.length;
      }, d.prototype.unshift = function(f) {
        var g = { data: f, next: this.head };
        this.length === 0 && (this.tail = g), this.head = g, ++this.length;
      }, d.prototype.shift = function() {
        if (this.length !== 0) {
          var f = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, f;
        }
      }, d.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, d.prototype.join = function(f) {
        if (this.length === 0)
          return "";
        for (var g = this.head, T = "" + g.data; g = g.next; )
          T += f + g.data;
        return T;
      }, d.prototype.concat = function(f) {
        if (this.length === 0)
          return n.alloc(0);
        for (var g = n.allocUnsafe(f >>> 0), T = this.head, F = 0; T; )
          u(T.data, g, F), F += T.data.length, T = T.next;
        return g;
      }, d;
    }(), s && s.inspect && s.inspect.custom && (e.exports.prototype[s.inspect.custom] = function() {
      var d = s.inspect({ length: this.length });
      return this.constructor.name + " " + d;
    });
  }(vr)), vr.exports;
}
var xt = Ge;
function zs(e, t) {
  var n = this, s = this._readableState && this._readableState.destroyed, u = this._writableState && this._writableState.destroyed;
  return s || u ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, xt.nextTick(Rt, this, e)) : xt.nextTick(Rt, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(d) {
    !t && d ? n._writableState ? n._writableState.errorEmitted || (n._writableState.errorEmitted = !0, xt.nextTick(Rt, n, d)) : xt.nextTick(Rt, n, d) : t && t(d);
  }), this);
}
function Js() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function Rt(e, t) {
  e.emit("error", t);
}
var Ni = {
  destroy: zs,
  undestroy: Js
}, br, bn;
function Ui() {
  if (bn)
    return br;
  bn = 1;
  var e = Ge;
  br = N;
  function t(h) {
    var y = this;
    this.next = null, this.entry = null, this.finish = function() {
      me(y, h);
    };
  }
  var n = !J.process.browser && ["v0.10", "v0.9."].indexOf(J.process.version.slice(0, 5)) > -1 ? setImmediate : e.nextTick, s;
  N.WritableState = U;
  var u = Object.create(re);
  u.inherits = Pe;
  var d = {
    deprecate: li
  }, l = $i, f = Yr.Buffer, g = (typeof te < "u" ? te : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function T(h) {
    return f.from(h);
  }
  function F(h) {
    return f.isBuffer(h) || h instanceof g;
  }
  var E = Ni;
  u.inherits(N, l);
  function j() {
  }
  function U(h, y) {
    s = s || ft(), h = h || {};
    var b = y instanceof s;
    this.objectMode = !!h.objectMode, b && (this.objectMode = this.objectMode || !!h.writableObjectMode);
    var P = h.highWaterMark, I = h.writableHighWaterMark, m = this.objectMode ? 16 : 16 * 1024;
    P || P === 0 ? this.highWaterMark = P : b && (I || I === 0) ? this.highWaterMark = I : this.highWaterMark = m, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var A = h.decodeStrings === !1;
    this.decodeStrings = !A, this.defaultEncoding = h.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(B) {
      ie(y, B);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  U.prototype.getBuffer = function() {
    for (var y = this.bufferedRequest, b = []; y; )
      b.push(y), y = y.next;
    return b;
  }, function() {
    try {
      Object.defineProperty(U.prototype, "buffer", {
        get: d.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var q;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (q = Function.prototype[Symbol.hasInstance], Object.defineProperty(N, Symbol.hasInstance, {
    value: function(h) {
      return q.call(this, h) ? !0 : this !== N ? !1 : h && h._writableState instanceof U;
    }
  })) : q = function(h) {
    return h instanceof this;
  };
  function N(h) {
    if (s = s || ft(), !q.call(N, this) && !(this instanceof s))
      return new N(h);
    this._writableState = new U(h, this), this.writable = !0, h && (typeof h.write == "function" && (this._write = h.write), typeof h.writev == "function" && (this._writev = h.writev), typeof h.destroy == "function" && (this._destroy = h.destroy), typeof h.final == "function" && (this._final = h.final)), l.call(this);
  }
  N.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function Q(h, y) {
    var b = new Error("write after end");
    h.emit("error", b), e.nextTick(y, b);
  }
  function x(h, y, b, P) {
    var I = !0, m = !1;
    return b === null ? m = new TypeError("May not write null values to stream") : typeof b != "string" && b !== void 0 && !y.objectMode && (m = new TypeError("Invalid non-string/buffer chunk")), m && (h.emit("error", m), e.nextTick(P, m), I = !1), I;
  }
  N.prototype.write = function(h, y, b) {
    var P = this._writableState, I = !1, m = !P.objectMode && F(h);
    return m && !f.isBuffer(h) && (h = T(h)), typeof y == "function" && (b = y, y = null), m ? y = "buffer" : y || (y = P.defaultEncoding), typeof b != "function" && (b = j), P.ended ? Q(this, b) : (m || x(this, P, h, b)) && (P.pendingcb++, I = L(this, P, m, h, y, b)), I;
  }, N.prototype.cork = function() {
    var h = this._writableState;
    h.corked++;
  }, N.prototype.uncork = function() {
    var h = this._writableState;
    h.corked && (h.corked--, !h.writing && !h.corked && !h.bufferProcessing && h.bufferedRequest && he(this, h));
  }, N.prototype.setDefaultEncoding = function(y) {
    if (typeof y == "string" && (y = y.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((y + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + y);
    return this._writableState.defaultEncoding = y, this;
  };
  function R(h, y, b) {
    return !h.objectMode && h.decodeStrings !== !1 && typeof y == "string" && (y = f.from(y, b)), y;
  }
  Object.defineProperty(N.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function L(h, y, b, P, I, m) {
    if (!b) {
      var A = R(y, P, I);
      P !== A && (b = !0, I = "buffer", P = A);
    }
    var B = y.objectMode ? 1 : P.length;
    y.length += B;
    var D = y.length < y.highWaterMark;
    if (D || (y.needDrain = !0), y.writing || y.corked) {
      var W = y.lastBufferedRequest;
      y.lastBufferedRequest = {
        chunk: P,
        encoding: I,
        isBuf: b,
        callback: m,
        next: null
      }, W ? W.next = y.lastBufferedRequest : y.bufferedRequest = y.lastBufferedRequest, y.bufferedRequestCount += 1;
    } else
      z(h, y, !1, B, P, I, m);
    return D;
  }
  function z(h, y, b, P, I, m, A) {
    y.writelen = P, y.writecb = A, y.writing = !0, y.sync = !0, b ? h._writev(I, y.onwrite) : h._write(I, m, y.onwrite), y.sync = !1;
  }
  function V(h, y, b, P, I) {
    --y.pendingcb, b ? (e.nextTick(I, P), e.nextTick(K, h, y), h._writableState.errorEmitted = !0, h.emit("error", P)) : (I(P), h._writableState.errorEmitted = !0, h.emit("error", P), K(h, y));
  }
  function Ee(h) {
    h.writing = !1, h.writecb = null, h.length -= h.writelen, h.writelen = 0;
  }
  function ie(h, y) {
    var b = h._writableState, P = b.sync, I = b.writecb;
    if (Ee(b), y)
      V(h, b, P, y, I);
    else {
      var m = ee(b);
      !m && !b.corked && !b.bufferProcessing && b.bufferedRequest && he(h, b), P ? n(de, h, b, m, I) : de(h, b, m, I);
    }
  }
  function de(h, y, b, P) {
    b || ce(h, y), y.pendingcb--, P(), K(h, y);
  }
  function ce(h, y) {
    y.length === 0 && y.needDrain && (y.needDrain = !1, h.emit("drain"));
  }
  function he(h, y) {
    y.bufferProcessing = !0;
    var b = y.bufferedRequest;
    if (h._writev && b && b.next) {
      var P = y.bufferedRequestCount, I = new Array(P), m = y.corkedRequestsFree;
      m.entry = b;
      for (var A = 0, B = !0; b; )
        I[A] = b, b.isBuf || (B = !1), b = b.next, A += 1;
      I.allBuffers = B, z(h, y, !0, y.length, I, "", m.finish), y.pendingcb++, y.lastBufferedRequest = null, m.next ? (y.corkedRequestsFree = m.next, m.next = null) : y.corkedRequestsFree = new t(y), y.bufferedRequestCount = 0;
    } else {
      for (; b; ) {
        var D = b.chunk, W = b.encoding, o = b.callback, a = y.objectMode ? 1 : D.length;
        if (z(h, y, !1, a, D, W, o), b = b.next, y.bufferedRequestCount--, y.writing)
          break;
      }
      b === null && (y.lastBufferedRequest = null);
    }
    y.bufferedRequest = b, y.bufferProcessing = !1;
  }
  N.prototype._write = function(h, y, b) {
    b(new Error("_write() is not implemented"));
  }, N.prototype._writev = null, N.prototype.end = function(h, y, b) {
    var P = this._writableState;
    typeof h == "function" ? (b = h, h = null, y = null) : typeof y == "function" && (b = y, y = null), h != null && this.write(h, y), P.corked && (P.corked = 1, this.uncork()), P.ending || ge(this, P, b);
  };
  function ee(h) {
    return h.ending && h.length === 0 && h.bufferedRequest === null && !h.finished && !h.writing;
  }
  function ue(h, y) {
    h._final(function(b) {
      y.pendingcb--, b && h.emit("error", b), y.prefinished = !0, h.emit("prefinish"), K(h, y);
    });
  }
  function ve(h, y) {
    !y.prefinished && !y.finalCalled && (typeof h._final == "function" ? (y.pendingcb++, y.finalCalled = !0, e.nextTick(ue, h, y)) : (y.prefinished = !0, h.emit("prefinish")));
  }
  function K(h, y) {
    var b = ee(y);
    return b && (ve(h, y), y.pendingcb === 0 && (y.finished = !0, h.emit("finish"))), b;
  }
  function ge(h, y, b) {
    y.ending = !0, K(h, y), b && (y.finished ? e.nextTick(b) : h.once("finish", b)), y.ended = !0, h.writable = !1;
  }
  function me(h, y, b) {
    var P = h.entry;
    for (h.entry = null; P; ) {
      var I = P.callback;
      y.pendingcb--, I(b), P = P.next;
    }
    y.corkedRequestsFree.next = h;
  }
  return Object.defineProperty(N.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(h) {
      this._writableState && (this._writableState.destroyed = h);
    }
  }), N.prototype.destroy = E.destroy, N.prototype._undestroy = E.undestroy, N.prototype._destroy = function(h, y) {
    this.end(), y(h);
  }, br;
}
var _r, _n;
function ft() {
  if (_n)
    return _r;
  _n = 1;
  var e = Ge, t = Object.keys || function(E) {
    var j = [];
    for (var U in E)
      j.push(U);
    return j;
  };
  _r = g;
  var n = Object.create(re);
  n.inherits = Pe;
  var s = Di(), u = Ui();
  n.inherits(g, s);
  for (var d = t(u.prototype), l = 0; l < d.length; l++) {
    var f = d[l];
    g.prototype[f] || (g.prototype[f] = u.prototype[f]);
  }
  function g(E) {
    if (!(this instanceof g))
      return new g(E);
    s.call(this, E), u.call(this, E), E && E.readable === !1 && (this.readable = !1), E && E.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, E && E.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", T);
  }
  Object.defineProperty(g.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function T() {
    this.allowHalfOpen || this._writableState.ended || e.nextTick(F, this);
  }
  function F(E) {
    E.end();
  }
  return Object.defineProperty(g.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(E) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = E, this._writableState.destroyed = E);
    }
  }), g.prototype._destroy = function(E, j) {
    this.push(null), this.end(), e.nextTick(j, E);
  }, _r;
}
var Er, En;
function Di() {
  if (En)
    return Er;
  En = 1;
  var e = Ge;
  Er = R;
  var t = Hs, n;
  R.ReadableState = x, lt.EventEmitter;
  var s = function(o, a) {
    return o.listeners(a).length;
  }, u = $i, d = Yr.Buffer, l = (typeof te < "u" ? te : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function f(o) {
    return d.from(o);
  }
  function g(o) {
    return d.isBuffer(o) || o instanceof l;
  }
  var T = Object.create(re);
  T.inherits = Pe;
  var F = wt, E = void 0;
  F && F.debuglog ? E = F.debuglog("stream") : E = function() {
  };
  var j = Gs(), U = Ni, q;
  T.inherits(R, u);
  var N = ["error", "close", "destroy", "pause", "resume"];
  function Q(o, a, w) {
    if (typeof o.prependListener == "function")
      return o.prependListener(a, w);
    !o._events || !o._events[a] ? o.on(a, w) : t(o._events[a]) ? o._events[a].unshift(w) : o._events[a] = [w, o._events[a]];
  }
  function x(o, a) {
    n = n || ft(), o = o || {};
    var w = a instanceof n;
    this.objectMode = !!o.objectMode, w && (this.objectMode = this.objectMode || !!o.readableObjectMode);
    var _ = o.highWaterMark, $ = o.readableHighWaterMark, C = this.objectMode ? 16 : 16 * 1024;
    _ || _ === 0 ? this.highWaterMark = _ : w && ($ || $ === 0) ? this.highWaterMark = $ : this.highWaterMark = C, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new j(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = o.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, o.encoding && (q || (q = kt().StringDecoder), this.decoder = new q(o.encoding), this.encoding = o.encoding);
  }
  function R(o) {
    if (n = n || ft(), !(this instanceof R))
      return new R(o);
    this._readableState = new x(o, this), this.readable = !0, o && (typeof o.read == "function" && (this._read = o.read), typeof o.destroy == "function" && (this._destroy = o.destroy)), u.call(this);
  }
  Object.defineProperty(R.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(o) {
      this._readableState && (this._readableState.destroyed = o);
    }
  }), R.prototype.destroy = U.destroy, R.prototype._undestroy = U.undestroy, R.prototype._destroy = function(o, a) {
    this.push(null), a(o);
  }, R.prototype.push = function(o, a) {
    var w = this._readableState, _;
    return w.objectMode ? _ = !0 : typeof o == "string" && (a = a || w.defaultEncoding, a !== w.encoding && (o = d.from(o, a), a = ""), _ = !0), L(this, o, a, !1, _);
  }, R.prototype.unshift = function(o) {
    return L(this, o, null, !0, !1);
  };
  function L(o, a, w, _, $) {
    var C = o._readableState;
    if (a === null)
      C.reading = !1, he(o, C);
    else {
      var k;
      $ || (k = V(C, a)), k ? o.emit("error", k) : C.objectMode || a && a.length > 0 ? (typeof a != "string" && !C.objectMode && Object.getPrototypeOf(a) !== d.prototype && (a = f(a)), _ ? C.endEmitted ? o.emit("error", new Error("stream.unshift() after end event")) : z(o, C, a, !0) : C.ended ? o.emit("error", new Error("stream.push() after EOF")) : (C.reading = !1, C.decoder && !w ? (a = C.decoder.write(a), C.objectMode || a.length !== 0 ? z(o, C, a, !1) : ve(o, C)) : z(o, C, a, !1))) : _ || (C.reading = !1);
    }
    return Ee(C);
  }
  function z(o, a, w, _) {
    a.flowing && a.length === 0 && !a.sync ? (o.emit("data", w), o.read(0)) : (a.length += a.objectMode ? 1 : w.length, _ ? a.buffer.unshift(w) : a.buffer.push(w), a.needReadable && ee(o)), ve(o, a);
  }
  function V(o, a) {
    var w;
    return !g(a) && typeof a != "string" && a !== void 0 && !o.objectMode && (w = new TypeError("Invalid non-string/buffer chunk")), w;
  }
  function Ee(o) {
    return !o.ended && (o.needReadable || o.length < o.highWaterMark || o.length === 0);
  }
  R.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, R.prototype.setEncoding = function(o) {
    return q || (q = kt().StringDecoder), this._readableState.decoder = new q(o), this._readableState.encoding = o, this;
  };
  var ie = 8388608;
  function de(o) {
    return o >= ie ? o = ie : (o--, o |= o >>> 1, o |= o >>> 2, o |= o >>> 4, o |= o >>> 8, o |= o >>> 16, o++), o;
  }
  function ce(o, a) {
    return o <= 0 || a.length === 0 && a.ended ? 0 : a.objectMode ? 1 : o !== o ? a.flowing && a.length ? a.buffer.head.data.length : a.length : (o > a.highWaterMark && (a.highWaterMark = de(o)), o <= a.length ? o : a.ended ? a.length : (a.needReadable = !0, 0));
  }
  R.prototype.read = function(o) {
    E("read", o), o = parseInt(o, 10);
    var a = this._readableState, w = o;
    if (o !== 0 && (a.emittedReadable = !1), o === 0 && a.needReadable && (a.length >= a.highWaterMark || a.ended))
      return E("read: emitReadable", a.length, a.ended), a.length === 0 && a.ended ? B(this) : ee(this), null;
    if (o = ce(o, a), o === 0 && a.ended)
      return a.length === 0 && B(this), null;
    var _ = a.needReadable;
    E("need readable", _), (a.length === 0 || a.length - o < a.highWaterMark) && (_ = !0, E("length less than watermark", _)), a.ended || a.reading ? (_ = !1, E("reading or ended", _)) : _ && (E("do read"), a.reading = !0, a.sync = !0, a.length === 0 && (a.needReadable = !0), this._read(a.highWaterMark), a.sync = !1, a.reading || (o = ce(w, a)));
    var $;
    return o > 0 ? $ = P(o, a) : $ = null, $ === null ? (a.needReadable = !0, o = 0) : a.length -= o, a.length === 0 && (a.ended || (a.needReadable = !0), w !== o && a.ended && B(this)), $ !== null && this.emit("data", $), $;
  };
  function he(o, a) {
    if (!a.ended) {
      if (a.decoder) {
        var w = a.decoder.end();
        w && w.length && (a.buffer.push(w), a.length += a.objectMode ? 1 : w.length);
      }
      a.ended = !0, ee(o);
    }
  }
  function ee(o) {
    var a = o._readableState;
    a.needReadable = !1, a.emittedReadable || (E("emitReadable", a.flowing), a.emittedReadable = !0, a.sync ? e.nextTick(ue, o) : ue(o));
  }
  function ue(o) {
    E("emit readable"), o.emit("readable"), b(o);
  }
  function ve(o, a) {
    a.readingMore || (a.readingMore = !0, e.nextTick(K, o, a));
  }
  function K(o, a) {
    for (var w = a.length; !a.reading && !a.flowing && !a.ended && a.length < a.highWaterMark && (E("maybeReadMore read 0"), o.read(0), w !== a.length); )
      w = a.length;
    a.readingMore = !1;
  }
  R.prototype._read = function(o) {
    this.emit("error", new Error("_read() is not implemented"));
  }, R.prototype.pipe = function(o, a) {
    var w = this, _ = this._readableState;
    switch (_.pipesCount) {
      case 0:
        _.pipes = o;
        break;
      case 1:
        _.pipes = [_.pipes, o];
        break;
      default:
        _.pipes.push(o);
        break;
    }
    _.pipesCount += 1, E("pipe count=%d opts=%j", _.pipesCount, a);
    var $ = (!a || a.end !== !1) && o !== J.process.stdout && o !== J.process.stderr, C = $ ? oe : be;
    _.endEmitted ? e.nextTick(C) : w.once("end", C), o.on("unpipe", k);
    function k(_e, le) {
      E("onunpipe"), _e === w && le && le.hasUnpiped === !1 && (le.hasUnpiped = !0, Ne());
    }
    function oe() {
      E("onend"), o.end();
    }
    var Se = ge(w);
    o.on("drain", Se);
    var Ce = !1;
    function Ne() {
      E("cleanup"), o.removeListener("close", Ae), o.removeListener("finish", pe), o.removeListener("drain", Se), o.removeListener("error", xe), o.removeListener("unpipe", k), w.removeListener("end", oe), w.removeListener("end", be), w.removeListener("data", O), Ce = !0, _.awaitDrain && (!o._writableState || o._writableState.needDrain) && Se();
    }
    var Be = !1;
    w.on("data", O);
    function O(_e) {
      E("ondata"), Be = !1;
      var le = o.write(_e);
      le === !1 && !Be && ((_.pipesCount === 1 && _.pipes === o || _.pipesCount > 1 && W(_.pipes, o) !== -1) && !Ce && (E("false write response, pause", _.awaitDrain), _.awaitDrain++, Be = !0), w.pause());
    }
    function xe(_e) {
      E("onerror", _e), be(), o.removeListener("error", xe), s(o, "error") === 0 && o.emit("error", _e);
    }
    Q(o, "error", xe);
    function Ae() {
      o.removeListener("finish", pe), be();
    }
    o.once("close", Ae);
    function pe() {
      E("onfinish"), o.removeListener("close", Ae), be();
    }
    o.once("finish", pe);
    function be() {
      E("unpipe"), w.unpipe(o);
    }
    return o.emit("pipe", w), _.flowing || (E("pipe resume"), w.resume()), o;
  };
  function ge(o) {
    return function() {
      var a = o._readableState;
      E("pipeOnDrain", a.awaitDrain), a.awaitDrain && a.awaitDrain--, a.awaitDrain === 0 && s(o, "data") && (a.flowing = !0, b(o));
    };
  }
  R.prototype.unpipe = function(o) {
    var a = this._readableState, w = { hasUnpiped: !1 };
    if (a.pipesCount === 0)
      return this;
    if (a.pipesCount === 1)
      return o && o !== a.pipes ? this : (o || (o = a.pipes), a.pipes = null, a.pipesCount = 0, a.flowing = !1, o && o.emit("unpipe", this, w), this);
    if (!o) {
      var _ = a.pipes, $ = a.pipesCount;
      a.pipes = null, a.pipesCount = 0, a.flowing = !1;
      for (var C = 0; C < $; C++)
        _[C].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var k = W(a.pipes, o);
    return k === -1 ? this : (a.pipes.splice(k, 1), a.pipesCount -= 1, a.pipesCount === 1 && (a.pipes = a.pipes[0]), o.emit("unpipe", this, w), this);
  }, R.prototype.on = function(o, a) {
    var w = u.prototype.on.call(this, o, a);
    if (o === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (o === "readable") {
      var _ = this._readableState;
      !_.endEmitted && !_.readableListening && (_.readableListening = _.needReadable = !0, _.emittedReadable = !1, _.reading ? _.length && ee(this) : e.nextTick(me, this));
    }
    return w;
  }, R.prototype.addListener = R.prototype.on;
  function me(o) {
    E("readable nexttick read 0"), o.read(0);
  }
  R.prototype.resume = function() {
    var o = this._readableState;
    return o.flowing || (E("resume"), o.flowing = !0, h(this, o)), this;
  };
  function h(o, a) {
    a.resumeScheduled || (a.resumeScheduled = !0, e.nextTick(y, o, a));
  }
  function y(o, a) {
    a.reading || (E("resume read 0"), o.read(0)), a.resumeScheduled = !1, a.awaitDrain = 0, o.emit("resume"), b(o), a.flowing && !a.reading && o.read(0);
  }
  R.prototype.pause = function() {
    return E("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (E("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function b(o) {
    var a = o._readableState;
    for (E("flow", a.flowing); a.flowing && o.read() !== null; )
      ;
  }
  R.prototype.wrap = function(o) {
    var a = this, w = this._readableState, _ = !1;
    o.on("end", function() {
      if (E("wrapped end"), w.decoder && !w.ended) {
        var k = w.decoder.end();
        k && k.length && a.push(k);
      }
      a.push(null);
    }), o.on("data", function(k) {
      if (E("wrapped data"), w.decoder && (k = w.decoder.write(k)), !(w.objectMode && k == null) && !(!w.objectMode && (!k || !k.length))) {
        var oe = a.push(k);
        oe || (_ = !0, o.pause());
      }
    });
    for (var $ in o)
      this[$] === void 0 && typeof o[$] == "function" && (this[$] = function(k) {
        return function() {
          return o[k].apply(o, arguments);
        };
      }($));
    for (var C = 0; C < N.length; C++)
      o.on(N[C], this.emit.bind(this, N[C]));
    return this._read = function(k) {
      E("wrapped _read", k), _ && (_ = !1, o.resume());
    }, this;
  }, Object.defineProperty(R.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), R._fromList = P;
  function P(o, a) {
    if (a.length === 0)
      return null;
    var w;
    return a.objectMode ? w = a.buffer.shift() : !o || o >= a.length ? (a.decoder ? w = a.buffer.join("") : a.buffer.length === 1 ? w = a.buffer.head.data : w = a.buffer.concat(a.length), a.buffer.clear()) : w = I(o, a.buffer, a.decoder), w;
  }
  function I(o, a, w) {
    var _;
    return o < a.head.data.length ? (_ = a.head.data.slice(0, o), a.head.data = a.head.data.slice(o)) : o === a.head.data.length ? _ = a.shift() : _ = w ? m(o, a) : A(o, a), _;
  }
  function m(o, a) {
    var w = a.head, _ = 1, $ = w.data;
    for (o -= $.length; w = w.next; ) {
      var C = w.data, k = o > C.length ? C.length : o;
      if (k === C.length ? $ += C : $ += C.slice(0, o), o -= k, o === 0) {
        k === C.length ? (++_, w.next ? a.head = w.next : a.head = a.tail = null) : (a.head = w, w.data = C.slice(k));
        break;
      }
      ++_;
    }
    return a.length -= _, $;
  }
  function A(o, a) {
    var w = d.allocUnsafe(o), _ = a.head, $ = 1;
    for (_.data.copy(w), o -= _.data.length; _ = _.next; ) {
      var C = _.data, k = o > C.length ? C.length : o;
      if (C.copy(w, w.length - o, 0, k), o -= k, o === 0) {
        k === C.length ? (++$, _.next ? a.head = _.next : a.head = a.tail = null) : (a.head = _, _.data = C.slice(k));
        break;
      }
      ++$;
    }
    return a.length -= $, w;
  }
  function B(o) {
    var a = o._readableState;
    if (a.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    a.endEmitted || (a.ended = !0, e.nextTick(D, a, o));
  }
  function D(o, a) {
    !o.endEmitted && o.length === 0 && (o.endEmitted = !0, a.readable = !1, a.emit("end"));
  }
  function W(o, a) {
    for (var w = 0, _ = o.length; w < _; w++)
      if (o[w] === a)
        return w;
    return -1;
  }
  return Er;
}
var Li = qe, Qt = ft(), qi = Object.create(re);
qi.inherits = Pe;
qi.inherits(qe, Qt);
function Xs(e, t) {
  var n = this._transformState;
  n.transforming = !1;
  var s = n.writecb;
  if (!s)
    return this.emit("error", new Error("write callback called multiple times"));
  n.writechunk = null, n.writecb = null, t != null && this.push(t), s(e);
  var u = this._readableState;
  u.reading = !1, (u.needReadable || u.length < u.highWaterMark) && this._read(u.highWaterMark);
}
function qe(e) {
  if (!(this instanceof qe))
    return new qe(e);
  Qt.call(this, e), this._transformState = {
    afterTransform: Xs.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", Ks);
}
function Ks() {
  var e = this;
  typeof this._flush == "function" ? this._flush(function(t, n) {
    Sn(e, t, n);
  }) : Sn(this, null, null);
}
qe.prototype.push = function(e, t) {
  return this._transformState.needTransform = !1, Qt.prototype.push.call(this, e, t);
};
qe.prototype._transform = function(e, t, n) {
  throw new Error("_transform() is not implemented");
};
qe.prototype._write = function(e, t, n) {
  var s = this._transformState;
  if (s.writecb = n, s.writechunk = e, s.writeencoding = t, !s.transforming) {
    var u = this._readableState;
    (s.needTransform || u.needReadable || u.length < u.highWaterMark) && this._read(u.highWaterMark);
  }
};
qe.prototype._read = function(e) {
  var t = this._transformState;
  t.writechunk !== null && t.writecb && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
};
qe.prototype._destroy = function(e, t) {
  var n = this;
  Qt.prototype._destroy.call(this, e, function(s) {
    t(s), n.emit("close");
  });
};
function Sn(e, t, n) {
  if (t)
    return e.emit("error", t);
  if (n != null && e.push(n), e._writableState.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (e._transformState.transforming)
    throw new Error("Calling transform done when still transforming");
  return e.push(null);
}
var Ys = mt, Wi = Li, Vi = Object.create(re);
Vi.inherits = Pe;
Vi.inherits(mt, Wi);
function mt(e) {
  if (!(this instanceof mt))
    return new mt(e);
  Wi.call(this, e);
}
mt.prototype._transform = function(e, t, n) {
  n(null, e);
};
(function(e, t) {
  t = e.exports = Di(), t.Stream = t, t.Readable = t, t.Writable = Ui(), t.Duplex = ft(), t.Transform = Li, t.PassThrough = Ys;
})(kr, kr.exports);
var Hi = kr.exports;
Object.defineProperty(Kr, "__esModule", { value: !0 });
const Zs = Hi;
function Qs(e) {
  if (!e || !e.engine)
    throw new Error("Missing engine parameter!");
  const { engine: t } = e, n = new Zs.Duplex({ objectMode: !0, read: s, write: u });
  return t.on && t.on("notification", (d) => {
    n.push(d);
  }), n;
  function s() {
  }
  function u(d, l, f) {
    t.handle(d, (g, T) => {
      n.push(T);
    }), f();
  }
}
Kr.default = Qs;
var Zr = {}, eu = te && te.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Zr, "__esModule", { value: !0 });
const tu = eu(Yt), ru = Hi;
function nu() {
  const e = {}, t = new ru.Duplex({
    objectMode: !0,
    read: u,
    write: d
  }), n = new tu.default();
  return { events: n, middleware: (g, T, F, E) => {
    t.push(g), e[g.id] = { req: g, res: T, next: F, end: E };
  }, stream: t };
  function u() {
    return !1;
  }
  function d(g, T, F) {
    let E;
    try {
      !g.id ? f(g) : l(g);
    } catch (j) {
      E = j;
    }
    F(E);
  }
  function l(g) {
    const T = e[g.id];
    if (!T)
      throw new Error(`StreamMiddleware - Unknown response id "${g.id}"`);
    delete e[g.id], Object.assign(T.res, g), setTimeout(T.end);
  }
  function f(g) {
    n.emit("notification", g);
  }
}
Zr.default = nu;
var Gi = te && te.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(gt, "__esModule", { value: !0 });
var zi = gt.createStreamMiddleware = gt.createEngineStream = void 0;
const iu = Gi(Kr);
gt.createEngineStream = iu.default;
const ou = Gi(Zr);
zi = gt.createStreamMiddleware = ou.default;
var au = zr, su = Si, Nr = function() {
}, uu = /^v?\.0/.test(J.process.version), Qr = function(e) {
  return typeof e == "function";
}, fu = function(e) {
  return !1;
}, cu = function(e) {
  return e.setHeader && Qr(e.abort);
}, lu = function(e, t, n, s) {
  s = au(s);
  var u = !1;
  e.on("close", function() {
    u = !0;
  }), su(e, { readable: t, writable: n }, function(l) {
    if (l)
      return s(l);
    u = !0, s();
  });
  var d = !1;
  return function(l) {
    if (!u && !d) {
      if (d = !0, fu())
        return e.close(Nr);
      if (cu(e))
        return e.abort();
      if (Qr(e.destroy))
        return e.destroy();
      s(l || new Error("stream was destroyed"));
    }
  };
}, An = function(e) {
  e();
}, du = function(e, t) {
  return e.pipe(t);
}, hu = function() {
  var e = Array.prototype.slice.call(arguments), t = Qr(e[e.length - 1] || Nr) && e.pop() || Nr;
  if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
    throw new Error("pump requires two streams per minimum");
  var n, s = e.map(function(u, d) {
    var l = d < e.length - 1, f = d > 0;
    return lu(u, l, f, function(g) {
      n || (n = g), g && s.forEach(An), !l && (s.forEach(An), t(n));
    });
  });
  return e.reduce(du);
}, pu = hu;
const xn = /* @__PURE__ */ Tn(pu), yu = "cede-provider", Nt = class Nt extends Os {
  constructor(n, { jsonRpcStreamName: s = yu, maxEventListeners: u = 100 } = {}) {
    super();
    ye(this, "_state");
    ye(this, "_rpcEngine");
    ye(this, "_jsonRpcConnection");
    ye(this, "_connectionStream");
    /**
     * Internal RPC method. Forwards requests to background via the RPC engine.
     * Also remap ids inbound and outbound.
     *
     * @param payload - The RPC request object.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ye(this, "request", async (n) => {
      if (!n || typeof n != "object" || Array.isArray(n))
        throw ot.ethErrors.rpc.invalidRequest({
          message: dt.errors.invalidRequestArgs(),
          data: n
        });
      const { method: s, params: u } = n;
      if (typeof s != "string" || s.length === 0)
        throw ot.ethErrors.rpc.invalidRequest({
          message: dt.errors.invalidRequestMethod(),
          data: n
        });
      if (u !== void 0 && !Array.isArray(u) && (typeof u != "object" || u === null))
        throw ot.ethErrors.rpc.invalidRequest({
          message: dt.errors.invalidRequestParams(),
          data: n
        });
      if (!(u != null && u.version))
        throw new Error("No version provided");
      const d = new Promise((l, f) => {
        const g = { method: s, params: u }, T = ji(l, f);
        return g.jsonrpc || (g.jsonrpc = "2.0"), this._rpcEngine.handle(g, T);
      });
      return s === "connect" && (u != null && u.silent) && d.then((l) => {
        l && (this._state.isUnlocked = !0);
      }).catch((l) => l), d;
    });
    if (this._connectionStream = n, n.addListener("close", () => {
      console.log("Connection closed !");
    }), !Ps.duplex(n))
      throw new Error(dt.errors.invalidDuplexStream());
    this.setMaxListeners(u), this._state = Qi({
      ...Nt._defaultState
    }), this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this), this.request = this.request.bind(this);
    const d = new ps();
    xn(
      n,
      d,
      n,
      this._handleStreamDisconnect.bind(this, "CEDE.store")
    ), this.on("connect", () => {
      this._state.isConnected = !0;
    }), this._jsonRpcConnection = zi(), xn(
      this._jsonRpcConnection.stream,
      d.createStream(s),
      this._jsonRpcConnection.stream,
      this._handleStreamDisconnect.bind(this, "CEDE.store RpcProvider")
    );
    const l = new Fr.JsonRpcEngine();
    l.push(Fr.createIdRemapMiddleware()), l.push(this._jsonRpcConnection.middleware), this._rpcEngine = l, this._jsonRpcConnection.events.on("notification", (f) => {
      const { method: g, params: T } = f;
      Ii.includes(g) ? this.emit("message", {
        type: g,
        data: T
      }) : g === "STREAM_FAILURE" ? n.destroy(new Error(dt.errors.permanentlyDisconnected())) : this.executeMethod(g, T);
    });
  }
  /**
   * Called when connection is lost to critical streams.
   *
   * @emits InpageProvider#disconnect
   */
  _handleStreamDisconnect(n, s) {
    console.log(`Critical stream failure for ${n}`), this._state.isConnected && (this._state.isConnected = !1, this._state.vaultPreviews = null, this._state.isUnlocked = !1, this.emit("disconnect", s));
  }
  /**
   * When the provider becomes connected, updates internal state and emits
   * required events. Idempotent.
   *
   * @emits connect event
   */
  _connectionEstablished() {
    console.log("Connection established !"), this._state.isConnected || (this._state.isConnected = !0, this.emit("connect"));
  }
  async _updateVaults(n) {
    var s;
    this._state.vaultPreviews = n.vaultsPreview, this.emit("accountsChanged", [
      (s = n.vaultsPreview.find((u) => u.isActive)) == null ? void 0 : s.name
    ]);
  }
  _unlock() {
    this._state.isUnlocked = !0, this.emit("unlock");
  }
  _lock() {
    this._state.isUnlocked = !1, this._state.vaultPreviews = [], this.emit("lock");
  }
  getNotificationApi() {
    return {
      connect: this._connectionEstablished.bind(this),
      accountsChanged: this._updateVaults.bind(this),
      unlock: this._unlock.bind(this),
      lock: this._lock.bind(this)
    };
  }
  executeMethod(n, ...s) {
    const d = this.getNotificationApi()[n];
    if (!d)
      throw new Error(`Method not found : ${n}`);
    return d(...s);
  }
  getIsUnlocked() {
    return this._state.isUnlocked;
  }
  /** Returns vaultPreview */
  getVaultPreviews() {
    return this._state.vaultPreviews;
  }
  getActiveVault() {
    return (this.getVaultPreviews() || []).find((n) => n.isActive);
  }
};
ye(Nt, "_defaultState", {
  vaultPreviews: null,
  isConnected: !1,
  isUnlocked: !1
});
let Rn = Nt;
const Z = {
  // transport related errors
  rpc: {
    parse: {
      code: -32700,
      message: "JSON parsing error",
      description: "{data.description}",
      documentation: "An error occurred on the server while parsing the JSON text"
    },
    invalidRequest: {
      code: -32600,
      message: "Invalid request object",
      description: "{data.description}",
      documentation: "The JSON sent is not a valid Request object"
    },
    methodNotFound: {
      code: -32601,
      message: "Method not found",
      description: "{data.description}",
      documentation: "The method does not exist / is not available"
    },
    invalidParams: {
      code: -32602,
      message: "Invalid method parameter(s)",
      description: "{data.description}",
      documentation: "Provided parameters do not match the method signature"
    },
    internal: {
      code: -32603,
      message: "Internal JSON-RPC error",
      description: "{data.description}",
      documentation: "Something went wrong in the communication engine of cede.store"
    }
  },
  defaultError: {
    code: 1e3,
    message: "cede.store default error",
    description: "{vault_and_account}: An error occurred",
    documentation: "Something went wrong in cede.store"
  },
  // ccxt library specific errors
  ccxt: {
    general: {
      notSupportedNfts: {
        code: 3e3,
        message: "NFTs are not supported",
        description: "{account.exchangeId}: NFTs aren't supported",
        documentation: "NFTs aren't supported on the given exchange"
      },
      cexError: {
        code: 3001,
        message: "CEX error",
        description: "{vault_and_account}: The exchange has a system abnormality. Original error: {error.message}",
        documentation: "The exchange has a system abnormality. The original exchange error is provided."
      },
      cexApiAuthError: {
        code: 3002,
        message: "CEX API authentication error",
        description: "{vault_and_account}: Invalid API-KEY or permission denied",
        documentation: "Invalid API key or permission denied"
      },
      cexNotAvailable: {
        code: 3003,
        message: "CEX is not available",
        description: "{vault_and_account}: Exchange is not available, please try again later",
        documentation: "Exchange is not available, please try again later"
      },
      cexOnMaintenance: {
        code: 3004,
        message: "CEX on maintenance",
        description: "{vault_and_account}: Exchange is on maintenance, please try again later",
        documentation: "Exchange is on maintenance, please try again later"
      },
      invalidNonce: {
        code: 3005,
        message: "Invalid nonce",
        description: "The API keys seem to be used by another app. Please create new {account.exchangeId} API keys and use them only for cede.store.",
        documentation: "The API keys seem to be used by another app. The user should create new API keys and use them only for cede.store."
      },
      notSupported: {
        code: 3006,
        message: "Not supported",
        description: "{vault_and_account}: Not supported - {error.message}",
        documentation: "This error is raised if the endpoint is not offered/not supported by the exchange API"
      }
    },
    order: {
      orderNotFound: {
        code: 3100,
        message: "Could not find the order",
        description: "{vault_and_account}: Order not found",
        documentation: "Raised when you are trying to fetch or cancel a non-existent order"
      },
      orderImmediatelyFillable: {
        code: 3101,
        message: "The order is immediately fillable",
        description: "{vault_and_account}: Order would immediately be triggered",
        documentation: "Raised when the order you're trying to place would immediately be triggered and filled, and not be placed on the order book"
      },
      orderNotFillable: {
        code: 3102,
        message: "The order is not fillable",
        description: "{vault_and_account}: Unable to fill this order - {error.message}",
        documentation: "Unable to fill this order"
      },
      invalidOrder: {
        code: 3103,
        message: "The order is invalid",
        description: "{vault_and_account}: Invalid order - {error.message}",
        documentation: "Raised when the order you're trying to place is not valid"
      },
      duplicateOrderId: {
        code: 3104,
        message: "Two or more orders have identical ids",
        description: "{vault_and_account}: Duplicate order id found",
        documentation: "Raised when two or more orders have identical ids"
      }
    },
    request: {
      badRequest: {
        code: 3200,
        message: "Bad request",
        description: "{vault_and_account}: Bad request - {error.message}",
        documentation: "The request is malformed, the content of the request is not valid"
      },
      requestTimeout: {
        code: 3201,
        message: "Request timeout",
        description: "{vault_and_account}: Request timeout, please try again later",
        documentation: "The request timed out"
      },
      badResponse: {
        code: 3202,
        message: "Bad response",
        description: "{vault_and_account}: Bad response from the exchange - {error.message}",
        documentation: "The response from the exchange is malformed"
      },
      rateLimitExceeded: {
        code: 3203,
        message: "Rate limit exceeded",
        description: "{vault_and_account}: Rate limit exceeded, please try again later",
        documentation: "The request rate limit has been exceeded"
      },
      argumentsRequired: {
        code: 3204,
        message: "Method requires some arguments",
        description: "{vault_and_account}: Arguments required - {error.message}",
        documentation: "The method requires some arguments"
      },
      nullResponse: {
        code: 3205,
        message: "Null response",
        description: "{vault_and_account}: Null response from the exchange - {error.message}",
        documentation: "The response from the exchange is null"
      },
      ddosProtection: {
        code: 3206,
        message: "DDOS protection",
        description: "{vault_and_account}: DDOS protection. Too many requests, please try again later",
        documentation: "The request has been rejected by the exchange due to DDOS protection"
      },
      badSymbol: {
        code: 3207,
        message: "Bad symbol",
        description: "{vault_and_account}: Bad symbol {account} - {error.message}",
        documentation: "The symbol is not valid"
      }
    },
    account: {
      accountSuspended: {
        code: 3300,
        message: "Account suspended",
        description: "{vault_and_account}: Account suspended",
        documentation: "The user account is suspended"
      },
      permissionDenied: {
        code: 3301,
        message: "Permission denied",
        description: "{vault_and_account}: permission denied. Your key doesn't have the right permissions.",
        documentation: "The user doesn't have enough permission to perform the action"
      },
      insufficientFunds: {
        code: 3302,
        message: "Insufficient funds",
        description: "{vault_and_account}: Insufficient balance",
        documentation: "The user doesn't have enough funds to perform the action"
      },
      invalidAddress: {
        code: 3303,
        message: "Invalid address",
        description: "{vault_and_account}: Invalid address",
        documentation: "The address is not valid"
      },
      addressPending: {
        code: 3304,
        message: "Address pending",
        description: "{vault_and_account}: Address pending",
        documentation: "The address is pending"
      },
      cancelPending: {
        code: 3305,
        message: "Cancel pending",
        description: "{vault_and_account}: Cancel pending",
        documentation: "The cancel is pending"
      }
    }
  },
  internal: {
    general: {
      badPassword: {
        code: 4e3,
        message: "Bad password",
        description: "Bad password",
        documentation: "The password provided is incorrect"
      }
    },
    misc: {
      jobs: {
        fetchTransactionHistoryError: {
          code: 4100,
          message: "Transaction history cannot be fetched through the job",
          description: "An error happened while fetching the transaction history",
          documentation: "An error happened while fetching the transaction history"
        },
        getLastTxUpdateError: {
          code: 4101,
          message: "Last transaction update cannot be fetched through the job",
          description: "An error happened while getting the last transaction update",
          documentation: "An error happened while getting the last transaction update"
        }
      }
    },
    vault: {
      accountAlreadyExists: {
        code: 4200,
        message: "Vault account already exists",
        description: "The exchange account has already been added to the vault",
        documentation: "The exchange account has already been added to the vault"
      },
      nameExists: {
        code: 4201,
        message: "Vault name already exists",
        description: "The vault {vault} already exists",
        documentation: "Raised when trying to create the vault with same name as the existent vault"
      },
      nameCannotBeGenerated: {
        code: 4202,
        message: "Vault name cannot be generated",
        description: "The vault name cannot be generated",
        documentation: "Raised when there is an error in the vault name generation"
      },
      accountKeysInconsistent: {
        code: 4203,
        message: "Account keys inconsistent. They may not relate to the same account",
        description: "The Api Keys are not related to the same CEX account",
        documentation: "Raised when the user is trying to a second pair of API keys for the 2 key CEX which are not related to the same account"
      },
      cannotUnlockStorage: {
        code: 4204,
        message: "The storage cannot be unlocked",
        description: "Cede Store cannot unlock the storage",
        documentation: "Raised when the storage cannot be unlocked"
      },
      cannotPersisted: {
        code: 4205,
        message: "Vaults cannot persisted",
        description: "The vaults cannot be persisted",
        documentation: "Raised when the vaults cannot be persisted"
      },
      creationError: {
        code: 4206,
        message: "Vault creation error",
        description: "{vault}: An error happened while creating the vault",
        documentation: "Raised when an error happened while creating the vault"
      },
      deletionError: {
        code: 4207,
        message: "Vault deletion error",
        description: "{vault}: An error happened while deleting the vault",
        documentation: "Raised when an error happened while deleting the vault"
      },
      checkApiCredentialsError: {
        code: 4208,
        message: "API check credentials failure",
        description: "{vault}: An error happened while checking the API credentials",
        documentation: "Raised when an error happened while checking the API credentials when adding a new CEX"
      },
      updateApiCredentialsError: {
        code: 4209,
        message: "API update credentials failure",
        description: "{vault_and_account}: An error happened while updating the API credentials",
        documentation: "Raised when an error happened while updating the API credentials when updating a CEX"
      },
      updateCexSettingsError: {
        code: 4210,
        message: "Vault CEX update settings error",
        description: "{vault_and_account}: An error happened while updating the CEX settings",
        documentation: "Raised when an error happened while updating the CEX settings when updating a CEX"
      },
      accountCreationError: {
        code: 4211,
        message: "Vault account creation error",
        description: "{vault}: An error happened while creating the account",
        documentation: "Raised when an error happened while creating the account"
      },
      accountUpdateError: {
        code: 4212,
        message: "Vault account update error",
        description: "{vault_and_account}: An error happened while updating the account",
        documentation: "Raised when an error happened while updating the account"
      },
      globalUnlockError: {
        code: 4213,
        message: "Vault cannot be unlocked",
        description: "An error happened while unlocking the vaults",
        documentation: "Raised when an error happened while unlocking globally the vaults"
      },
      notWhitelisted: {
        code: 4214,
        message: "IP not whitelisted for API keys",
        description: "IP addresses weren't whitelisted. Please, whitelist them first.",
        documentation: "Raised when cede.store proxy IP was not whitelisted on the CEX side"
      },
      accountKeyAlreadyExists: {
        code: 4215,
        message: "API key already exists",
        description: "The API Key already exists",
        documentation: "Raised when the user is trying to update a key using one that already exists in the vault for the same CEX"
      },
      whitelistCheckFail: {
        code: 4216,
        message: "Whitelist check failed",
        description: "Whitelist check failed. Please try again later.",
        documentation: "Raised when the whitelist check failed"
      }
    }
  },
  // cede.store background errors
  cede: {
    general: {
      dispatcherDefaultError: {
        code: 5e3,
        message: "Dispatcher default error",
        description: "An error occured while {data.humanizedAction}",
        documentation: "An error occured while executing the method."
      },
      approvalNotFound: {
        code: 5001,
        message: "Approval not found",
        description: "The approval {data.approvalId} isn't found",
        documentation: "The approval isn't found. This can happen if the approval is not in pending approvals array"
      },
      vaultNotAllowedToAccess: {
        code: 5002,
        message: "Vault is not allowed to access",
        description: "You aren't allowed to access to this vault",
        documentation: "You aren't allowed to access to this vault"
      },
      accountNotPermission: {
        code: 5003,
        message: "Account does not have sufficient permissions to perform this action",
        description: "The account {account} doesn't have the permission to {data.permission} : {vault}",
        documentation: "The account doesn't have the permission to perform this action. If the account is read-only, you can't perform trades/withdrawals"
      },
      notAllowedMethod: {
        code: 5004,
        message: "Method not allowed",
        description: "You aren't available to access to the method {data.method}",
        documentation: "You aren't available to access to the given method"
      },
      notConnected: {
        code: 5005,
        message: "Not connected",
        description: "Connect with cede.store to perfom this request",
        documentation: "Connect with cede.store to perfom this request"
      },
      notInitialized: {
        code: 5006,
        message: "Not initialized",
        description: "The user must set up at least one vault in the cede.store first",
        documentation: "Raised when cede.store has been downloaded but not initialized. The user must set up at least one vault in the cede.store first"
      },
      oauthAccessRevoked: {
        code: 5007,
        message: "Access token revoked",
        description: "{vault}: Access token revoked. You should remove the {account} account and add it again.",
        documentation: "Raised when user adds an account via OAuth2. The user must remove and add the account again to get the new access token."
      },
      notSupportedFeature: {
        code: 5108,
        message: "This feature is not supported by the {account}",
        description: "This feature is not supported by the {account}",
        documentation: "Verify if the feature is supported by the CEX"
      },
      userDeniedApproval: {
        code: 5109,
        message: "User denied approval",
        description: "User denied approval",
        documentation: "User denied approval"
      }
    },
    vault: {
      notFound: {
        code: 5100,
        message: "Vault not found",
        description: "The vault was not found",
        documentation: "The vault was not found. Verify the vauld id"
      },
      accountNotFound: {
        code: 5101,
        message: "Vault account not found",
        // TODO make sure the error handler puts accountId in the context
        description: "{vault}: The account {account} was not found",
        documentation: "The account was not found. Verify the account name"
      },
      fetchVaultsError: {
        code: 5102,
        message: "Vaults cannot be retrieved",
        description: "An error happened while retrieveing the vaults",
        documentation: "Raised when the vaults cannot be retrieved from cede.store"
      },
      generateAccountNameError: {
        code: 5103,
        message: "An error occured while generating the account name",
        description: "An error occured while generating the account name",
        documentation: "The generate account name method shouldn't fail"
      },
      validateAccountNameError: {
        code: 5104,
        message: "An error occured while validating the account name",
        description: "An error occured while validating the account name",
        documentation: "The validate account name method shouldn't fail"
      },
      updateAccountNameError: {
        code: 5105,
        message: "An error occured while updating the account name",
        description: "An error occured while updating the account name",
        documentation: "Verify if the old account name is valid because we are using it to update the account"
      },
      getAccountError: {
        code: 5106,
        message: "An error occured while getting the account",
        description: "An error occured while getting the account",
        documentation: "Verify if the account id is valid"
      },
      getAccountsError: {
        code: 5107,
        message: "An error occured while getting the accounts",
        description: "An error occured while getting the accounts",
        documentation: "Verify if the vault id is valid"
      },
      notOAuthAccount: {
        code: 5108,
        message: "The account is not an OAuth account",
        description: "The account is not an OAuth account",
        documentation: "This error is raised when we try to perform an action on an OAuth account and the account is not using OAuth"
      }
    },
    exchange: {
      // public data, such as available tickers, tokens, etc.
      public: {
        fetchTickerFromTokenError: {
          code: 5201,
          message: "Cannot fetch ticker from token",
          description: "{vault_and_account}: An error happened while fetching tickers",
          documentation: "Raised when the ticker for a given token symbol cannot be retrieved from the CEX"
        },
        tokenNotFound: {
          code: 5202,
          message: "Token not found",
          description: "{vault_and_account}: The token {data.tokenSymbol} was not found",
          documentation: "Raised when the token cannot be found on the CEX"
        },
        marketNotFound: {
          code: 5203,
          message: "Market not found",
          description: "{vault_and_account}: The market {data.pairSymbol} was not found",
          documentation: "Raised when the market cannot be found on the CEX"
        }
      },
      // fungible and non-fungible balances (tokens, nfts, fiat)
      balances: {
        getBalancesError: {
          code: 5210,
          message: "Cannot retrieve vault portfolio from CEX",
          description: "{vault_and_account}: An error happened while fetching the portfolio from the CEX",
          documentation: "Raised when the portfolio cannot be retrieved from the CEX"
        },
        getNftFromCexError: {
          code: 5211,
          message: "NFTs cannot be fetched from CEX",
          description: "{vault_and_account}: An error happened while fetching the NFTs",
          documentation: "Raised when the NFTs cannot be retrieved from the CEX"
        }
      },
      transactions: {
        getVaultTransactionsError: {
          code: 5220,
          message: "Cannot retrieve vault transactions",
          description: "{vault_and_account}: An error happened while fetching the vault transactions",
          documentation: "Raised when the transactions cannot be retrieved from the CEX"
        }
      },
      deposit: {
        getDepositableTokensError: {
          code: 5230,
          message: "Cannot get depositable tokens",
          description: "{vault_and_account}: An error happened while fetching the depositable tokens",
          documentation: "Raised when the depositable tokens cannot be retrieved from the CEX"
        },
        getDepositAddressError: {
          code: 5231,
          message: "Cannot get deposit address",
          description: "{vault_and_account}: An error happened while fetching the deposit address",
          documentation: "Raised when the deposit address cannot be retrieved from the CEX"
        }
      },
      trade: {
        postOrderError: {
          code: 5240,
          message: "Error encountered while posting order",
          description: "{vault_and_account}: An error occured with the market order",
          documentation: "Raised when the order cannot be posted to the CEX"
        },
        fetchMarketPairsError: {
          code: 5241,
          message: "Market pairs cannot be fetched",
          description: "{vault_and_account}: An error happened while fetching the market pairs",
          documentation: "Raised when the market pairs cannot be retrieved from the CEX"
        },
        fetchAllTickersFromSymbolsError: {
          code: 5242,
          message: "Tickers cannot be fetched from symbols",
          description: "{vault_and_account}: An error happened while fetching the tickers",
          documentation: "Raised when the tickers cannot be retrieved from the CEX"
        },
        orderNotFound: {
          code: 5243,
          message: "Order not found",
          description: "{vault_and_account}: The order {data.orderId} was not found",
          documentation: "Raised when the order cannot be found on the CEX"
        },
        minAmountError: {
          code: 5244,
          message: "Minimum amount error",
          description: "{vault_and_account}: The amount should be greater than {data.minAmount}",
          documentation: "Raised when the amount is too low to execute the trade"
        },
        tickerNotFound: {
          code: 5245,
          message: "Ticker not found",
          description: "{vault_and_account}: The ticker for {data.pairSymbol} was not found",
          documentation: "Raised when the ticker cannot be found on the CEX"
        },
        invalidOrderRequest: {
          code: 5246,
          message: "Invalid order request",
          description: "{vault_and_account}: The order request is invalid: {data.error}",
          documentation: "This error is triggered by invalid order requests. It could arise due to inappropriate data inputs, such as a price set to zero. To streamline error handling, we avoid generating overly specific errors for each scenario. This approach assumes that proper data validation is performed within the dApp, ensuring user inputs are correct."
        },
        fetchMarketPriceError: {
          code: 5247,
          message: "Market rates cannot be fetched",
          description: "{vault_and_account}: An error happened while fetching market rates",
          documentation: "Raised when market rates cannot be retrieved from the CEX"
        }
      },
      network: {
        networkNotFound: {
          code: 5250,
          message: "Network not found",
          description: "The network {data.network} isn't found",
          documentation: "Raised when the network isn't found"
        },
        networkNotProvided: {
          code: 5251,
          message: "Network not provided",
          description: "The network is not provided",
          documentation: "Raised when the network is not provided, but required"
        },
        networksNotStandardized: {
          code: 5252,
          message: "Networks are not standardized",
          description: "The networks are not standardized",
          documentation: "Raised when the networks are not standardized"
        }
      },
      withdrawal: {
        tokenToDefiAddressError: {
          code: 5260,
          message: "Error encountered while withdrawing token to DeFi address",
          description: "{vault_and_account}: An error happened while withdrawing to a DeFi address",
          documentation: "Raised when the withdrawal cannot be posted to DeFi address"
        },
        tokenToAnotherCexError: {
          code: 5261,
          message: "Error encountered while withdrawing token to another CEX",
          description: "{vault_and_account}: An error happened while withdrawing to another CEX",
          documentation: "Raised when the withdrawal cannot be posted to the CEX"
        },
        notFound: {
          code: 5262,
          message: "Withdrawal not found",
          description: "The withdrawal with id {data.withdrawalId} isn't found",
          documentation: "Raised when the withdrawal isn't found"
        },
        infoError: {
          code: 5263,
          message: "Withdrawal info error",
          description: "{vault_and_account}: Withdrawal info not found",
          documentation: "Raised when the withdrawal info cannot be retrieved from the CEX"
        },
        notEnoughBalance: {
          code: 5265,
          message: "Not enough balance to withdraw",
          description: "{vault_and_account}: Not enough balance to withdraw",
          documentation: "Raised when the balance hasn't enough funds to execute the withdrawal"
        },
        underWithdrawMin: {
          code: 5266,
          message: "Amount under the minimum withdrawal amount",
          description: "{vault_and_account}: Amount under the minimum withdrawal amount",
          documentation: "Raised when the amount is under the minimum withdrawal amount"
        },
        overWithdrawMax: {
          code: 5267,
          message: "Amont over the maximum withdrawal amount",
          description: "{vault_and_account}: Amount over the maximum withdrawal amount",
          documentation: "Raised when the amount is over the maximum withdrawal amount"
        }
      },
      coinbase: {
        accountNotFound: {
          code: 5270,
          message: "Coinbase account not found",
          description: "{account}: The account for currency {data.currency} was not found",
          documentation: "Raised when the account for currency cannot be found on the CEX"
        }
      },
      binance: {
        readonlyBinanceNotProvided: {
          code: 5280,
          message: "Read-only Binance account not provided",
          description: "{account}: The read-only Binance account was not provided",
          documentation: "Raised when the read-only Binance account was not provided"
        }
      },
      register: {
        invalidExchangeId: {
          code: 5290,
          message: "Error encountered while registering an exchange instance",
          description: "Invalid exchange id",
          documentation: "Raised when the exchange id isn't recognized"
        },
        invalidExchangeInstanceId: {
          code: 5291,
          message: "Error encountered while getting an exchange instance",
          description: "Invalid exchange instance id",
          documentation: "Raised when the exchange instance id isn't recognized"
        },
        invalidCredentials: {
          code: 5292,
          message: "Error encountered while checking credentials of an exchange instance",
          description: "Invalid credentials",
          documentation: "Raised when the credentials are invalid"
        }
      },
      authentication: {
        authenticationFlowNotSupported: {
          code: 5300,
          message: "Authentication flow not supported",
          description: "Authentication flow not supported",
          documentation: "Raised when the authentication flow is not supported"
        },
        oauthFlowInterruptedByTheUser: {
          code: 5301,
          message: "Connection has been interrupted",
          description: "Connection has been interrupted",
          documentation: "Raised when the OAuth flow is interrupted by the user (e.g. user closes the authorization popup)"
        }
      }
    }
  },
  api: {
    invalidRequest: {
      code: 6e3,
      message: "Error encountered when sending a request to the api",
      description: "Request failed",
      documentation: "Raised when an API request failed"
    }
  }
};
Z.ccxt.general.cexError, Z.ccxt.general.cexApiAuthError, Z.ccxt.account.permissionDenied, Z.ccxt.account.accountSuspended, Z.ccxt.request.argumentsRequired, Z.ccxt.request.badRequest, Z.ccxt.request.badSymbol, Z.ccxt.request.badResponse, Z.ccxt.account.insufficientFunds, Z.ccxt.request.nullResponse, Z.ccxt.account.invalidAddress, Z.ccxt.order.invalidOrder, Z.ccxt.account.addressPending, Z.ccxt.order.orderNotFound, Z.ccxt.order.orderImmediatelyFillable, Z.ccxt.order.orderNotFillable, Z.ccxt.account.cancelPending, Z.ccxt.order.duplicateOrderId, Z.ccxt.general.notSupported, Z.ccxt.general.invalidNonce, Z.ccxt.request.requestTimeout, Z.ccxt.general.cexNotAvailable, Z.ccxt.general.cexOnMaintenance, Z.ccxt.request.ddosProtection, Z.ccxt.request.rateLimitExceeded;
const gu = (e) => {
  const t = {};
  function n(s, u = "") {
    for (const d in s) {
      const l = s[d], f = u ? `${u}.${d}` : d;
      typeof l == "object" && "code" in l && typeof l.code == "number" && typeof l.documentation == "string" && typeof l.message == "string" ? t[f] = {
        code: l.code,
        message: l.message,
        documentation: l.documentation
      } : typeof l == "object" && n(l, f);
    }
  }
  return n(e), t;
}, Eu = gu(Z);
export {
  Eu as CedeErrors,
  en as CedeProvider,
  Rn as InpageProvider,
  yu as PROVIDER,
  Yi as RequestVersion,
  wu as detectCedeProvider
};
