import "./chunk-2E63JINA.js";

// node_modules/@web3-onboard/ledger/dist/v1.js
function ledger(options = { walletConnectVersion: 1 }) {
  return () => {
    return {
      label: "Ledger",
      getIcon: async () => (await import("./icon-LNV7LDDF.js")).default,
      getInterface: async ({ chains, EventEmitter }) => {
        const { loadConnectKit, SupportedProviders, SupportedProviderImplementations } = await import("./esm-HHMJ5BZW.js");
        const connectKit = await loadConnectKit();
        if (options.enableDebugLogs) {
          connectKit.enableDebugLogs();
        }
        const checkSupportResult = connectKit.checkSupport({
          providerType: SupportedProviders.Ethereum,
          chainId: options === null || options === void 0 ? void 0 : options.chainId,
          infuraId: options === null || options === void 0 ? void 0 : options.infuraId,
          rpc: options === null || options === void 0 ? void 0 : options.rpc
        });
        const instance = await connectKit.getProvider();
        if (checkSupportResult.providerImplementation === SupportedProviderImplementations.LedgerConnect) {
          return {
            provider: instance
          };
        }
        const { StaticJsonRpcProvider } = await import("./lib-E6NAM244.js");
        const { ProviderRpcError, ProviderRpcErrorCode } = await import("./dist-B6GI6SQT.js");
        const { default: WalletConnect } = await import("./esm-V74NOKV4.js");
        const { Subject, fromEvent } = await import("./esm5-GKP2IZLS.js");
        const { takeUntil, take } = await import("./operators-HZEBPPU3.js");
        const connector = instance.connector;
        const emitter = new EventEmitter();
        class EthProvider {
          constructor({ connector: connector2, chains: chains2 }) {
            this.emit = emitter.emit.bind(emitter);
            this.on = emitter.on.bind(emitter);
            this.removeListener = emitter.removeListener.bind(emitter);
            this.connector = connector2;
            this.chains = chains2;
            this.disconnected$ = new Subject();
            this.providers = {};
            let activeChain;
            fromEvent(this.connector, "session_update", (error, payload) => {
              if (error) {
                throw error;
              }
              return payload;
            }).pipe(takeUntil(this.disconnected$)).subscribe({
              next: ({ params }) => {
                const [{ accounts, chainId }] = params;
                const lowerCaseAccounts = accounts.map((accountAddress) => accountAddress.toLowerCase());
                this.emit("accountsChanged", lowerCaseAccounts);
                const hexChainId = isHexString(chainId) ? chainId : `0x${chainId.toString(16)}`;
                if (!activeChain || activeChain !== hexChainId) {
                  this.emit("chainChanged", hexChainId);
                  activeChain = hexChainId;
                }
              },
              error: console.warn
            });
            fromEvent(this.connector, "disconnect", (error, payload) => {
              if (error) {
                throw error;
              }
              return payload;
            }).pipe(takeUntil(this.disconnected$)).subscribe({
              next: () => {
                this.emit("accountsChanged", []);
                this.disconnected$.next(true);
                typeof localStorage !== "undefined" && localStorage.removeItem("walletconnect");
              },
              error: console.warn
            });
            this.disconnect = () => this.connector.killSession();
            this.request = async ({ method, params }) => {
              if (method === "eth_chainId") {
                return isHexString(this.connector.chainId) ? this.connector.chainId : `0x${this.connector.chainId.toString(16)}`;
              }
              if (method === "eth_requestAccounts") {
                return new Promise((resolve, reject) => {
                  fromEvent(this.connector, "connect", (error, payload) => {
                    if (error) {
                      throw error;
                    }
                    return payload;
                  }).pipe(take(1)).subscribe({
                    next: ({ params: params2 }) => {
                      const [{ accounts, chainId: chainId2 }] = params2;
                      const lowerCaseAccounts = accounts.map((accountAddress) => accountAddress.toLowerCase());
                      this.emit("accountsChanged", lowerCaseAccounts);
                      const hexChainId = isHexString(chainId2) ? chainId2 : `0x${chainId2.toString(16)}`;
                      if (!activeChain)
                        activeChain = hexChainId;
                      this.emit("chainChanged", hexChainId);
                      resolve(lowerCaseAccounts);
                    },
                    error: reject
                  });
                  if (!this.connector.connected) {
                    resolve(instance.request({ method, params }));
                  } else {
                    const { accounts, chainId: chainId2 } = this.connector.session;
                    const hexChainId = isHexString(chainId2) ? chainId2 : `0x${chainId2.toString(16)}`;
                    this.emit("chainChanged", hexChainId);
                    if (!activeChain)
                      activeChain = hexChainId;
                    const lowerCaseAccounts = accounts.map((accountAddress) => accountAddress.toLowerCase());
                    return resolve(lowerCaseAccounts);
                  }
                });
              }
              if (method === "eth_selectAccounts") {
                throw new ProviderRpcError({
                  code: ProviderRpcErrorCode.UNSUPPORTED_METHOD,
                  message: `The Provider does not support the requested method: ${method}`
                });
              }
              if (method == "wallet_switchEthereumChain") {
                if (!params) {
                  throw new ProviderRpcError({
                    code: ProviderRpcErrorCode.INVALID_PARAMS,
                    message: `The Provider requires a chainId to be passed in as an argument`
                  });
                }
                const chainIdObj = params[0];
                if (!chainIdObj.hasOwnProperty("chainId") || typeof chainIdObj["chainId"] === "undefined") {
                  throw new ProviderRpcError({
                    code: ProviderRpcErrorCode.INVALID_PARAMS,
                    message: `The Provider requires a chainId to be passed in as an argument`
                  });
                }
                return this.connector.sendCustomRequest({
                  method: "wallet_switchEthereumChain",
                  params: [
                    {
                      chainId: chainIdObj.chainId
                    }
                  ]
                });
              }
              if (method === "eth_sendTransaction") {
                return this.connector.sendTransaction(params[0]);
              }
              if (method === "eth_signTransaction") {
                return this.connector.signTransaction(params[0]);
              }
              if (method === "personal_sign") {
                return this.connector.signPersonalMessage(params);
              }
              if (method === "eth_sign") {
                return this.connector.signMessage(params);
              }
              if (method.includes("eth_signTypedData")) {
                return this.connector.signTypedData(params);
              }
              if (method === "eth_accounts") {
                return this.connector.sendCustomRequest({
                  id: 1337,
                  jsonrpc: "2.0",
                  method,
                  params
                });
              }
              const chainId = await this.request({ method: "eth_chainId" });
              if (!this.providers[chainId]) {
                const currentChain = chains2.find(({ id }) => id === chainId);
                if (!currentChain) {
                  throw new ProviderRpcError({
                    code: ProviderRpcErrorCode.CHAIN_NOT_ADDED,
                    message: `The Provider does not have a rpcUrl to make a request for the requested method: ${method}`
                  });
                }
                this.providers[chainId] = new StaticJsonRpcProvider(currentChain.rpcUrl);
              }
              return this.providers[chainId].send(
                method,
                // @ts-ignore
                params
              );
            };
          }
        }
        return {
          provider: new EthProvider({ chains, connector })
        };
      }
    };
  };
}
var v1_default = ledger;

// node_modules/@web3-onboard/ledger/dist/v2.js
var defaultOptionalMethods = [
  "eth_sendTransaction",
  "eth_signTransaction",
  "personal_sign",
  "eth_sign",
  "eth_signTypedData",
  "eth_signTypedData_v4"
];
function ledger2(options) {
  if (!(options === null || options === void 0 ? void 0 : options.projectId)) {
    throw new Error("WalletConnect requires a projectId. Please visit https://cloud.walletconnect.com to get one.");
  }
  return () => {
    return {
      label: "Ledger",
      getIcon: async () => (await import("./icon-LNV7LDDF.js")).default,
      getInterface: async ({ chains, EventEmitter }) => {
        var _a;
        const { loadConnectKit, SupportedProviders, SupportedProviderImplementations } = await import("./esm-HHMJ5BZW.js");
        const connectKit = await loadConnectKit();
        if (options === null || options === void 0 ? void 0 : options.enableDebugLogs) {
          connectKit.enableDebugLogs();
        }
        const requiredChains = (_a = options === null || options === void 0 ? void 0 : options.requiredChains) === null || _a === void 0 ? void 0 : _a.map((id) => typeof id === "string" && isHexString(id) ? parseInt(id, 16) : id);
        const optionalMethods = options.optionalMethods && Array.isArray(options.optionalMethods) ? [...options.optionalMethods, ...defaultOptionalMethods] : defaultOptionalMethods;
        const checkSupportResult = connectKit.checkSupport({
          providerType: SupportedProviders.Ethereum,
          walletConnectVersion: 2,
          projectId: options === null || options === void 0 ? void 0 : options.projectId,
          chains: requiredChains,
          optionalChains: chains.map(({ id }) => parseInt(id, 16)),
          methods: options === null || options === void 0 ? void 0 : options.requiredMethods,
          optionalMethods,
          events: options === null || options === void 0 ? void 0 : options.requiredEvents,
          optionalEvents: options === null || options === void 0 ? void 0 : options.optionalEvents,
          rpcMap: chains.map(({ id, rpcUrl }) => ({ id, rpcUrl })).reduce((rpcMap, { id, rpcUrl }) => {
            rpcMap[parseInt(id, 16)] = rpcUrl || "";
            return rpcMap;
          }, {})
        });
        const instance = await connectKit.getProvider();
        if (checkSupportResult.providerImplementation === SupportedProviderImplementations.LedgerConnect) {
          return {
            provider: instance
          };
        }
        const { ProviderRpcError, ProviderRpcErrorCode } = await import("./dist-B6GI6SQT.js");
        const { default: EthereumProvider } = await import("./index.es-Y3O4YMJ5.js");
        const { Subject, fromEvent } = await import("./esm5-GKP2IZLS.js");
        const { takeUntil, take } = await import("./operators-HZEBPPU3.js");
        const connector = instance;
        const emitter = new EventEmitter();
        class EthProvider {
          constructor({ connector: connector2, chains: chains2 }) {
            this.emit = emitter.emit.bind(emitter);
            this.on = emitter.on.bind(emitter);
            this.removeListener = emitter.removeListener.bind(emitter);
            this.connector = connector2;
            this.chains = chains2;
            this.disconnected$ = new Subject();
            fromEvent(this.connector, "accountsChanged", (payload) => payload).pipe(takeUntil(this.disconnected$)).subscribe({
              next: (accounts) => {
                this.emit("accountsChanged", accounts);
              },
              error: console.warn
            });
            fromEvent(this.connector, "chainChanged", (payload) => payload).pipe(takeUntil(this.disconnected$)).subscribe({
              next: (chainId) => {
                const hexChainId = isHexString(chainId) ? chainId : `0x${chainId.toString(16)}`;
                this.emit("chainChanged", hexChainId);
              },
              error: console.warn
            });
            fromEvent(this.connector, "session_delete", (payload) => payload).pipe(takeUntil(this.disconnected$)).subscribe({
              next: () => {
                this.emit("accountsChanged", []);
                this.disconnected$.next(true);
                typeof localStorage !== "undefined" && localStorage.removeItem("walletconnect");
              },
              error: console.warn
            });
            this.disconnect = () => {
              if (this.connector.session)
                this.connector.disconnect();
            };
            const checkForSession = () => {
              const session = this.connector.session;
              if (session) {
                this.emit("accountsChanged", this.connector.accounts);
                this.emit("chainChanged", this.connector.chainId);
              }
            };
            checkForSession();
            this.request = async ({ method, params }) => {
              if (method === "eth_chainId") {
                return isHexString(this.connector.chainId) ? this.connector.chainId : `0x${this.connector.chainId.toString(16)}`;
              }
              if (method === "eth_requestAccounts") {
                return new Promise(async (resolve, reject) => {
                  fromEvent(this.connector, "connect", (payload) => payload).pipe(take(1)).subscribe({
                    next: ({ chainId }) => {
                      this.emit("accountsChanged", this.connector.accounts);
                      const hexChainId = isHexString(chainId) ? chainId : `0x${chainId.toString(16)}`;
                      this.emit("chainChanged", hexChainId);
                      resolve(this.connector.accounts);
                    },
                    error: reject
                  });
                  if (!this.connector.session) {
                    await instance.request({ method }).catch((err) => {
                      console.error("err creating new session: ", err);
                      reject(new ProviderRpcError({
                        code: 4001,
                        message: "User rejected the request."
                      }));
                    });
                  } else {
                    const accounts = this.connector.accounts;
                    const chainId = this.connector.chainId;
                    const hexChainId = `0x${chainId.toString(16)}`;
                    this.emit("chainChanged", hexChainId);
                    return resolve(accounts);
                  }
                });
              }
              if (method === "eth_selectAccounts") {
                throw new ProviderRpcError({
                  code: ProviderRpcErrorCode.UNSUPPORTED_METHOD,
                  message: `The Provider does not support the requested method: ${method}`
                });
              }
              if (method == "wallet_switchEthereumChain") {
                if (!params) {
                  throw new ProviderRpcError({
                    code: ProviderRpcErrorCode.INVALID_PARAMS,
                    message: `The Provider requires a chainId to be passed in as an argument`
                  });
                }
                const chainIdObj = params[0];
                if (!chainIdObj.hasOwnProperty("chainId") || typeof chainIdObj["chainId"] === "undefined") {
                  throw new ProviderRpcError({
                    code: ProviderRpcErrorCode.INVALID_PARAMS,
                    message: `The Provider requires a chainId to be passed in as an argument`
                  });
                }
                return this.connector.request({
                  method: "wallet_switchEthereumChain",
                  params: [
                    {
                      chainId: chainIdObj.chainId
                    }
                  ]
                });
              }
              return this.connector.request({
                method,
                params
              });
            };
          }
        }
        return {
          provider: new EthProvider({ chains, connector })
        };
      }
    };
  };
}
var v2_default = ledger2;

// node_modules/@web3-onboard/ledger/dist/index.js
var isHexString = (value) => {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  return true;
};
function ledger3(options) {
  const walletConnectVersion = (options === null || options === void 0 ? void 0 : options.walletConnectVersion) || 2;
  return walletConnectVersion === 1 ? v1_default(options) : v2_default(options);
}
var dist_default = ledger3;
export {
  dist_default as default,
  isHexString
};
//# sourceMappingURL=@web3-onboard_ledger.js.map
