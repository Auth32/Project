import {
  createEIP1193Provider
} from "./chunk-FSVYEHLU.js";
import "./chunk-2E63JINA.js";

// node_modules/@cedelabs/providers/dist/providers.mjs
var Xi = Object.defineProperty;
var Ki = (e2, t, n) => t in e2 ? Xi(e2, t, { enumerable: true, configurable: true, writable: true, value: n }) : e2[t] = n;
var ye = (e2, t, n) => (Ki(e2, typeof t != "symbol" ? t + "" : t, n), n);
var Yi = ((e2) => (e2[e2.V1 = 1] = "V1", e2[e2.V2 = 2] = "V2", e2[e2.V3 = 3] = "V3", e2))(Yi || {});
var Zi = {
  connect: 2,
  disconnect: 1,
  vaults: 1,
  vaultAccounts: 1,
  supportedExchanges: 1,
  getWithdrawalById: 2,
  transactions: 2,
  balances: 3,
  nfts: 2,
  openOrders: 2,
  retrieveOrder: 2,
  editOrder: 2,
  getMinAmounts: 2,
  createOrder: 2,
  prepareOrder: 2,
  getMarketPairs: 2,
  getMarketRate: 2,
  tickers: 1,
  tokens: 1,
  activeVault: 1,
  depositableTokens: 2,
  getNetworks: 2,
  deposit: 2,
  cancelOrder: 2,
  addCex: 2,
  withdrawToDefi: 2,
  withdrawableTokens: 2,
  getPrices: 1,
  prepareWithdrawal: 2,
  getSettings: 1,
  getAddressBook: 1,
  checkAddressIsWhitelisted: 1
  /* V1 */
};
var en = class {
  constructor(t) {
    ye(this, "inpageProvider");
    ye(this, "request", async (t2) => {
      const s = Zi[t2.method] ?? -1, u = t2;
      return u.params ? u.params = { ...u.params, version: s } : u.params = { version: s }, this.inpageProvider.request(u);
    });
    ye(this, "on", (t2, n) => (this.inpageProvider.on(t2, n), this));
    ye(this, "once", (t2, n) => (this.inpageProvider.on(t2, n), this));
    ye(this, "off", (t2, n) => (this.inpageProvider.off(t2, n), this));
    ye(this, "removeListener", (t2, n) => (this.inpageProvider.removeListener(t2, n), this));
    ye(this, "removeAllListeners", (t2) => (this.inpageProvider.removeAllListeners(t2), this));
    ye(this, "emit", (t2, ...n) => this.inpageProvider.emit(t2, ...n));
    ye(this, "getVaultPreviews", () => this.inpageProvider.getVaultPreviews());
    ye(this, "getIsUnlocked", () => this.inpageProvider.getIsUnlocked());
    ye(this, "getActiveVault", () => this.inpageProvider.getActiveVault());
    this.inpageProvider = t;
  }
};
function wu(e2 = 3e3) {
  let t = false;
  return new Promise((n) => {
    window.cede ? s() : (window.addEventListener("cede#initialized", s, {
      once: true
    }), setTimeout(() => {
      s();
    }, e2));
    function s() {
      if (t) {
        const d = window.cede, l = new en(d);
        n(l);
        return;
      }
      t = true, window.removeEventListener("cede#initialized", s);
      const { cede: u } = window;
      if (u) {
        const d = window.cede, l = new en(d);
        n(l);
      } else
        n(null);
    }
  });
}
function Qi(e2) {
  return JSON.parse(JSON.stringify(e2));
}
var te = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Tn(e2) {
  return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
}
var Ut = {};
var Sr = { exports: {} };
var J = {};
var ct = {};
var Dt = {};
Dt.byteLength = ro;
Dt.toByteArray = io;
Dt.fromByteArray = so;
var ke = [];
var Me = [];
var eo = typeof Uint8Array < "u" ? Uint8Array : Array;
var er = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (Ze = 0, to = er.length; Ze < to; ++Ze)
  ke[Ze] = er[Ze], Me[er.charCodeAt(Ze)] = Ze;
var Ze;
var to;
Me["-".charCodeAt(0)] = 62;
Me["_".charCodeAt(0)] = 63;
function Mn(e2) {
  var t = e2.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n = e2.indexOf("=");
  n === -1 && (n = t);
  var s = n === t ? 0 : 4 - n % 4;
  return [n, s];
}
function ro(e2) {
  var t = Mn(e2), n = t[0], s = t[1];
  return (n + s) * 3 / 4 - s;
}
function no(e2, t, n) {
  return (t + n) * 3 / 4 - n;
}
function io(e2) {
  var t, n = Mn(e2), s = n[0], u = n[1], d = new eo(no(e2, s, u)), l = 0, f = u > 0 ? s - 4 : s, g;
  for (g = 0; g < f; g += 4)
    t = Me[e2.charCodeAt(g)] << 18 | Me[e2.charCodeAt(g + 1)] << 12 | Me[e2.charCodeAt(g + 2)] << 6 | Me[e2.charCodeAt(g + 3)], d[l++] = t >> 16 & 255, d[l++] = t >> 8 & 255, d[l++] = t & 255;
  return u === 2 && (t = Me[e2.charCodeAt(g)] << 2 | Me[e2.charCodeAt(g + 1)] >> 4, d[l++] = t & 255), u === 1 && (t = Me[e2.charCodeAt(g)] << 10 | Me[e2.charCodeAt(g + 1)] << 4 | Me[e2.charCodeAt(g + 2)] >> 2, d[l++] = t >> 8 & 255, d[l++] = t & 255), d;
}
function oo(e2) {
  return ke[e2 >> 18 & 63] + ke[e2 >> 12 & 63] + ke[e2 >> 6 & 63] + ke[e2 & 63];
}
function ao(e2, t, n) {
  for (var s, u = [], d = t; d < n; d += 3)
    s = (e2[d] << 16 & 16711680) + (e2[d + 1] << 8 & 65280) + (e2[d + 2] & 255), u.push(oo(s));
  return u.join("");
}
function so(e2) {
  for (var t, n = e2.length, s = n % 3, u = [], d = 16383, l = 0, f = n - s; l < f; l += d)
    u.push(ao(e2, l, l + d > f ? f : l + d));
  return s === 1 ? (t = e2[n - 1], u.push(
    ke[t >> 2] + ke[t << 4 & 63] + "=="
  )) : s === 2 && (t = (e2[n - 2] << 8) + e2[n - 1], u.push(
    ke[t >> 10] + ke[t >> 4 & 63] + ke[t << 2 & 63] + "="
  )), u.join("");
}
var Ur = {};
Ur.read = function(e2, t, n, s, u) {
  var d, l, f = u * 8 - s - 1, g = (1 << f) - 1, T = g >> 1, F = -7, E = n ? u - 1 : 0, j = n ? -1 : 1, U = e2[t + E];
  for (E += j, d = U & (1 << -F) - 1, U >>= -F, F += f; F > 0; d = d * 256 + e2[t + E], E += j, F -= 8)
    ;
  for (l = d & (1 << -F) - 1, d >>= -F, F += s; F > 0; l = l * 256 + e2[t + E], E += j, F -= 8)
    ;
  if (d === 0)
    d = 1 - T;
  else {
    if (d === g)
      return l ? NaN : (U ? -1 : 1) * (1 / 0);
    l = l + Math.pow(2, s), d = d - T;
  }
  return (U ? -1 : 1) * l * Math.pow(2, d - s);
};
Ur.write = function(e2, t, n, s, u, d) {
  var l, f, g, T = d * 8 - u - 1, F = (1 << T) - 1, E = F >> 1, j = u === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, U = s ? 0 : d - 1, q = s ? 1 : -1, N = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (f = isNaN(t) ? 1 : 0, l = F) : (l = Math.floor(Math.log(t) / Math.LN2), t * (g = Math.pow(2, -l)) < 1 && (l--, g *= 2), l + E >= 1 ? t += j / g : t += j * Math.pow(2, 1 - E), t * g >= 2 && (l++, g /= 2), l + E >= F ? (f = 0, l = F) : l + E >= 1 ? (f = (t * g - 1) * Math.pow(2, u), l = l + E) : (f = t * Math.pow(2, E - 1) * Math.pow(2, u), l = 0)); u >= 8; e2[n + U] = f & 255, U += q, f /= 256, u -= 8)
    ;
  for (l = l << u | f, T += u; T > 0; e2[n + U] = l & 255, U += q, l /= 256, T -= 8)
    ;
  e2[n + U - q] |= N * 128;
};
(function(e2) {
  const t = Dt, n = Ur, s = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e2.Buffer = f, e2.SlowBuffer = R, e2.INSPECT_MAX_BYTES = 50;
  const u = 2147483647;
  e2.kMaxLength = u, f.TYPED_ARRAY_SUPPORT = d(), !f.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function d() {
    try {
      const c = new Uint8Array(1), r = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(c, r), c.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(f.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (f.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(f.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (f.isBuffer(this))
        return this.byteOffset;
    }
  });
  function l(c) {
    if (c > u)
      throw new RangeError('The value "' + c + '" is invalid for option "size"');
    const r = new Uint8Array(c);
    return Object.setPrototypeOf(r, f.prototype), r;
  }
  function f(c, r, i) {
    if (typeof c == "number") {
      if (typeof r == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return E(c);
    }
    return g(c, r, i);
  }
  f.poolSize = 8192;
  function g(c, r, i) {
    if (typeof c == "string")
      return j(c, r);
    if (ArrayBuffer.isView(c))
      return q(c);
    if (c == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof c
      );
    if (pe(c, ArrayBuffer) || c && pe(c.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (pe(c, SharedArrayBuffer) || c && pe(c.buffer, SharedArrayBuffer)))
      return N(c, r, i);
    if (typeof c == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const p = c.valueOf && c.valueOf();
    if (p != null && p !== c)
      return f.from(p, r, i);
    const v = Q(c);
    if (v)
      return v;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof c[Symbol.toPrimitive] == "function")
      return f.from(c[Symbol.toPrimitive]("string"), r, i);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof c
    );
  }
  f.from = function(c, r, i) {
    return g(c, r, i);
  }, Object.setPrototypeOf(f.prototype, Uint8Array.prototype), Object.setPrototypeOf(f, Uint8Array);
  function T(c) {
    if (typeof c != "number")
      throw new TypeError('"size" argument must be of type number');
    if (c < 0)
      throw new RangeError('The value "' + c + '" is invalid for option "size"');
  }
  function F(c, r, i) {
    return T(c), c <= 0 ? l(c) : r !== void 0 ? typeof i == "string" ? l(c).fill(r, i) : l(c).fill(r) : l(c);
  }
  f.alloc = function(c, r, i) {
    return F(c, r, i);
  };
  function E(c) {
    return T(c), l(c < 0 ? 0 : x(c) | 0);
  }
  f.allocUnsafe = function(c) {
    return E(c);
  }, f.allocUnsafeSlow = function(c) {
    return E(c);
  };
  function j(c, r) {
    if ((typeof r != "string" || r === "") && (r = "utf8"), !f.isEncoding(r))
      throw new TypeError("Unknown encoding: " + r);
    const i = L(c, r) | 0;
    let p = l(i);
    const v = p.write(c, r);
    return v !== i && (p = p.slice(0, v)), p;
  }
  function U(c) {
    const r = c.length < 0 ? 0 : x(c.length) | 0, i = l(r);
    for (let p = 0; p < r; p += 1)
      i[p] = c[p] & 255;
    return i;
  }
  function q(c) {
    if (pe(c, Uint8Array)) {
      const r = new Uint8Array(c);
      return N(r.buffer, r.byteOffset, r.byteLength);
    }
    return U(c);
  }
  function N(c, r, i) {
    if (r < 0 || c.byteLength < r)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (c.byteLength < r + (i || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let p;
    return r === void 0 && i === void 0 ? p = new Uint8Array(c) : i === void 0 ? p = new Uint8Array(c, r) : p = new Uint8Array(c, r, i), Object.setPrototypeOf(p, f.prototype), p;
  }
  function Q(c) {
    if (f.isBuffer(c)) {
      const r = x(c.length) | 0, i = l(r);
      return i.length === 0 || c.copy(i, 0, 0, r), i;
    }
    if (c.length !== void 0)
      return typeof c.length != "number" || be(c.length) ? l(0) : U(c);
    if (c.type === "Buffer" && Array.isArray(c.data))
      return U(c.data);
  }
  function x(c) {
    if (c >= u)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + u.toString(16) + " bytes");
    return c | 0;
  }
  function R(c) {
    return +c != c && (c = 0), f.alloc(+c);
  }
  f.isBuffer = function(r) {
    return r != null && r._isBuffer === true && r !== f.prototype;
  }, f.compare = function(r, i) {
    if (pe(r, Uint8Array) && (r = f.from(r, r.offset, r.byteLength)), pe(i, Uint8Array) && (i = f.from(i, i.offset, i.byteLength)), !f.isBuffer(r) || !f.isBuffer(i))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (r === i)
      return 0;
    let p = r.length, v = i.length;
    for (let S = 0, M = Math.min(p, v); S < M; ++S)
      if (r[S] !== i[S]) {
        p = r[S], v = i[S];
        break;
      }
    return p < v ? -1 : v < p ? 1 : 0;
  }, f.isEncoding = function(r) {
    switch (String(r).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, f.concat = function(r, i) {
    if (!Array.isArray(r))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (r.length === 0)
      return f.alloc(0);
    let p;
    if (i === void 0)
      for (i = 0, p = 0; p < r.length; ++p)
        i += r[p].length;
    const v = f.allocUnsafe(i);
    let S = 0;
    for (p = 0; p < r.length; ++p) {
      let M = r[p];
      if (pe(M, Uint8Array))
        S + M.length > v.length ? (f.isBuffer(M) || (M = f.from(M)), M.copy(v, S)) : Uint8Array.prototype.set.call(
          v,
          M,
          S
        );
      else if (f.isBuffer(M))
        M.copy(v, S);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      S += M.length;
    }
    return v;
  };
  function L(c, r) {
    if (f.isBuffer(c))
      return c.length;
    if (ArrayBuffer.isView(c) || pe(c, ArrayBuffer))
      return c.byteLength;
    if (typeof c != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof c
      );
    const i = c.length, p = arguments.length > 2 && arguments[2] === true;
    if (!p && i === 0)
      return 0;
    let v = false;
    for (; ; )
      switch (r) {
        case "ascii":
        case "latin1":
        case "binary":
          return i;
        case "utf8":
        case "utf-8":
          return Ne(c).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return i * 2;
        case "hex":
          return i >>> 1;
        case "base64":
          return xe(c).length;
        default:
          if (v)
            return p ? -1 : Ne(c).length;
          r = ("" + r).toLowerCase(), v = true;
      }
  }
  f.byteLength = L;
  function z(c, r, i) {
    let p = false;
    if ((r === void 0 || r < 0) && (r = 0), r > this.length || ((i === void 0 || i > this.length) && (i = this.length), i <= 0) || (i >>>= 0, r >>>= 0, i <= r))
      return "";
    for (c || (c = "utf8"); ; )
      switch (c) {
        case "hex":
          return b(this, r, i);
        case "utf8":
        case "utf-8":
          return K(this, r, i);
        case "ascii":
          return h(this, r, i);
        case "latin1":
        case "binary":
          return y(this, r, i);
        case "base64":
          return ve(this, r, i);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return P(this, r, i);
        default:
          if (p)
            throw new TypeError("Unknown encoding: " + c);
          c = (c + "").toLowerCase(), p = true;
      }
  }
  f.prototype._isBuffer = true;
  function V(c, r, i) {
    const p = c[r];
    c[r] = c[i], c[i] = p;
  }
  f.prototype.swap16 = function() {
    const r = this.length;
    if (r % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let i = 0; i < r; i += 2)
      V(this, i, i + 1);
    return this;
  }, f.prototype.swap32 = function() {
    const r = this.length;
    if (r % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let i = 0; i < r; i += 4)
      V(this, i, i + 3), V(this, i + 1, i + 2);
    return this;
  }, f.prototype.swap64 = function() {
    const r = this.length;
    if (r % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let i = 0; i < r; i += 8)
      V(this, i, i + 7), V(this, i + 1, i + 6), V(this, i + 2, i + 5), V(this, i + 3, i + 4);
    return this;
  }, f.prototype.toString = function() {
    const r = this.length;
    return r === 0 ? "" : arguments.length === 0 ? K(this, 0, r) : z.apply(this, arguments);
  }, f.prototype.toLocaleString = f.prototype.toString, f.prototype.equals = function(r) {
    if (!f.isBuffer(r))
      throw new TypeError("Argument must be a Buffer");
    return this === r ? true : f.compare(this, r) === 0;
  }, f.prototype.inspect = function() {
    let r = "";
    const i = e2.INSPECT_MAX_BYTES;
    return r = this.toString("hex", 0, i).replace(/(.{2})/g, "$1 ").trim(), this.length > i && (r += " ... "), "<Buffer " + r + ">";
  }, s && (f.prototype[s] = f.prototype.inspect), f.prototype.compare = function(r, i, p, v, S) {
    if (pe(r, Uint8Array) && (r = f.from(r, r.offset, r.byteLength)), !f.isBuffer(r))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r
      );
    if (i === void 0 && (i = 0), p === void 0 && (p = r ? r.length : 0), v === void 0 && (v = 0), S === void 0 && (S = this.length), i < 0 || p > r.length || v < 0 || S > this.length)
      throw new RangeError("out of range index");
    if (v >= S && i >= p)
      return 0;
    if (v >= S)
      return -1;
    if (i >= p)
      return 1;
    if (i >>>= 0, p >>>= 0, v >>>= 0, S >>>= 0, this === r)
      return 0;
    let M = S - v, H = p - i;
    const ae = Math.min(M, H), ne = this.slice(v, S), se = r.slice(i, p);
    for (let Y = 0; Y < ae; ++Y)
      if (ne[Y] !== se[Y]) {
        M = ne[Y], H = se[Y];
        break;
      }
    return M < H ? -1 : H < M ? 1 : 0;
  };
  function Ee(c, r, i, p, v) {
    if (c.length === 0)
      return -1;
    if (typeof i == "string" ? (p = i, i = 0) : i > 2147483647 ? i = 2147483647 : i < -2147483648 && (i = -2147483648), i = +i, be(i) && (i = v ? 0 : c.length - 1), i < 0 && (i = c.length + i), i >= c.length) {
      if (v)
        return -1;
      i = c.length - 1;
    } else if (i < 0)
      if (v)
        i = 0;
      else
        return -1;
    if (typeof r == "string" && (r = f.from(r, p)), f.isBuffer(r))
      return r.length === 0 ? -1 : ie(c, r, i, p, v);
    if (typeof r == "number")
      return r = r & 255, typeof Uint8Array.prototype.indexOf == "function" ? v ? Uint8Array.prototype.indexOf.call(c, r, i) : Uint8Array.prototype.lastIndexOf.call(c, r, i) : ie(c, [r], i, p, v);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ie(c, r, i, p, v) {
    let S = 1, M = c.length, H = r.length;
    if (p !== void 0 && (p = String(p).toLowerCase(), p === "ucs2" || p === "ucs-2" || p === "utf16le" || p === "utf-16le")) {
      if (c.length < 2 || r.length < 2)
        return -1;
      S = 2, M /= 2, H /= 2, i /= 2;
    }
    function ae(se, Y) {
      return S === 1 ? se[Y] : se.readUInt16BE(Y * S);
    }
    let ne;
    if (v) {
      let se = -1;
      for (ne = i; ne < M; ne++)
        if (ae(c, ne) === ae(r, se === -1 ? 0 : ne - se)) {
          if (se === -1 && (se = ne), ne - se + 1 === H)
            return se * S;
        } else
          se !== -1 && (ne -= ne - se), se = -1;
    } else
      for (i + H > M && (i = M - H), ne = i; ne >= 0; ne--) {
        let se = true;
        for (let Y = 0; Y < H; Y++)
          if (ae(c, ne + Y) !== ae(r, Y)) {
            se = false;
            break;
          }
        if (se)
          return ne;
      }
    return -1;
  }
  f.prototype.includes = function(r, i, p) {
    return this.indexOf(r, i, p) !== -1;
  }, f.prototype.indexOf = function(r, i, p) {
    return Ee(this, r, i, p, true);
  }, f.prototype.lastIndexOf = function(r, i, p) {
    return Ee(this, r, i, p, false);
  };
  function de(c, r, i, p) {
    i = Number(i) || 0;
    const v = c.length - i;
    p ? (p = Number(p), p > v && (p = v)) : p = v;
    const S = r.length;
    p > S / 2 && (p = S / 2);
    let M;
    for (M = 0; M < p; ++M) {
      const H = parseInt(r.substr(M * 2, 2), 16);
      if (be(H))
        return M;
      c[i + M] = H;
    }
    return M;
  }
  function ce(c, r, i, p) {
    return Ae(Ne(r, c.length - i), c, i, p);
  }
  function he(c, r, i, p) {
    return Ae(Be(r), c, i, p);
  }
  function ee(c, r, i, p) {
    return Ae(xe(r), c, i, p);
  }
  function ue(c, r, i, p) {
    return Ae(O(r, c.length - i), c, i, p);
  }
  f.prototype.write = function(r, i, p, v) {
    if (i === void 0)
      v = "utf8", p = this.length, i = 0;
    else if (p === void 0 && typeof i == "string")
      v = i, p = this.length, i = 0;
    else if (isFinite(i))
      i = i >>> 0, isFinite(p) ? (p = p >>> 0, v === void 0 && (v = "utf8")) : (v = p, p = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const S = this.length - i;
    if ((p === void 0 || p > S) && (p = S), r.length > 0 && (p < 0 || i < 0) || i > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    v || (v = "utf8");
    let M = false;
    for (; ; )
      switch (v) {
        case "hex":
          return de(this, r, i, p);
        case "utf8":
        case "utf-8":
          return ce(this, r, i, p);
        case "ascii":
        case "latin1":
        case "binary":
          return he(this, r, i, p);
        case "base64":
          return ee(this, r, i, p);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ue(this, r, i, p);
        default:
          if (M)
            throw new TypeError("Unknown encoding: " + v);
          v = ("" + v).toLowerCase(), M = true;
      }
  }, f.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function ve(c, r, i) {
    return r === 0 && i === c.length ? t.fromByteArray(c) : t.fromByteArray(c.slice(r, i));
  }
  function K(c, r, i) {
    i = Math.min(c.length, i);
    const p = [];
    let v = r;
    for (; v < i; ) {
      const S = c[v];
      let M = null, H = S > 239 ? 4 : S > 223 ? 3 : S > 191 ? 2 : 1;
      if (v + H <= i) {
        let ae, ne, se, Y;
        switch (H) {
          case 1:
            S < 128 && (M = S);
            break;
          case 2:
            ae = c[v + 1], (ae & 192) === 128 && (Y = (S & 31) << 6 | ae & 63, Y > 127 && (M = Y));
            break;
          case 3:
            ae = c[v + 1], ne = c[v + 2], (ae & 192) === 128 && (ne & 192) === 128 && (Y = (S & 15) << 12 | (ae & 63) << 6 | ne & 63, Y > 2047 && (Y < 55296 || Y > 57343) && (M = Y));
            break;
          case 4:
            ae = c[v + 1], ne = c[v + 2], se = c[v + 3], (ae & 192) === 128 && (ne & 192) === 128 && (se & 192) === 128 && (Y = (S & 15) << 18 | (ae & 63) << 12 | (ne & 63) << 6 | se & 63, Y > 65535 && Y < 1114112 && (M = Y));
        }
      }
      M === null ? (M = 65533, H = 1) : M > 65535 && (M -= 65536, p.push(M >>> 10 & 1023 | 55296), M = 56320 | M & 1023), p.push(M), v += H;
    }
    return me(p);
  }
  const ge = 4096;
  function me(c) {
    const r = c.length;
    if (r <= ge)
      return String.fromCharCode.apply(String, c);
    let i = "", p = 0;
    for (; p < r; )
      i += String.fromCharCode.apply(
        String,
        c.slice(p, p += ge)
      );
    return i;
  }
  function h(c, r, i) {
    let p = "";
    i = Math.min(c.length, i);
    for (let v = r; v < i; ++v)
      p += String.fromCharCode(c[v] & 127);
    return p;
  }
  function y(c, r, i) {
    let p = "";
    i = Math.min(c.length, i);
    for (let v = r; v < i; ++v)
      p += String.fromCharCode(c[v]);
    return p;
  }
  function b(c, r, i) {
    const p = c.length;
    (!r || r < 0) && (r = 0), (!i || i < 0 || i > p) && (i = p);
    let v = "";
    for (let S = r; S < i; ++S)
      v += _e[c[S]];
    return v;
  }
  function P(c, r, i) {
    const p = c.slice(r, i);
    let v = "";
    for (let S = 0; S < p.length - 1; S += 2)
      v += String.fromCharCode(p[S] + p[S + 1] * 256);
    return v;
  }
  f.prototype.slice = function(r, i) {
    const p = this.length;
    r = ~~r, i = i === void 0 ? p : ~~i, r < 0 ? (r += p, r < 0 && (r = 0)) : r > p && (r = p), i < 0 ? (i += p, i < 0 && (i = 0)) : i > p && (i = p), i < r && (i = r);
    const v = this.subarray(r, i);
    return Object.setPrototypeOf(v, f.prototype), v;
  };
  function I(c, r, i) {
    if (c % 1 !== 0 || c < 0)
      throw new RangeError("offset is not uint");
    if (c + r > i)
      throw new RangeError("Trying to access beyond buffer length");
  }
  f.prototype.readUintLE = f.prototype.readUIntLE = function(r, i, p) {
    r = r >>> 0, i = i >>> 0, p || I(r, i, this.length);
    let v = this[r], S = 1, M = 0;
    for (; ++M < i && (S *= 256); )
      v += this[r + M] * S;
    return v;
  }, f.prototype.readUintBE = f.prototype.readUIntBE = function(r, i, p) {
    r = r >>> 0, i = i >>> 0, p || I(r, i, this.length);
    let v = this[r + --i], S = 1;
    for (; i > 0 && (S *= 256); )
      v += this[r + --i] * S;
    return v;
  }, f.prototype.readUint8 = f.prototype.readUInt8 = function(r, i) {
    return r = r >>> 0, i || I(r, 1, this.length), this[r];
  }, f.prototype.readUint16LE = f.prototype.readUInt16LE = function(r, i) {
    return r = r >>> 0, i || I(r, 2, this.length), this[r] | this[r + 1] << 8;
  }, f.prototype.readUint16BE = f.prototype.readUInt16BE = function(r, i) {
    return r = r >>> 0, i || I(r, 2, this.length), this[r] << 8 | this[r + 1];
  }, f.prototype.readUint32LE = f.prototype.readUInt32LE = function(r, i) {
    return r = r >>> 0, i || I(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216;
  }, f.prototype.readUint32BE = f.prototype.readUInt32BE = function(r, i) {
    return r = r >>> 0, i || I(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
  }, f.prototype.readBigUInt64LE = le(function(r) {
    r = r >>> 0, k(r, "offset");
    const i = this[r], p = this[r + 7];
    (i === void 0 || p === void 0) && oe(r, this.length - 8);
    const v = i + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24, S = this[++r] + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + p * 2 ** 24;
    return BigInt(v) + (BigInt(S) << BigInt(32));
  }), f.prototype.readBigUInt64BE = le(function(r) {
    r = r >>> 0, k(r, "offset");
    const i = this[r], p = this[r + 7];
    (i === void 0 || p === void 0) && oe(r, this.length - 8);
    const v = i * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r], S = this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + p;
    return (BigInt(v) << BigInt(32)) + BigInt(S);
  }), f.prototype.readIntLE = function(r, i, p) {
    r = r >>> 0, i = i >>> 0, p || I(r, i, this.length);
    let v = this[r], S = 1, M = 0;
    for (; ++M < i && (S *= 256); )
      v += this[r + M] * S;
    return S *= 128, v >= S && (v -= Math.pow(2, 8 * i)), v;
  }, f.prototype.readIntBE = function(r, i, p) {
    r = r >>> 0, i = i >>> 0, p || I(r, i, this.length);
    let v = i, S = 1, M = this[r + --v];
    for (; v > 0 && (S *= 256); )
      M += this[r + --v] * S;
    return S *= 128, M >= S && (M -= Math.pow(2, 8 * i)), M;
  }, f.prototype.readInt8 = function(r, i) {
    return r = r >>> 0, i || I(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r];
  }, f.prototype.readInt16LE = function(r, i) {
    r = r >>> 0, i || I(r, 2, this.length);
    const p = this[r] | this[r + 1] << 8;
    return p & 32768 ? p | 4294901760 : p;
  }, f.prototype.readInt16BE = function(r, i) {
    r = r >>> 0, i || I(r, 2, this.length);
    const p = this[r + 1] | this[r] << 8;
    return p & 32768 ? p | 4294901760 : p;
  }, f.prototype.readInt32LE = function(r, i) {
    return r = r >>> 0, i || I(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
  }, f.prototype.readInt32BE = function(r, i) {
    return r = r >>> 0, i || I(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
  }, f.prototype.readBigInt64LE = le(function(r) {
    r = r >>> 0, k(r, "offset");
    const i = this[r], p = this[r + 7];
    (i === void 0 || p === void 0) && oe(r, this.length - 8);
    const v = this[r + 4] + this[r + 5] * 2 ** 8 + this[r + 6] * 2 ** 16 + (p << 24);
    return (BigInt(v) << BigInt(32)) + BigInt(i + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24);
  }), f.prototype.readBigInt64BE = le(function(r) {
    r = r >>> 0, k(r, "offset");
    const i = this[r], p = this[r + 7];
    (i === void 0 || p === void 0) && oe(r, this.length - 8);
    const v = (i << 24) + // Overflow
    this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r];
    return (BigInt(v) << BigInt(32)) + BigInt(this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + p);
  }), f.prototype.readFloatLE = function(r, i) {
    return r = r >>> 0, i || I(r, 4, this.length), n.read(this, r, true, 23, 4);
  }, f.prototype.readFloatBE = function(r, i) {
    return r = r >>> 0, i || I(r, 4, this.length), n.read(this, r, false, 23, 4);
  }, f.prototype.readDoubleLE = function(r, i) {
    return r = r >>> 0, i || I(r, 8, this.length), n.read(this, r, true, 52, 8);
  }, f.prototype.readDoubleBE = function(r, i) {
    return r = r >>> 0, i || I(r, 8, this.length), n.read(this, r, false, 52, 8);
  };
  function m(c, r, i, p, v, S) {
    if (!f.isBuffer(c))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (r > v || r < S)
      throw new RangeError('"value" argument is out of bounds');
    if (i + p > c.length)
      throw new RangeError("Index out of range");
  }
  f.prototype.writeUintLE = f.prototype.writeUIntLE = function(r, i, p, v) {
    if (r = +r, i = i >>> 0, p = p >>> 0, !v) {
      const H = Math.pow(2, 8 * p) - 1;
      m(this, r, i, p, H, 0);
    }
    let S = 1, M = 0;
    for (this[i] = r & 255; ++M < p && (S *= 256); )
      this[i + M] = r / S & 255;
    return i + p;
  }, f.prototype.writeUintBE = f.prototype.writeUIntBE = function(r, i, p, v) {
    if (r = +r, i = i >>> 0, p = p >>> 0, !v) {
      const H = Math.pow(2, 8 * p) - 1;
      m(this, r, i, p, H, 0);
    }
    let S = p - 1, M = 1;
    for (this[i + S] = r & 255; --S >= 0 && (M *= 256); )
      this[i + S] = r / M & 255;
    return i + p;
  }, f.prototype.writeUint8 = f.prototype.writeUInt8 = function(r, i, p) {
    return r = +r, i = i >>> 0, p || m(this, r, i, 1, 255, 0), this[i] = r & 255, i + 1;
  }, f.prototype.writeUint16LE = f.prototype.writeUInt16LE = function(r, i, p) {
    return r = +r, i = i >>> 0, p || m(this, r, i, 2, 65535, 0), this[i] = r & 255, this[i + 1] = r >>> 8, i + 2;
  }, f.prototype.writeUint16BE = f.prototype.writeUInt16BE = function(r, i, p) {
    return r = +r, i = i >>> 0, p || m(this, r, i, 2, 65535, 0), this[i] = r >>> 8, this[i + 1] = r & 255, i + 2;
  }, f.prototype.writeUint32LE = f.prototype.writeUInt32LE = function(r, i, p) {
    return r = +r, i = i >>> 0, p || m(this, r, i, 4, 4294967295, 0), this[i + 3] = r >>> 24, this[i + 2] = r >>> 16, this[i + 1] = r >>> 8, this[i] = r & 255, i + 4;
  }, f.prototype.writeUint32BE = f.prototype.writeUInt32BE = function(r, i, p) {
    return r = +r, i = i >>> 0, p || m(this, r, i, 4, 4294967295, 0), this[i] = r >>> 24, this[i + 1] = r >>> 16, this[i + 2] = r >>> 8, this[i + 3] = r & 255, i + 4;
  };
  function A(c, r, i, p, v) {
    C(r, p, v, c, i, 7);
    let S = Number(r & BigInt(4294967295));
    c[i++] = S, S = S >> 8, c[i++] = S, S = S >> 8, c[i++] = S, S = S >> 8, c[i++] = S;
    let M = Number(r >> BigInt(32) & BigInt(4294967295));
    return c[i++] = M, M = M >> 8, c[i++] = M, M = M >> 8, c[i++] = M, M = M >> 8, c[i++] = M, i;
  }
  function B(c, r, i, p, v) {
    C(r, p, v, c, i, 7);
    let S = Number(r & BigInt(4294967295));
    c[i + 7] = S, S = S >> 8, c[i + 6] = S, S = S >> 8, c[i + 5] = S, S = S >> 8, c[i + 4] = S;
    let M = Number(r >> BigInt(32) & BigInt(4294967295));
    return c[i + 3] = M, M = M >> 8, c[i + 2] = M, M = M >> 8, c[i + 1] = M, M = M >> 8, c[i] = M, i + 8;
  }
  f.prototype.writeBigUInt64LE = le(function(r, i = 0) {
    return A(this, r, i, BigInt(0), BigInt("0xffffffffffffffff"));
  }), f.prototype.writeBigUInt64BE = le(function(r, i = 0) {
    return B(this, r, i, BigInt(0), BigInt("0xffffffffffffffff"));
  }), f.prototype.writeIntLE = function(r, i, p, v) {
    if (r = +r, i = i >>> 0, !v) {
      const ae = Math.pow(2, 8 * p - 1);
      m(this, r, i, p, ae - 1, -ae);
    }
    let S = 0, M = 1, H = 0;
    for (this[i] = r & 255; ++S < p && (M *= 256); )
      r < 0 && H === 0 && this[i + S - 1] !== 0 && (H = 1), this[i + S] = (r / M >> 0) - H & 255;
    return i + p;
  }, f.prototype.writeIntBE = function(r, i, p, v) {
    if (r = +r, i = i >>> 0, !v) {
      const ae = Math.pow(2, 8 * p - 1);
      m(this, r, i, p, ae - 1, -ae);
    }
    let S = p - 1, M = 1, H = 0;
    for (this[i + S] = r & 255; --S >= 0 && (M *= 256); )
      r < 0 && H === 0 && this[i + S + 1] !== 0 && (H = 1), this[i + S] = (r / M >> 0) - H & 255;
    return i + p;
  }, f.prototype.writeInt8 = function(r, i, p) {
    return r = +r, i = i >>> 0, p || m(this, r, i, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[i] = r & 255, i + 1;
  }, f.prototype.writeInt16LE = function(r, i, p) {
    return r = +r, i = i >>> 0, p || m(this, r, i, 2, 32767, -32768), this[i] = r & 255, this[i + 1] = r >>> 8, i + 2;
  }, f.prototype.writeInt16BE = function(r, i, p) {
    return r = +r, i = i >>> 0, p || m(this, r, i, 2, 32767, -32768), this[i] = r >>> 8, this[i + 1] = r & 255, i + 2;
  }, f.prototype.writeInt32LE = function(r, i, p) {
    return r = +r, i = i >>> 0, p || m(this, r, i, 4, 2147483647, -2147483648), this[i] = r & 255, this[i + 1] = r >>> 8, this[i + 2] = r >>> 16, this[i + 3] = r >>> 24, i + 4;
  }, f.prototype.writeInt32BE = function(r, i, p) {
    return r = +r, i = i >>> 0, p || m(this, r, i, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[i] = r >>> 24, this[i + 1] = r >>> 16, this[i + 2] = r >>> 8, this[i + 3] = r & 255, i + 4;
  }, f.prototype.writeBigInt64LE = le(function(r, i = 0) {
    return A(this, r, i, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), f.prototype.writeBigInt64BE = le(function(r, i = 0) {
    return B(this, r, i, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function D(c, r, i, p, v, S) {
    if (i + p > c.length)
      throw new RangeError("Index out of range");
    if (i < 0)
      throw new RangeError("Index out of range");
  }
  function W(c, r, i, p, v) {
    return r = +r, i = i >>> 0, v || D(c, r, i, 4), n.write(c, r, i, p, 23, 4), i + 4;
  }
  f.prototype.writeFloatLE = function(r, i, p) {
    return W(this, r, i, true, p);
  }, f.prototype.writeFloatBE = function(r, i, p) {
    return W(this, r, i, false, p);
  };
  function o(c, r, i, p, v) {
    return r = +r, i = i >>> 0, v || D(c, r, i, 8), n.write(c, r, i, p, 52, 8), i + 8;
  }
  f.prototype.writeDoubleLE = function(r, i, p) {
    return o(this, r, i, true, p);
  }, f.prototype.writeDoubleBE = function(r, i, p) {
    return o(this, r, i, false, p);
  }, f.prototype.copy = function(r, i, p, v) {
    if (!f.isBuffer(r))
      throw new TypeError("argument should be a Buffer");
    if (p || (p = 0), !v && v !== 0 && (v = this.length), i >= r.length && (i = r.length), i || (i = 0), v > 0 && v < p && (v = p), v === p || r.length === 0 || this.length === 0)
      return 0;
    if (i < 0)
      throw new RangeError("targetStart out of bounds");
    if (p < 0 || p >= this.length)
      throw new RangeError("Index out of range");
    if (v < 0)
      throw new RangeError("sourceEnd out of bounds");
    v > this.length && (v = this.length), r.length - i < v - p && (v = r.length - i + p);
    const S = v - p;
    return this === r && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(i, p, v) : Uint8Array.prototype.set.call(
      r,
      this.subarray(p, v),
      i
    ), S;
  }, f.prototype.fill = function(r, i, p, v) {
    if (typeof r == "string") {
      if (typeof i == "string" ? (v = i, i = 0, p = this.length) : typeof p == "string" && (v = p, p = this.length), v !== void 0 && typeof v != "string")
        throw new TypeError("encoding must be a string");
      if (typeof v == "string" && !f.isEncoding(v))
        throw new TypeError("Unknown encoding: " + v);
      if (r.length === 1) {
        const M = r.charCodeAt(0);
        (v === "utf8" && M < 128 || v === "latin1") && (r = M);
      }
    } else
      typeof r == "number" ? r = r & 255 : typeof r == "boolean" && (r = Number(r));
    if (i < 0 || this.length < i || this.length < p)
      throw new RangeError("Out of range index");
    if (p <= i)
      return this;
    i = i >>> 0, p = p === void 0 ? this.length : p >>> 0, r || (r = 0);
    let S;
    if (typeof r == "number")
      for (S = i; S < p; ++S)
        this[S] = r;
    else {
      const M = f.isBuffer(r) ? r : f.from(r, v), H = M.length;
      if (H === 0)
        throw new TypeError('The value "' + r + '" is invalid for argument "value"');
      for (S = 0; S < p - i; ++S)
        this[S + i] = M[S % H];
    }
    return this;
  };
  const a = {};
  function w(c, r, i) {
    a[c] = class extends i {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: r.apply(this, arguments),
          writable: true,
          configurable: true
        }), this.name = `${this.name} [${c}]`, this.stack, delete this.name;
      }
      get code() {
        return c;
      }
      set code(v) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: v,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${c}]: ${this.message}`;
      }
    };
  }
  w(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(c) {
      return c ? `${c} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), w(
    "ERR_INVALID_ARG_TYPE",
    function(c, r) {
      return `The "${c}" argument must be of type number. Received type ${typeof r}`;
    },
    TypeError
  ), w(
    "ERR_OUT_OF_RANGE",
    function(c, r, i) {
      let p = `The value of "${c}" is out of range.`, v = i;
      return Number.isInteger(i) && Math.abs(i) > 2 ** 32 ? v = _(String(i)) : typeof i == "bigint" && (v = String(i), (i > BigInt(2) ** BigInt(32) || i < -(BigInt(2) ** BigInt(32))) && (v = _(v)), v += "n"), p += ` It must be ${r}. Received ${v}`, p;
    },
    RangeError
  );
  function _(c) {
    let r = "", i = c.length;
    const p = c[0] === "-" ? 1 : 0;
    for (; i >= p + 4; i -= 3)
      r = `_${c.slice(i - 3, i)}${r}`;
    return `${c.slice(0, i)}${r}`;
  }
  function $(c, r, i) {
    k(r, "offset"), (c[r] === void 0 || c[r + i] === void 0) && oe(r, c.length - (i + 1));
  }
  function C(c, r, i, p, v, S) {
    if (c > i || c < r) {
      const M = typeof r == "bigint" ? "n" : "";
      let H;
      throw S > 3 ? r === 0 || r === BigInt(0) ? H = `>= 0${M} and < 2${M} ** ${(S + 1) * 8}${M}` : H = `>= -(2${M} ** ${(S + 1) * 8 - 1}${M}) and < 2 ** ${(S + 1) * 8 - 1}${M}` : H = `>= ${r}${M} and <= ${i}${M}`, new a.ERR_OUT_OF_RANGE("value", H, c);
    }
    $(p, v, S);
  }
  function k(c, r) {
    if (typeof c != "number")
      throw new a.ERR_INVALID_ARG_TYPE(r, "number", c);
  }
  function oe(c, r, i) {
    throw Math.floor(c) !== c ? (k(c, i), new a.ERR_OUT_OF_RANGE(i || "offset", "an integer", c)) : r < 0 ? new a.ERR_BUFFER_OUT_OF_BOUNDS() : new a.ERR_OUT_OF_RANGE(
      i || "offset",
      `>= ${i ? 1 : 0} and <= ${r}`,
      c
    );
  }
  const Se = /[^+/0-9A-Za-z-_]/g;
  function Ce(c) {
    if (c = c.split("=")[0], c = c.trim().replace(Se, ""), c.length < 2)
      return "";
    for (; c.length % 4 !== 0; )
      c = c + "=";
    return c;
  }
  function Ne(c, r) {
    r = r || 1 / 0;
    let i;
    const p = c.length;
    let v = null;
    const S = [];
    for (let M = 0; M < p; ++M) {
      if (i = c.charCodeAt(M), i > 55295 && i < 57344) {
        if (!v) {
          if (i > 56319) {
            (r -= 3) > -1 && S.push(239, 191, 189);
            continue;
          } else if (M + 1 === p) {
            (r -= 3) > -1 && S.push(239, 191, 189);
            continue;
          }
          v = i;
          continue;
        }
        if (i < 56320) {
          (r -= 3) > -1 && S.push(239, 191, 189), v = i;
          continue;
        }
        i = (v - 55296 << 10 | i - 56320) + 65536;
      } else
        v && (r -= 3) > -1 && S.push(239, 191, 189);
      if (v = null, i < 128) {
        if ((r -= 1) < 0)
          break;
        S.push(i);
      } else if (i < 2048) {
        if ((r -= 2) < 0)
          break;
        S.push(
          i >> 6 | 192,
          i & 63 | 128
        );
      } else if (i < 65536) {
        if ((r -= 3) < 0)
          break;
        S.push(
          i >> 12 | 224,
          i >> 6 & 63 | 128,
          i & 63 | 128
        );
      } else if (i < 1114112) {
        if ((r -= 4) < 0)
          break;
        S.push(
          i >> 18 | 240,
          i >> 12 & 63 | 128,
          i >> 6 & 63 | 128,
          i & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return S;
  }
  function Be(c) {
    const r = [];
    for (let i = 0; i < c.length; ++i)
      r.push(c.charCodeAt(i) & 255);
    return r;
  }
  function O(c, r) {
    let i, p, v;
    const S = [];
    for (let M = 0; M < c.length && !((r -= 2) < 0); ++M)
      i = c.charCodeAt(M), p = i >> 8, v = i % 256, S.push(v), S.push(p);
    return S;
  }
  function xe(c) {
    return t.toByteArray(Ce(c));
  }
  function Ae(c, r, i, p) {
    let v;
    for (v = 0; v < p && !(v + i >= r.length || v >= c.length); ++v)
      r[v + i] = c[v];
    return v;
  }
  function pe(c, r) {
    return c instanceof r || c != null && c.constructor != null && c.constructor.name != null && c.constructor.name === r.name;
  }
  function be(c) {
    return c !== c;
  }
  const _e = function() {
    const c = "0123456789abcdef", r = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const p = i * 16;
      for (let v = 0; v < 16; ++v)
        r[p + v] = c[i] + c[v];
    }
    return r;
  }();
  function le(c) {
    return typeof BigInt > "u" ? Ji : c;
  }
  function Ji() {
    throw new Error("BigInt not supported");
  }
})(ct);
var Bn = { exports: {} };
var fe = Bn.exports = {};
var Ie;
var je;
function Ar() {
  throw new Error("setTimeout has not been defined");
}
function xr() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Ie = setTimeout : Ie = Ar;
  } catch {
    Ie = Ar;
  }
  try {
    typeof clearTimeout == "function" ? je = clearTimeout : je = xr;
  } catch {
    je = xr;
  }
})();
function On(e2) {
  if (Ie === setTimeout)
    return setTimeout(e2, 0);
  if ((Ie === Ar || !Ie) && setTimeout)
    return Ie = setTimeout, setTimeout(e2, 0);
  try {
    return Ie(e2, 0);
  } catch {
    try {
      return Ie.call(null, e2, 0);
    } catch {
      return Ie.call(this, e2, 0);
    }
  }
}
function uo(e2) {
  if (je === clearTimeout)
    return clearTimeout(e2);
  if ((je === xr || !je) && clearTimeout)
    return je = clearTimeout, clearTimeout(e2);
  try {
    return je(e2);
  } catch {
    try {
      return je.call(null, e2);
    } catch {
      return je.call(this, e2);
    }
  }
}
var De = [];
var rt = false;
var ze;
var Tt = -1;
function fo() {
  !rt || !ze || (rt = false, ze.length ? De = ze.concat(De) : Tt = -1, De.length && Pn());
}
function Pn() {
  if (!rt) {
    var e2 = On(fo);
    rt = true;
    for (var t = De.length; t; ) {
      for (ze = De, De = []; ++Tt < t; )
        ze && ze[Tt].run();
      Tt = -1, t = De.length;
    }
    ze = null, rt = false, uo(e2);
  }
}
fe.nextTick = function(e2) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var n = 1; n < arguments.length; n++)
      t[n - 1] = arguments[n];
  De.push(new Cn(e2, t)), De.length === 1 && !rt && On(Pn);
};
function Cn(e2, t) {
  this.fun = e2, this.array = t;
}
Cn.prototype.run = function() {
  this.fun.apply(null, this.array);
};
fe.title = "browser";
fe.browser = true;
fe.env = {};
fe.argv = [];
fe.version = "";
fe.versions = {};
function We() {
}
fe.on = We;
fe.addListener = We;
fe.once = We;
fe.off = We;
fe.removeListener = We;
fe.removeAllListeners = We;
fe.emit = We;
fe.prependListener = We;
fe.prependOnceListener = We;
fe.listeners = function(e2) {
  return [];
};
fe.binding = function(e2) {
  throw new Error("process.binding is not supported");
};
fe.cwd = function() {
  return "/";
};
fe.chdir = function(e2) {
  throw new Error("process.chdir is not supported");
};
fe.umask = function() {
  return 0;
};
var co = Bn.exports;
(function(e2) {
  Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" });
  const t = ct, n = co, s = (l) => l && l.__esModule ? l : { default: l }, u = s(n), d = globalThis || void 0 || self;
  Object.defineProperty(e2, "Buffer", { enumerable: true, get: () => t.Buffer }), Object.defineProperty(e2, "process", { enumerable: true, get: () => u.default }), e2.global = d;
})(J);
var Rr = { exports: {} };
typeof J.process > "u" || !J.process.version || J.process.version.indexOf("v0.") === 0 || J.process.version.indexOf("v1.") === 0 && J.process.version.indexOf("v1.8.") !== 0 ? Rr.exports = { nextTick: lo } : Rr.exports = J.process;
function lo(e2, t, n, s) {
  if (typeof e2 != "function")
    throw new TypeError('"callback" argument must be a function');
  var u = arguments.length, d, l;
  switch (u) {
    case 0:
    case 1:
      return J.process.nextTick(e2);
    case 2:
      return J.process.nextTick(function() {
        e2.call(null, t);
      });
    case 3:
      return J.process.nextTick(function() {
        e2.call(null, t, n);
      });
    case 4:
      return J.process.nextTick(function() {
        e2.call(null, t, n, s);
      });
    default:
      for (d = new Array(u - 1), l = 0; l < d.length; )
        d[l++] = arguments[l];
      return J.process.nextTick(function() {
        e2.apply(null, d);
      });
  }
}
var Ge = Rr.exports;
var ho = {}.toString;
var po = Array.isArray || function(e2) {
  return ho.call(e2) == "[object Array]";
};
var Dr = { exports: {} };
var nt = typeof Reflect == "object" ? Reflect : null;
var tn = nt && typeof nt.apply == "function" ? nt.apply : function(t, n, s) {
  return Function.prototype.apply.call(t, n, s);
};
var Mt;
nt && typeof nt.ownKeys == "function" ? Mt = nt.ownKeys : Object.getOwnPropertySymbols ? Mt = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : Mt = function(t) {
  return Object.getOwnPropertyNames(t);
};
function yo(e2) {
  console && console.warn && console.warn(e2);
}
var In = Number.isNaN || function(t) {
  return t !== t;
};
function X() {
  X.init.call(this);
}
Dr.exports = X;
Dr.exports.once = vo;
X.EventEmitter = X;
X.prototype._events = void 0;
X.prototype._eventsCount = 0;
X.prototype._maxListeners = void 0;
var rn = 10;
function Lt(e2) {
  if (typeof e2 != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e2);
}
Object.defineProperty(X, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return rn;
  },
  set: function(e2) {
    if (typeof e2 != "number" || e2 < 0 || In(e2))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e2 + ".");
    rn = e2;
  }
});
X.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
X.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || In(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function jn(e2) {
  return e2._maxListeners === void 0 ? X.defaultMaxListeners : e2._maxListeners;
}
X.prototype.getMaxListeners = function() {
  return jn(this);
};
X.prototype.emit = function(t) {
  for (var n = [], s = 1; s < arguments.length; s++)
    n.push(arguments[s]);
  var u = t === "error", d = this._events;
  if (d !== void 0)
    u = u && d.error === void 0;
  else if (!u)
    return false;
  if (u) {
    var l;
    if (n.length > 0 && (l = n[0]), l instanceof Error)
      throw l;
    var f = new Error("Unhandled error." + (l ? " (" + l.message + ")" : ""));
    throw f.context = l, f;
  }
  var g = d[t];
  if (g === void 0)
    return false;
  if (typeof g == "function")
    tn(g, this, n);
  else
    for (var T = g.length, F = Un(g, T), s = 0; s < T; ++s)
      tn(F[s], this, n);
  return true;
};
function Fn(e2, t, n, s) {
  var u, d, l;
  if (Lt(n), d = e2._events, d === void 0 ? (d = e2._events = /* @__PURE__ */ Object.create(null), e2._eventsCount = 0) : (d.newListener !== void 0 && (e2.emit(
    "newListener",
    t,
    n.listener ? n.listener : n
  ), d = e2._events), l = d[t]), l === void 0)
    l = d[t] = n, ++e2._eventsCount;
  else if (typeof l == "function" ? l = d[t] = s ? [n, l] : [l, n] : s ? l.unshift(n) : l.push(n), u = jn(e2), u > 0 && l.length > u && !l.warned) {
    l.warned = true;
    var f = new Error("Possible EventEmitter memory leak detected. " + l.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    f.name = "MaxListenersExceededWarning", f.emitter = e2, f.type = t, f.count = l.length, yo(f);
  }
  return e2;
}
X.prototype.addListener = function(t, n) {
  return Fn(this, t, n, false);
};
X.prototype.on = X.prototype.addListener;
X.prototype.prependListener = function(t, n) {
  return Fn(this, t, n, true);
};
function go() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function kn(e2, t, n) {
  var s = { fired: false, wrapFn: void 0, target: e2, type: t, listener: n }, u = go.bind(s);
  return u.listener = n, s.wrapFn = u, u;
}
X.prototype.once = function(t, n) {
  return Lt(n), this.on(t, kn(this, t, n)), this;
};
X.prototype.prependOnceListener = function(t, n) {
  return Lt(n), this.prependListener(t, kn(this, t, n)), this;
};
X.prototype.removeListener = function(t, n) {
  var s, u, d, l, f;
  if (Lt(n), u = this._events, u === void 0)
    return this;
  if (s = u[t], s === void 0)
    return this;
  if (s === n || s.listener === n)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete u[t], u.removeListener && this.emit("removeListener", t, s.listener || n));
  else if (typeof s != "function") {
    for (d = -1, l = s.length - 1; l >= 0; l--)
      if (s[l] === n || s[l].listener === n) {
        f = s[l].listener, d = l;
        break;
      }
    if (d < 0)
      return this;
    d === 0 ? s.shift() : mo(s, d), s.length === 1 && (u[t] = s[0]), u.removeListener !== void 0 && this.emit("removeListener", t, f || n);
  }
  return this;
};
X.prototype.off = X.prototype.removeListener;
X.prototype.removeAllListeners = function(t) {
  var n, s, u;
  if (s = this._events, s === void 0)
    return this;
  if (s.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : s[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete s[t]), this;
  if (arguments.length === 0) {
    var d = Object.keys(s), l;
    for (u = 0; u < d.length; ++u)
      l = d[u], l !== "removeListener" && this.removeAllListeners(l);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (n = s[t], typeof n == "function")
    this.removeListener(t, n);
  else if (n !== void 0)
    for (u = n.length - 1; u >= 0; u--)
      this.removeListener(t, n[u]);
  return this;
};
function $n(e2, t, n) {
  var s = e2._events;
  if (s === void 0)
    return [];
  var u = s[t];
  return u === void 0 ? [] : typeof u == "function" ? n ? [u.listener || u] : [u] : n ? wo(u) : Un(u, u.length);
}
X.prototype.listeners = function(t) {
  return $n(this, t, true);
};
X.prototype.rawListeners = function(t) {
  return $n(this, t, false);
};
X.listenerCount = function(e2, t) {
  return typeof e2.listenerCount == "function" ? e2.listenerCount(t) : Nn.call(e2, t);
};
X.prototype.listenerCount = Nn;
function Nn(e2) {
  var t = this._events;
  if (t !== void 0) {
    var n = t[e2];
    if (typeof n == "function")
      return 1;
    if (n !== void 0)
      return n.length;
  }
  return 0;
}
X.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Mt(this._events) : [];
};
function Un(e2, t) {
  for (var n = new Array(t), s = 0; s < t; ++s)
    n[s] = e2[s];
  return n;
}
function mo(e2, t) {
  for (; t + 1 < e2.length; t++)
    e2[t] = e2[t + 1];
  e2.pop();
}
function wo(e2) {
  for (var t = new Array(e2.length), n = 0; n < t.length; ++n)
    t[n] = e2[n].listener || e2[n];
  return t;
}
function vo(e2, t) {
  return new Promise(function(n, s) {
    function u(l) {
      e2.removeListener(t, d), s(l);
    }
    function d() {
      typeof e2.removeListener == "function" && e2.removeListener("error", u), n([].slice.call(arguments));
    }
    Dn(e2, t, d, { once: true }), t !== "error" && bo(e2, u, { once: true });
  });
}
function bo(e2, t, n) {
  typeof e2.on == "function" && Dn(e2, "error", t, n);
}
function Dn(e2, t, n, s) {
  if (typeof e2.on == "function")
    s.once ? e2.once(t, n) : e2.on(t, n);
  else if (typeof e2.addEventListener == "function")
    e2.addEventListener(t, function u(d) {
      s.once && e2.removeEventListener(t, u), n(d);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e2);
}
var lt = Dr.exports;
var Ln = lt.EventEmitter;
var Tr = { exports: {} };
(function(e2, t) {
  var n = ct, s = n.Buffer;
  function u(l, f) {
    for (var g in l)
      f[g] = l[g];
  }
  s.from && s.alloc && s.allocUnsafe && s.allocUnsafeSlow ? e2.exports = n : (u(n, t), t.Buffer = d);
  function d(l, f, g) {
    return s(l, f, g);
  }
  u(s, d), d.from = function(l, f, g) {
    if (typeof l == "number")
      throw new TypeError("Argument must not be a number");
    return s(l, f, g);
  }, d.alloc = function(l, f, g) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    var T = s(l);
    return f !== void 0 ? typeof g == "string" ? T.fill(f, g) : T.fill(f) : T.fill(0), T;
  }, d.allocUnsafe = function(l) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    return s(l);
  }, d.allocUnsafeSlow = function(l) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    return n.SlowBuffer(l);
  };
})(Tr, Tr.exports);
var Lr = Tr.exports;
var re = {};
function _o(e2) {
  return Array.isArray ? Array.isArray(e2) : qt(e2) === "[object Array]";
}
re.isArray = _o;
function Eo(e2) {
  return typeof e2 == "boolean";
}
re.isBoolean = Eo;
function So(e2) {
  return e2 === null;
}
re.isNull = So;
function Ao(e2) {
  return e2 == null;
}
re.isNullOrUndefined = Ao;
function xo(e2) {
  return typeof e2 == "number";
}
re.isNumber = xo;
function Ro(e2) {
  return typeof e2 == "string";
}
re.isString = Ro;
function To(e2) {
  return typeof e2 == "symbol";
}
re.isSymbol = To;
function Mo(e2) {
  return e2 === void 0;
}
re.isUndefined = Mo;
function Bo(e2) {
  return qt(e2) === "[object RegExp]";
}
re.isRegExp = Bo;
function Oo(e2) {
  return typeof e2 == "object" && e2 !== null;
}
re.isObject = Oo;
function Po(e2) {
  return qt(e2) === "[object Date]";
}
re.isDate = Po;
function Co(e2) {
  return qt(e2) === "[object Error]" || e2 instanceof Error;
}
re.isError = Co;
function Io(e2) {
  return typeof e2 == "function";
}
re.isFunction = Io;
function jo(e2) {
  return e2 === null || typeof e2 == "boolean" || typeof e2 == "number" || typeof e2 == "string" || typeof e2 == "symbol" || // ES6 symbol
  typeof e2 > "u";
}
re.isPrimitive = jo;
re.isBuffer = ct.Buffer.isBuffer;
function qt(e2) {
  return Object.prototype.toString.call(e2);
}
var Mr = { exports: {} };
typeof Object.create == "function" ? Mr.exports = function(t, n) {
  n && (t.super_ = n, t.prototype = Object.create(n.prototype, {
    constructor: {
      value: t,
      enumerable: false,
      writable: true,
      configurable: true
    }
  }));
} : Mr.exports = function(t, n) {
  if (n) {
    t.super_ = n;
    var s = function() {
    };
    s.prototype = n.prototype, t.prototype = new s(), t.prototype.constructor = t;
  }
};
var Pe = Mr.exports;
var wt = {};
var qn = {};
var Wn = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return false;
  if (typeof Symbol.iterator == "symbol")
    return true;
  var t = {}, n = Symbol("test"), s = Object(n);
  if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(s) !== "[object Symbol]")
    return false;
  var u = 42;
  t[n] = u;
  for (n in t)
    return false;
  if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
    return false;
  var d = Object.getOwnPropertySymbols(t);
  if (d.length !== 1 || d[0] !== n || !Object.prototype.propertyIsEnumerable.call(t, n))
    return false;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var l = Object.getOwnPropertyDescriptor(t, n);
    if (l.value !== u || l.enumerable !== true)
      return false;
  }
  return true;
};
var Fo = Wn;
var Wt = function() {
  return Fo() && !!Symbol.toStringTag;
};
var nn = typeof Symbol < "u" && Symbol;
var ko = Wn;
var $o = function() {
  return typeof nn != "function" || typeof Symbol != "function" || typeof nn("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : ko();
};
var No = "Function.prototype.bind called on incompatible ";
var tr = Array.prototype.slice;
var Uo = Object.prototype.toString;
var Do = "[object Function]";
var Lo = function(t) {
  var n = this;
  if (typeof n != "function" || Uo.call(n) !== Do)
    throw new TypeError(No + n);
  for (var s = tr.call(arguments, 1), u, d = function() {
    if (this instanceof u) {
      var F = n.apply(
        this,
        s.concat(tr.call(arguments))
      );
      return Object(F) === F ? F : this;
    } else
      return n.apply(
        t,
        s.concat(tr.call(arguments))
      );
  }, l = Math.max(0, n.length - s.length), f = [], g = 0; g < l; g++)
    f.push("$" + g);
  if (u = Function("binder", "return function (" + f.join(",") + "){ return binder.apply(this,arguments); }")(d), n.prototype) {
    var T = function() {
    };
    T.prototype = n.prototype, u.prototype = new T(), T.prototype = null;
  }
  return u;
};
var qo = Lo;
var qr = Function.prototype.bind || qo;
var Wo = qr;
var Vo = Wo.call(Function.call, Object.prototype.hasOwnProperty);
var G;
var st = SyntaxError;
var Vn = Function;
var it = TypeError;
var rr = function(e2) {
  try {
    return Vn('"use strict"; return (' + e2 + ").constructor;")();
  } catch {
  }
};
var Xe = Object.getOwnPropertyDescriptor;
if (Xe)
  try {
    Xe({}, "");
  } catch {
    Xe = null;
  }
var nr = function() {
  throw new it();
};
var Ho = Xe ? function() {
  try {
    return arguments.callee, nr;
  } catch {
    try {
      return Xe(arguments, "callee").get;
    } catch {
      return nr;
    }
  }
}() : nr;
var Qe = $o();
var Fe = Object.getPrototypeOf || function(e2) {
  return e2.__proto__;
};
var et = {};
var Go = typeof Uint8Array > "u" ? G : Fe(Uint8Array);
var Ke = {
  "%AggregateError%": typeof AggregateError > "u" ? G : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? G : ArrayBuffer,
  "%ArrayIteratorPrototype%": Qe ? Fe([][Symbol.iterator]()) : G,
  "%AsyncFromSyncIteratorPrototype%": G,
  "%AsyncFunction%": et,
  "%AsyncGenerator%": et,
  "%AsyncGeneratorFunction%": et,
  "%AsyncIteratorPrototype%": et,
  "%Atomics%": typeof Atomics > "u" ? G : Atomics,
  "%BigInt%": typeof BigInt > "u" ? G : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? G : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? G : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? G : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? G : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? G : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? G : FinalizationRegistry,
  "%Function%": Vn,
  "%GeneratorFunction%": et,
  "%Int8Array%": typeof Int8Array > "u" ? G : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? G : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? G : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": Qe ? Fe(Fe([][Symbol.iterator]())) : G,
  "%JSON%": typeof JSON == "object" ? JSON : G,
  "%Map%": typeof Map > "u" ? G : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !Qe ? G : Fe((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? G : Promise,
  "%Proxy%": typeof Proxy > "u" ? G : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? G : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? G : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !Qe ? G : Fe((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? G : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": Qe ? Fe(""[Symbol.iterator]()) : G,
  "%Symbol%": Qe ? Symbol : G,
  "%SyntaxError%": st,
  "%ThrowTypeError%": Ho,
  "%TypedArray%": Go,
  "%TypeError%": it,
  "%Uint8Array%": typeof Uint8Array > "u" ? G : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? G : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? G : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? G : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap > "u" ? G : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? G : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? G : WeakSet
};
try {
  null.error;
} catch (e2) {
  zo = Fe(Fe(e2));
  Ke["%Error.prototype%"] = zo;
}
var zo;
var Jo = function e(t) {
  var n;
  if (t === "%AsyncFunction%")
    n = rr("async function () {}");
  else if (t === "%GeneratorFunction%")
    n = rr("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    n = rr("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var s = e("%AsyncGeneratorFunction%");
    s && (n = s.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var u = e("%AsyncGenerator%");
    u && (n = Fe(u.prototype));
  }
  return Ke[t] = n, n;
};
var on = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var vt = qr;
var jt = Vo;
var Xo = vt.call(Function.call, Array.prototype.concat);
var Ko = vt.call(Function.apply, Array.prototype.splice);
var an = vt.call(Function.call, String.prototype.replace);
var Ft = vt.call(Function.call, String.prototype.slice);
var Yo = vt.call(Function.call, RegExp.prototype.exec);
var Zo = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var Qo = /\\(\\)?/g;
var ea = function(t) {
  var n = Ft(t, 0, 1), s = Ft(t, -1);
  if (n === "%" && s !== "%")
    throw new st("invalid intrinsic syntax, expected closing `%`");
  if (s === "%" && n !== "%")
    throw new st("invalid intrinsic syntax, expected opening `%`");
  var u = [];
  return an(t, Zo, function(d, l, f, g) {
    u[u.length] = f ? an(g, Qo, "$1") : l || d;
  }), u;
};
var ta = function(t, n) {
  var s = t, u;
  if (jt(on, s) && (u = on[s], s = "%" + u[0] + "%"), jt(Ke, s)) {
    var d = Ke[s];
    if (d === et && (d = Jo(s)), typeof d > "u" && !n)
      throw new it("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: u,
      name: s,
      value: d
    };
  }
  throw new st("intrinsic " + t + " does not exist!");
};
var Wr = function(t, n) {
  if (typeof t != "string" || t.length === 0)
    throw new it("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof n != "boolean")
    throw new it('"allowMissing" argument must be a boolean');
  if (Yo(/^%?[^%]*%?$/, t) === null)
    throw new st("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var s = ea(t), u = s.length > 0 ? s[0] : "", d = ta("%" + u + "%", n), l = d.name, f = d.value, g = false, T = d.alias;
  T && (u = T[0], Ko(s, Xo([0, 1], T)));
  for (var F = 1, E = true; F < s.length; F += 1) {
    var j = s[F], U = Ft(j, 0, 1), q = Ft(j, -1);
    if ((U === '"' || U === "'" || U === "`" || q === '"' || q === "'" || q === "`") && U !== q)
      throw new st("property names with quotes must have matching quotes");
    if ((j === "constructor" || !E) && (g = true), u += "." + j, l = "%" + u + "%", jt(Ke, l))
      f = Ke[l];
    else if (f != null) {
      if (!(j in f)) {
        if (!n)
          throw new it("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (Xe && F + 1 >= s.length) {
        var N = Xe(f, j);
        E = !!N, E && "get" in N && !("originalValue" in N.get) ? f = N.get : f = f[j];
      } else
        E = jt(f, j), f = f[j];
      E && !g && (Ke[l] = f);
    }
  }
  return f;
};
var Hn = { exports: {} };
(function(e2) {
  var t = qr, n = Wr, s = n("%Function.prototype.apply%"), u = n("%Function.prototype.call%"), d = n("%Reflect.apply%", true) || t.call(u, s), l = n("%Object.getOwnPropertyDescriptor%", true), f = n("%Object.defineProperty%", true), g = n("%Math.max%");
  if (f)
    try {
      f({}, "a", { value: 1 });
    } catch {
      f = null;
    }
  e2.exports = function(E) {
    var j = d(t, u, arguments);
    if (l && f) {
      var U = l(j, "length");
      U.configurable && f(
        j,
        "length",
        { value: 1 + g(0, E.length - (arguments.length - 1)) }
      );
    }
    return j;
  };
  var T = function() {
    return d(t, s, arguments);
  };
  f ? f(e2.exports, "apply", { value: T }) : e2.exports.apply = T;
})(Hn);
var ra = Hn.exports;
var Gn = Wr;
var zn = ra;
var na = zn(Gn("String.prototype.indexOf"));
var Vr = function(t, n) {
  var s = Gn(t, !!n);
  return typeof s == "function" && na(t, ".prototype.") > -1 ? zn(s) : s;
};
var ia = Wt();
var oa = Vr;
var Br = oa("Object.prototype.toString");
var Vt = function(t) {
  return ia && t && typeof t == "object" && Symbol.toStringTag in t ? false : Br(t) === "[object Arguments]";
};
var Jn = function(t) {
  return Vt(t) ? true : t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && Br(t) !== "[object Array]" && Br(t.callee) === "[object Function]";
};
var aa = function() {
  return Vt(arguments);
}();
Vt.isLegacyArguments = Jn;
var sa = aa ? Vt : Jn;
var ua = Object.prototype.toString;
var fa = Function.prototype.toString;
var ca = /^\s*(?:function)?\*/;
var Xn = Wt();
var ir = Object.getPrototypeOf;
var la = function() {
  if (!Xn)
    return false;
  try {
    return Function("return function*() {}")();
  } catch {
  }
};
var or;
var da = function(t) {
  if (typeof t != "function")
    return false;
  if (ca.test(fa.call(t)))
    return true;
  if (!Xn) {
    var n = ua.call(t);
    return n === "[object GeneratorFunction]";
  }
  if (!ir)
    return false;
  if (typeof or > "u") {
    var s = la();
    or = s ? ir(s) : false;
  }
  return ir(t) === or;
};
var Kn = Function.prototype.toString;
var tt = typeof Reflect == "object" && Reflect !== null && Reflect.apply;
var Or;
var Bt;
if (typeof tt == "function" && typeof Object.defineProperty == "function")
  try {
    Or = Object.defineProperty({}, "length", {
      get: function() {
        throw Bt;
      }
    }), Bt = {}, tt(function() {
      throw 42;
    }, null, Or);
  } catch (e2) {
    e2 !== Bt && (tt = null);
  }
else
  tt = null;
var ha = /^\s*class\b/;
var Pr = function(t) {
  try {
    var n = Kn.call(t);
    return ha.test(n);
  } catch {
    return false;
  }
};
var ar = function(t) {
  try {
    return Pr(t) ? false : (Kn.call(t), true);
  } catch {
    return false;
  }
};
var Ot = Object.prototype.toString;
var pa = "[object Object]";
var ya = "[object Function]";
var ga = "[object GeneratorFunction]";
var ma = "[object HTMLAllCollection]";
var wa = "[object HTML document.all class]";
var va = "[object HTMLCollection]";
var ba = typeof Symbol == "function" && !!Symbol.toStringTag;
var _a = !(0 in [,]);
var Cr = function() {
  return false;
};
if (typeof document == "object") {
  Ea = document.all;
  Ot.call(Ea) === Ot.call(document.all) && (Cr = function(t) {
    if ((_a || !t) && (typeof t > "u" || typeof t == "object"))
      try {
        var n = Ot.call(t);
        return (n === ma || n === wa || n === va || n === pa) && t("") == null;
      } catch {
      }
    return false;
  });
}
var Ea;
var Sa = tt ? function(t) {
  if (Cr(t))
    return true;
  if (!t || typeof t != "function" && typeof t != "object")
    return false;
  try {
    tt(t, null, Or);
  } catch (n) {
    if (n !== Bt)
      return false;
  }
  return !Pr(t) && ar(t);
} : function(t) {
  if (Cr(t))
    return true;
  if (!t || typeof t != "function" && typeof t != "object")
    return false;
  if (ba)
    return ar(t);
  if (Pr(t))
    return false;
  var n = Ot.call(t);
  return n !== ya && n !== ga && !/^\[object HTML/.test(n) ? false : ar(t);
};
var Aa = Sa;
var xa = Object.prototype.toString;
var Yn = Object.prototype.hasOwnProperty;
var Ra = function(t, n, s) {
  for (var u = 0, d = t.length; u < d; u++)
    Yn.call(t, u) && (s == null ? n(t[u], u, t) : n.call(s, t[u], u, t));
};
var Ta = function(t, n, s) {
  for (var u = 0, d = t.length; u < d; u++)
    s == null ? n(t.charAt(u), u, t) : n.call(s, t.charAt(u), u, t);
};
var Ma = function(t, n, s) {
  for (var u in t)
    Yn.call(t, u) && (s == null ? n(t[u], u, t) : n.call(s, t[u], u, t));
};
var Ba = function(t, n, s) {
  if (!Aa(n))
    throw new TypeError("iterator must be a function");
  var u;
  arguments.length >= 3 && (u = s), xa.call(t) === "[object Array]" ? Ra(t, n, u) : typeof t == "string" ? Ta(t, n, u) : Ma(t, n, u);
};
var Zn = Ba;
var sr = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
];
var Oa = typeof globalThis > "u" ? te : globalThis;
var Qn = function() {
  for (var t = [], n = 0; n < sr.length; n++)
    typeof Oa[sr[n]] == "function" && (t[t.length] = sr[n]);
  return t;
};
var Pa = Wr;
var Pt = Pa("%Object.getOwnPropertyDescriptor%", true);
if (Pt)
  try {
    Pt([], "length");
  } catch {
    Pt = null;
  }
var ei = Pt;
var ti = Zn;
var Ca = Qn;
var Hr = Vr;
var Ia = Hr("Object.prototype.toString");
var ri = Wt();
var Ct = ei;
var ja = typeof globalThis > "u" ? te : globalThis;
var ni = Ca();
var Fa = Hr("Array.prototype.indexOf", true) || function(t, n) {
  for (var s = 0; s < t.length; s += 1)
    if (t[s] === n)
      return s;
  return -1;
};
var ka = Hr("String.prototype.slice");
var ii = {};
var ur = Object.getPrototypeOf;
ri && Ct && ur && ti(ni, function(e2) {
  var t = new ja[e2]();
  if (Symbol.toStringTag in t) {
    var n = ur(t), s = Ct(n, Symbol.toStringTag);
    if (!s) {
      var u = ur(n);
      s = Ct(u, Symbol.toStringTag);
    }
    ii[e2] = s.get;
  }
});
var $a = function(t) {
  var n = false;
  return ti(ii, function(s, u) {
    if (!n)
      try {
        n = s.call(t) === u;
      } catch {
      }
  }), n;
};
var oi = function(t) {
  if (!t || typeof t != "object")
    return false;
  if (!ri || !(Symbol.toStringTag in t)) {
    var n = ka(Ia(t), 8, -1);
    return Fa(ni, n) > -1;
  }
  return Ct ? $a(t) : false;
};
var ai = Zn;
var Na = Qn;
var si = Vr;
var fr = ei;
var Ua = si("Object.prototype.toString");
var ui = Wt();
var sn = typeof globalThis > "u" ? te : globalThis;
var Da = Na();
var La = si("String.prototype.slice");
var fi = {};
var cr = Object.getPrototypeOf;
ui && fr && cr && ai(Da, function(e2) {
  if (typeof sn[e2] == "function") {
    var t = new sn[e2]();
    if (Symbol.toStringTag in t) {
      var n = cr(t), s = fr(n, Symbol.toStringTag);
      if (!s) {
        var u = cr(n);
        s = fr(u, Symbol.toStringTag);
      }
      fi[e2] = s.get;
    }
  }
});
var qa = function(t) {
  var n = false;
  return ai(fi, function(s, u) {
    if (!n)
      try {
        var d = s.call(t);
        d === u && (n = d);
      } catch {
      }
  }), n;
};
var Wa = oi;
var Va = function(t) {
  return Wa(t) ? !ui || !(Symbol.toStringTag in t) ? La(Ua(t), 8, -1) : qa(t) : false;
};
(function(e2) {
  var t = sa, n = da, s = Va, u = oi;
  function d(O) {
    return O.call.bind(O);
  }
  var l = typeof BigInt < "u", f = typeof Symbol < "u", g = d(Object.prototype.toString), T = d(Number.prototype.valueOf), F = d(String.prototype.valueOf), E = d(Boolean.prototype.valueOf);
  if (l)
    var j = d(BigInt.prototype.valueOf);
  if (f)
    var U = d(Symbol.prototype.valueOf);
  function q(O, xe) {
    if (typeof O != "object")
      return false;
    try {
      return xe(O), true;
    } catch {
      return false;
    }
  }
  e2.isArgumentsObject = t, e2.isGeneratorFunction = n, e2.isTypedArray = u;
  function N(O) {
    return typeof Promise < "u" && O instanceof Promise || O !== null && typeof O == "object" && typeof O.then == "function" && typeof O.catch == "function";
  }
  e2.isPromise = N;
  function Q(O) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(O) : u(O) || A(O);
  }
  e2.isArrayBufferView = Q;
  function x(O) {
    return s(O) === "Uint8Array";
  }
  e2.isUint8Array = x;
  function R(O) {
    return s(O) === "Uint8ClampedArray";
  }
  e2.isUint8ClampedArray = R;
  function L(O) {
    return s(O) === "Uint16Array";
  }
  e2.isUint16Array = L;
  function z(O) {
    return s(O) === "Uint32Array";
  }
  e2.isUint32Array = z;
  function V(O) {
    return s(O) === "Int8Array";
  }
  e2.isInt8Array = V;
  function Ee(O) {
    return s(O) === "Int16Array";
  }
  e2.isInt16Array = Ee;
  function ie(O) {
    return s(O) === "Int32Array";
  }
  e2.isInt32Array = ie;
  function de(O) {
    return s(O) === "Float32Array";
  }
  e2.isFloat32Array = de;
  function ce(O) {
    return s(O) === "Float64Array";
  }
  e2.isFloat64Array = ce;
  function he(O) {
    return s(O) === "BigInt64Array";
  }
  e2.isBigInt64Array = he;
  function ee(O) {
    return s(O) === "BigUint64Array";
  }
  e2.isBigUint64Array = ee;
  function ue(O) {
    return g(O) === "[object Map]";
  }
  ue.working = typeof Map < "u" && ue(/* @__PURE__ */ new Map());
  function ve(O) {
    return typeof Map > "u" ? false : ue.working ? ue(O) : O instanceof Map;
  }
  e2.isMap = ve;
  function K(O) {
    return g(O) === "[object Set]";
  }
  K.working = typeof Set < "u" && K(/* @__PURE__ */ new Set());
  function ge(O) {
    return typeof Set > "u" ? false : K.working ? K(O) : O instanceof Set;
  }
  e2.isSet = ge;
  function me(O) {
    return g(O) === "[object WeakMap]";
  }
  me.working = typeof WeakMap < "u" && me(/* @__PURE__ */ new WeakMap());
  function h(O) {
    return typeof WeakMap > "u" ? false : me.working ? me(O) : O instanceof WeakMap;
  }
  e2.isWeakMap = h;
  function y(O) {
    return g(O) === "[object WeakSet]";
  }
  y.working = typeof WeakSet < "u" && y(/* @__PURE__ */ new WeakSet());
  function b(O) {
    return y(O);
  }
  e2.isWeakSet = b;
  function P(O) {
    return g(O) === "[object ArrayBuffer]";
  }
  P.working = typeof ArrayBuffer < "u" && P(new ArrayBuffer());
  function I(O) {
    return typeof ArrayBuffer > "u" ? false : P.working ? P(O) : O instanceof ArrayBuffer;
  }
  e2.isArrayBuffer = I;
  function m(O) {
    return g(O) === "[object DataView]";
  }
  m.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && m(new DataView(new ArrayBuffer(1), 0, 1));
  function A(O) {
    return typeof DataView > "u" ? false : m.working ? m(O) : O instanceof DataView;
  }
  e2.isDataView = A;
  var B = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function D(O) {
    return g(O) === "[object SharedArrayBuffer]";
  }
  function W(O) {
    return typeof B > "u" ? false : (typeof D.working > "u" && (D.working = D(new B())), D.working ? D(O) : O instanceof B);
  }
  e2.isSharedArrayBuffer = W;
  function o(O) {
    return g(O) === "[object AsyncFunction]";
  }
  e2.isAsyncFunction = o;
  function a(O) {
    return g(O) === "[object Map Iterator]";
  }
  e2.isMapIterator = a;
  function w(O) {
    return g(O) === "[object Set Iterator]";
  }
  e2.isSetIterator = w;
  function _(O) {
    return g(O) === "[object Generator]";
  }
  e2.isGeneratorObject = _;
  function $(O) {
    return g(O) === "[object WebAssembly.Module]";
  }
  e2.isWebAssemblyCompiledModule = $;
  function C(O) {
    return q(O, T);
  }
  e2.isNumberObject = C;
  function k(O) {
    return q(O, F);
  }
  e2.isStringObject = k;
  function oe(O) {
    return q(O, E);
  }
  e2.isBooleanObject = oe;
  function Se(O) {
    return l && q(O, j);
  }
  e2.isBigIntObject = Se;
  function Ce(O) {
    return f && q(O, U);
  }
  e2.isSymbolObject = Ce;
  function Ne(O) {
    return C(O) || k(O) || oe(O) || Se(O) || Ce(O);
  }
  e2.isBoxedPrimitive = Ne;
  function Be(O) {
    return typeof Uint8Array < "u" && (I(O) || W(O));
  }
  e2.isAnyArrayBuffer = Be, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(O) {
    Object.defineProperty(e2, O, {
      enumerable: false,
      value: function() {
        throw new Error(O + " is not supported in userland");
      }
    });
  });
})(qn);
var Ha = function(t) {
  return t && typeof t == "object" && typeof t.copy == "function" && typeof t.fill == "function" && typeof t.readUInt8 == "function";
};
(function(e2) {
  var t = Object.getOwnPropertyDescriptors || function(A) {
    for (var B = Object.keys(A), D = {}, W = 0; W < B.length; W++)
      D[B[W]] = Object.getOwnPropertyDescriptor(A, B[W]);
    return D;
  }, n = /%[sdj%]/g;
  e2.format = function(m) {
    if (!V(m)) {
      for (var A = [], B = 0; B < arguments.length; B++)
        A.push(l(arguments[B]));
      return A.join(" ");
    }
    for (var B = 1, D = arguments, W = D.length, o = String(m).replace(n, function(w) {
      if (w === "%%")
        return "%";
      if (B >= W)
        return w;
      switch (w) {
        case "%s":
          return String(D[B++]);
        case "%d":
          return Number(D[B++]);
        case "%j":
          try {
            return JSON.stringify(D[B++]);
          } catch {
            return "[Circular]";
          }
        default:
          return w;
      }
    }), a = D[B]; B < W; a = D[++B])
      R(a) || !ce(a) ? o += " " + a : o += " " + l(a);
    return o;
  }, e2.deprecate = function(m, A) {
    if (typeof J.process < "u" && J.process.noDeprecation === true)
      return m;
    if (typeof J.process > "u")
      return function() {
        return e2.deprecate(m, A).apply(this, arguments);
      };
    var B = false;
    function D() {
      if (!B) {
        if (J.process.throwDeprecation)
          throw new Error(A);
        J.process.traceDeprecation ? console.trace(A) : console.error(A), B = true;
      }
      return m.apply(this, arguments);
    }
    return D;
  };
  var s = {}, u = /^$/;
  if (J.process.env.NODE_DEBUG) {
    var d = J.process.env.NODE_DEBUG;
    d = d.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), u = new RegExp("^" + d + "$", "i");
  }
  e2.debuglog = function(m) {
    if (m = m.toUpperCase(), !s[m])
      if (u.test(m)) {
        var A = J.process.pid;
        s[m] = function() {
          var B = e2.format.apply(e2, arguments);
          console.error("%s %d: %s", m, A, B);
        };
      } else
        s[m] = function() {
        };
    return s[m];
  };
  function l(m, A) {
    var B = {
      seen: [],
      stylize: g
    };
    return arguments.length >= 3 && (B.depth = arguments[2]), arguments.length >= 4 && (B.colors = arguments[3]), x(A) ? B.showHidden = A : A && e2._extend(B, A), ie(B.showHidden) && (B.showHidden = false), ie(B.depth) && (B.depth = 2), ie(B.colors) && (B.colors = false), ie(B.customInspect) && (B.customInspect = true), B.colors && (B.stylize = f), F(B, m, B.depth);
  }
  e2.inspect = l, l.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, l.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function f(m, A) {
    var B = l.styles[A];
    return B ? "\x1B[" + l.colors[B][0] + "m" + m + "\x1B[" + l.colors[B][1] + "m" : m;
  }
  function g(m, A) {
    return m;
  }
  function T(m) {
    var A = {};
    return m.forEach(function(B, D) {
      A[B] = true;
    }), A;
  }
  function F(m, A, B) {
    if (m.customInspect && A && ue(A.inspect) && // Filter out the util module, it's inspect function is special
    A.inspect !== e2.inspect && // Also filter out any prototype objects using the circular check.
    !(A.constructor && A.constructor.prototype === A)) {
      var D = A.inspect(B, m);
      return V(D) || (D = F(m, D, B)), D;
    }
    var W = E(m, A);
    if (W)
      return W;
    var o = Object.keys(A), a = T(o);
    if (m.showHidden && (o = Object.getOwnPropertyNames(A)), ee(A) && (o.indexOf("message") >= 0 || o.indexOf("description") >= 0))
      return j(A);
    if (o.length === 0) {
      if (ue(A)) {
        var w = A.name ? ": " + A.name : "";
        return m.stylize("[Function" + w + "]", "special");
      }
      if (de(A))
        return m.stylize(RegExp.prototype.toString.call(A), "regexp");
      if (he(A))
        return m.stylize(Date.prototype.toString.call(A), "date");
      if (ee(A))
        return j(A);
    }
    var _ = "", $ = false, C = ["{", "}"];
    if (Q(A) && ($ = true, C = ["[", "]"]), ue(A)) {
      var k = A.name ? ": " + A.name : "";
      _ = " [Function" + k + "]";
    }
    if (de(A) && (_ = " " + RegExp.prototype.toString.call(A)), he(A) && (_ = " " + Date.prototype.toUTCString.call(A)), ee(A) && (_ = " " + j(A)), o.length === 0 && (!$ || A.length == 0))
      return C[0] + _ + C[1];
    if (B < 0)
      return de(A) ? m.stylize(RegExp.prototype.toString.call(A), "regexp") : m.stylize("[Object]", "special");
    m.seen.push(A);
    var oe;
    return $ ? oe = U(m, A, B, a, o) : oe = o.map(function(Se) {
      return q(m, A, B, a, Se, $);
    }), m.seen.pop(), N(oe, _, C);
  }
  function E(m, A) {
    if (ie(A))
      return m.stylize("undefined", "undefined");
    if (V(A)) {
      var B = "'" + JSON.stringify(A).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return m.stylize(B, "string");
    }
    if (z(A))
      return m.stylize("" + A, "number");
    if (x(A))
      return m.stylize("" + A, "boolean");
    if (R(A))
      return m.stylize("null", "null");
  }
  function j(m) {
    return "[" + Error.prototype.toString.call(m) + "]";
  }
  function U(m, A, B, D, W) {
    for (var o = [], a = 0, w = A.length; a < w; ++a)
      y(A, String(a)) ? o.push(q(
        m,
        A,
        B,
        D,
        String(a),
        true
      )) : o.push("");
    return W.forEach(function(_) {
      _.match(/^\d+$/) || o.push(q(
        m,
        A,
        B,
        D,
        _,
        true
      ));
    }), o;
  }
  function q(m, A, B, D, W, o) {
    var a, w, _;
    if (_ = Object.getOwnPropertyDescriptor(A, W) || { value: A[W] }, _.get ? _.set ? w = m.stylize("[Getter/Setter]", "special") : w = m.stylize("[Getter]", "special") : _.set && (w = m.stylize("[Setter]", "special")), y(D, W) || (a = "[" + W + "]"), w || (m.seen.indexOf(_.value) < 0 ? (R(B) ? w = F(m, _.value, null) : w = F(m, _.value, B - 1), w.indexOf(`
`) > -1 && (o ? w = w.split(`
`).map(function($) {
      return "  " + $;
    }).join(`
`).slice(2) : w = `
` + w.split(`
`).map(function($) {
      return "   " + $;
    }).join(`
`))) : w = m.stylize("[Circular]", "special")), ie(a)) {
      if (o && W.match(/^\d+$/))
        return w;
      a = JSON.stringify("" + W), a.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (a = a.slice(1, -1), a = m.stylize(a, "name")) : (a = a.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), a = m.stylize(a, "string"));
    }
    return a + ": " + w;
  }
  function N(m, A, B) {
    var D = m.reduce(function(W, o) {
      return o.indexOf(`
`) >= 0, W + o.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return D > 60 ? B[0] + (A === "" ? "" : A + `
 `) + " " + m.join(`,
  `) + " " + B[1] : B[0] + A + " " + m.join(", ") + " " + B[1];
  }
  e2.types = qn;
  function Q(m) {
    return Array.isArray(m);
  }
  e2.isArray = Q;
  function x(m) {
    return typeof m == "boolean";
  }
  e2.isBoolean = x;
  function R(m) {
    return m === null;
  }
  e2.isNull = R;
  function L(m) {
    return m == null;
  }
  e2.isNullOrUndefined = L;
  function z(m) {
    return typeof m == "number";
  }
  e2.isNumber = z;
  function V(m) {
    return typeof m == "string";
  }
  e2.isString = V;
  function Ee(m) {
    return typeof m == "symbol";
  }
  e2.isSymbol = Ee;
  function ie(m) {
    return m === void 0;
  }
  e2.isUndefined = ie;
  function de(m) {
    return ce(m) && K(m) === "[object RegExp]";
  }
  e2.isRegExp = de, e2.types.isRegExp = de;
  function ce(m) {
    return typeof m == "object" && m !== null;
  }
  e2.isObject = ce;
  function he(m) {
    return ce(m) && K(m) === "[object Date]";
  }
  e2.isDate = he, e2.types.isDate = he;
  function ee(m) {
    return ce(m) && (K(m) === "[object Error]" || m instanceof Error);
  }
  e2.isError = ee, e2.types.isNativeError = ee;
  function ue(m) {
    return typeof m == "function";
  }
  e2.isFunction = ue;
  function ve(m) {
    return m === null || typeof m == "boolean" || typeof m == "number" || typeof m == "string" || typeof m == "symbol" || // ES6 symbol
    typeof m > "u";
  }
  e2.isPrimitive = ve, e2.isBuffer = Ha;
  function K(m) {
    return Object.prototype.toString.call(m);
  }
  function ge(m) {
    return m < 10 ? "0" + m.toString(10) : m.toString(10);
  }
  var me = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function h() {
    var m = /* @__PURE__ */ new Date(), A = [
      ge(m.getHours()),
      ge(m.getMinutes()),
      ge(m.getSeconds())
    ].join(":");
    return [m.getDate(), me[m.getMonth()], A].join(" ");
  }
  e2.log = function() {
    console.log("%s - %s", h(), e2.format.apply(e2, arguments));
  }, e2.inherits = Pe, e2._extend = function(m, A) {
    if (!A || !ce(A))
      return m;
    for (var B = Object.keys(A), D = B.length; D--; )
      m[B[D]] = A[B[D]];
    return m;
  };
  function y(m, A) {
    return Object.prototype.hasOwnProperty.call(m, A);
  }
  var b = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  e2.promisify = function(A) {
    if (typeof A != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (b && A[b]) {
      var B = A[b];
      if (typeof B != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(B, b, {
        value: B,
        enumerable: false,
        writable: false,
        configurable: true
      }), B;
    }
    function B() {
      for (var D, W, o = new Promise(function(_, $) {
        D = _, W = $;
      }), a = [], w = 0; w < arguments.length; w++)
        a.push(arguments[w]);
      a.push(function(_, $) {
        _ ? W(_) : D($);
      });
      try {
        A.apply(this, a);
      } catch (_) {
        W(_);
      }
      return o;
    }
    return Object.setPrototypeOf(B, Object.getPrototypeOf(A)), b && Object.defineProperty(B, b, {
      value: B,
      enumerable: false,
      writable: false,
      configurable: true
    }), Object.defineProperties(
      B,
      t(A)
    );
  }, e2.promisify.custom = b;
  function P(m, A) {
    if (!m) {
      var B = new Error("Promise was rejected with a falsy value");
      B.reason = m, m = B;
    }
    return A(m);
  }
  function I(m) {
    if (typeof m != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function A() {
      for (var B = [], D = 0; D < arguments.length; D++)
        B.push(arguments[D]);
      var W = B.pop();
      if (typeof W != "function")
        throw new TypeError("The last argument must be of type Function");
      var o = this, a = function() {
        return W.apply(o, arguments);
      };
      m.apply(this, B).then(
        function(w) {
          J.process.nextTick(a.bind(null, null, w));
        },
        function(w) {
          J.process.nextTick(P.bind(null, w, a));
        }
      );
    }
    return Object.setPrototypeOf(A, Object.getPrototypeOf(m)), Object.defineProperties(
      A,
      t(m)
    ), A;
  }
  e2.callbackify = I;
})(wt);
var lr = { exports: {} };
var un;
function Ga() {
  return un || (un = 1, function(e2) {
    function t(d, l) {
      if (!(d instanceof l))
        throw new TypeError("Cannot call a class as a function");
    }
    var n = Lr.Buffer, s = wt;
    function u(d, l, f) {
      d.copy(l, f);
    }
    e2.exports = function() {
      function d() {
        t(this, d), this.head = null, this.tail = null, this.length = 0;
      }
      return d.prototype.push = function(f) {
        var g = { data: f, next: null };
        this.length > 0 ? this.tail.next = g : this.head = g, this.tail = g, ++this.length;
      }, d.prototype.unshift = function(f) {
        var g = { data: f, next: this.head };
        this.length === 0 && (this.tail = g), this.head = g, ++this.length;
      }, d.prototype.shift = function() {
        if (this.length !== 0) {
          var f = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, f;
        }
      }, d.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, d.prototype.join = function(f) {
        if (this.length === 0)
          return "";
        for (var g = this.head, T = "" + g.data; g = g.next; )
          T += f + g.data;
        return T;
      }, d.prototype.concat = function(f) {
        if (this.length === 0)
          return n.alloc(0);
        for (var g = n.allocUnsafe(f >>> 0), T = this.head, F = 0; T; )
          u(T.data, g, F), F += T.data.length, T = T.next;
        return g;
      }, d;
    }(), s && s.inspect && s.inspect.custom && (e2.exports.prototype[s.inspect.custom] = function() {
      var d = s.inspect({ length: this.length });
      return this.constructor.name + " " + d;
    });
  }(lr)), lr.exports;
}
var Et = Ge;
function za(e2, t) {
  var n = this, s = this._readableState && this._readableState.destroyed, u = this._writableState && this._writableState.destroyed;
  return s || u ? (t ? t(e2) : e2 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, Et.nextTick(St, this, e2)) : Et.nextTick(St, this, e2)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(e2 || null, function(d) {
    !t && d ? n._writableState ? n._writableState.errorEmitted || (n._writableState.errorEmitted = true, Et.nextTick(St, n, d)) : Et.nextTick(St, n, d) : t && t(d);
  }), this);
}
function Ja() {
  this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
}
function St(e2, t) {
  e2.emit("error", t);
}
var ci = {
  destroy: za,
  undestroy: Ja
};
var li = Xa;
function Xa(e2, t) {
  if (dr("noDeprecation"))
    return e2;
  var n = false;
  function s() {
    if (!n) {
      if (dr("throwDeprecation"))
        throw new Error(t);
      dr("traceDeprecation") ? console.trace(t) : console.warn(t), n = true;
    }
    return e2.apply(this, arguments);
  }
  return s;
}
function dr(e2) {
  try {
    if (!te.localStorage)
      return false;
  } catch {
    return false;
  }
  var t = te.localStorage[e2];
  return t == null ? false : String(t).toLowerCase() === "true";
}
var hr;
var fn;
function di() {
  if (fn)
    return hr;
  fn = 1;
  var e2 = Ge;
  hr = N;
  function t(h) {
    var y = this;
    this.next = null, this.entry = null, this.finish = function() {
      me(y, h);
    };
  }
  var n = !J.process.browser && ["v0.10", "v0.9."].indexOf(J.process.version.slice(0, 5)) > -1 ? setImmediate : e2.nextTick, s;
  N.WritableState = U;
  var u = Object.create(re);
  u.inherits = Pe;
  var d = {
    deprecate: li
  }, l = Ln, f = Lr.Buffer, g = (typeof te < "u" ? te : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function T(h) {
    return f.from(h);
  }
  function F(h) {
    return f.isBuffer(h) || h instanceof g;
  }
  var E = ci;
  u.inherits(N, l);
  function j() {
  }
  function U(h, y) {
    s = s || ut(), h = h || {};
    var b = y instanceof s;
    this.objectMode = !!h.objectMode, b && (this.objectMode = this.objectMode || !!h.writableObjectMode);
    var P = h.highWaterMark, I = h.writableHighWaterMark, m = this.objectMode ? 16 : 16 * 1024;
    P || P === 0 ? this.highWaterMark = P : b && (I || I === 0) ? this.highWaterMark = I : this.highWaterMark = m, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    var A = h.decodeStrings === false;
    this.decodeStrings = !A, this.defaultEncoding = h.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(B) {
      ie(y, B);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  U.prototype.getBuffer = function() {
    for (var y = this.bufferedRequest, b = []; y; )
      b.push(y), y = y.next;
    return b;
  }, function() {
    try {
      Object.defineProperty(U.prototype, "buffer", {
        get: d.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var q;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (q = Function.prototype[Symbol.hasInstance], Object.defineProperty(N, Symbol.hasInstance, {
    value: function(h) {
      return q.call(this, h) ? true : this !== N ? false : h && h._writableState instanceof U;
    }
  })) : q = function(h) {
    return h instanceof this;
  };
  function N(h) {
    if (s = s || ut(), !q.call(N, this) && !(this instanceof s))
      return new N(h);
    this._writableState = new U(h, this), this.writable = true, h && (typeof h.write == "function" && (this._write = h.write), typeof h.writev == "function" && (this._writev = h.writev), typeof h.destroy == "function" && (this._destroy = h.destroy), typeof h.final == "function" && (this._final = h.final)), l.call(this);
  }
  N.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function Q(h, y) {
    var b = new Error("write after end");
    h.emit("error", b), e2.nextTick(y, b);
  }
  function x(h, y, b, P) {
    var I = true, m = false;
    return b === null ? m = new TypeError("May not write null values to stream") : typeof b != "string" && b !== void 0 && !y.objectMode && (m = new TypeError("Invalid non-string/buffer chunk")), m && (h.emit("error", m), e2.nextTick(P, m), I = false), I;
  }
  N.prototype.write = function(h, y, b) {
    var P = this._writableState, I = false, m = !P.objectMode && F(h);
    return m && !f.isBuffer(h) && (h = T(h)), typeof y == "function" && (b = y, y = null), m ? y = "buffer" : y || (y = P.defaultEncoding), typeof b != "function" && (b = j), P.ended ? Q(this, b) : (m || x(this, P, h, b)) && (P.pendingcb++, I = L(this, P, m, h, y, b)), I;
  }, N.prototype.cork = function() {
    var h = this._writableState;
    h.corked++;
  }, N.prototype.uncork = function() {
    var h = this._writableState;
    h.corked && (h.corked--, !h.writing && !h.corked && !h.bufferProcessing && h.bufferedRequest && he(this, h));
  }, N.prototype.setDefaultEncoding = function(y) {
    if (typeof y == "string" && (y = y.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((y + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + y);
    return this._writableState.defaultEncoding = y, this;
  };
  function R(h, y, b) {
    return !h.objectMode && h.decodeStrings !== false && typeof y == "string" && (y = f.from(y, b)), y;
  }
  Object.defineProperty(N.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function L(h, y, b, P, I, m) {
    if (!b) {
      var A = R(y, P, I);
      P !== A && (b = true, I = "buffer", P = A);
    }
    var B = y.objectMode ? 1 : P.length;
    y.length += B;
    var D = y.length < y.highWaterMark;
    if (D || (y.needDrain = true), y.writing || y.corked) {
      var W = y.lastBufferedRequest;
      y.lastBufferedRequest = {
        chunk: P,
        encoding: I,
        isBuf: b,
        callback: m,
        next: null
      }, W ? W.next = y.lastBufferedRequest : y.bufferedRequest = y.lastBufferedRequest, y.bufferedRequestCount += 1;
    } else
      z(h, y, false, B, P, I, m);
    return D;
  }
  function z(h, y, b, P, I, m, A) {
    y.writelen = P, y.writecb = A, y.writing = true, y.sync = true, b ? h._writev(I, y.onwrite) : h._write(I, m, y.onwrite), y.sync = false;
  }
  function V(h, y, b, P, I) {
    --y.pendingcb, b ? (e2.nextTick(I, P), e2.nextTick(K, h, y), h._writableState.errorEmitted = true, h.emit("error", P)) : (I(P), h._writableState.errorEmitted = true, h.emit("error", P), K(h, y));
  }
  function Ee(h) {
    h.writing = false, h.writecb = null, h.length -= h.writelen, h.writelen = 0;
  }
  function ie(h, y) {
    var b = h._writableState, P = b.sync, I = b.writecb;
    if (Ee(b), y)
      V(h, b, P, y, I);
    else {
      var m = ee(b);
      !m && !b.corked && !b.bufferProcessing && b.bufferedRequest && he(h, b), P ? n(de, h, b, m, I) : de(h, b, m, I);
    }
  }
  function de(h, y, b, P) {
    b || ce(h, y), y.pendingcb--, P(), K(h, y);
  }
  function ce(h, y) {
    y.length === 0 && y.needDrain && (y.needDrain = false, h.emit("drain"));
  }
  function he(h, y) {
    y.bufferProcessing = true;
    var b = y.bufferedRequest;
    if (h._writev && b && b.next) {
      var P = y.bufferedRequestCount, I = new Array(P), m = y.corkedRequestsFree;
      m.entry = b;
      for (var A = 0, B = true; b; )
        I[A] = b, b.isBuf || (B = false), b = b.next, A += 1;
      I.allBuffers = B, z(h, y, true, y.length, I, "", m.finish), y.pendingcb++, y.lastBufferedRequest = null, m.next ? (y.corkedRequestsFree = m.next, m.next = null) : y.corkedRequestsFree = new t(y), y.bufferedRequestCount = 0;
    } else {
      for (; b; ) {
        var D = b.chunk, W = b.encoding, o = b.callback, a = y.objectMode ? 1 : D.length;
        if (z(h, y, false, a, D, W, o), b = b.next, y.bufferedRequestCount--, y.writing)
          break;
      }
      b === null && (y.lastBufferedRequest = null);
    }
    y.bufferedRequest = b, y.bufferProcessing = false;
  }
  N.prototype._write = function(h, y, b) {
    b(new Error("_write() is not implemented"));
  }, N.prototype._writev = null, N.prototype.end = function(h, y, b) {
    var P = this._writableState;
    typeof h == "function" ? (b = h, h = null, y = null) : typeof y == "function" && (b = y, y = null), h != null && this.write(h, y), P.corked && (P.corked = 1, this.uncork()), P.ending || ge(this, P, b);
  };
  function ee(h) {
    return h.ending && h.length === 0 && h.bufferedRequest === null && !h.finished && !h.writing;
  }
  function ue(h, y) {
    h._final(function(b) {
      y.pendingcb--, b && h.emit("error", b), y.prefinished = true, h.emit("prefinish"), K(h, y);
    });
  }
  function ve(h, y) {
    !y.prefinished && !y.finalCalled && (typeof h._final == "function" ? (y.pendingcb++, y.finalCalled = true, e2.nextTick(ue, h, y)) : (y.prefinished = true, h.emit("prefinish")));
  }
  function K(h, y) {
    var b = ee(y);
    return b && (ve(h, y), y.pendingcb === 0 && (y.finished = true, h.emit("finish"))), b;
  }
  function ge(h, y, b) {
    y.ending = true, K(h, y), b && (y.finished ? e2.nextTick(b) : h.once("finish", b)), y.ended = true, h.writable = false;
  }
  function me(h, y, b) {
    var P = h.entry;
    for (h.entry = null; P; ) {
      var I = P.callback;
      y.pendingcb--, I(b), P = P.next;
    }
    y.corkedRequestsFree.next = h;
  }
  return Object.defineProperty(N.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? false : this._writableState.destroyed;
    },
    set: function(h) {
      this._writableState && (this._writableState.destroyed = h);
    }
  }), N.prototype.destroy = E.destroy, N.prototype._undestroy = E.undestroy, N.prototype._destroy = function(h, y) {
    this.end(), y(h);
  }, hr;
}
var pr;
var cn;
function ut() {
  if (cn)
    return pr;
  cn = 1;
  var e2 = Ge, t = Object.keys || function(E) {
    var j = [];
    for (var U in E)
      j.push(U);
    return j;
  };
  pr = g;
  var n = Object.create(re);
  n.inherits = Pe;
  var s = hi(), u = di();
  n.inherits(g, s);
  for (var d = t(u.prototype), l = 0; l < d.length; l++) {
    var f = d[l];
    g.prototype[f] || (g.prototype[f] = u.prototype[f]);
  }
  function g(E) {
    if (!(this instanceof g))
      return new g(E);
    s.call(this, E), u.call(this, E), E && E.readable === false && (this.readable = false), E && E.writable === false && (this.writable = false), this.allowHalfOpen = true, E && E.allowHalfOpen === false && (this.allowHalfOpen = false), this.once("end", T);
  }
  Object.defineProperty(g.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function T() {
    this.allowHalfOpen || this._writableState.ended || e2.nextTick(F, this);
  }
  function F(E) {
    E.end();
  }
  return Object.defineProperty(g.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? false : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(E) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = E, this._writableState.destroyed = E);
    }
  }), g.prototype._destroy = function(E, j) {
    this.push(null), this.end(), e2.nextTick(j, E);
  }, pr;
}
var yr = {};
var At = { exports: {} };
var ln;
function Ka() {
  return ln || (ln = 1, function(e2, t) {
    var n = ct, s = n.Buffer;
    function u(l, f) {
      for (var g in l)
        f[g] = l[g];
    }
    s.from && s.alloc && s.allocUnsafe && s.allocUnsafeSlow ? e2.exports = n : (u(n, t), t.Buffer = d);
    function d(l, f, g) {
      return s(l, f, g);
    }
    d.prototype = Object.create(s.prototype), u(s, d), d.from = function(l, f, g) {
      if (typeof l == "number")
        throw new TypeError("Argument must not be a number");
      return s(l, f, g);
    }, d.alloc = function(l, f, g) {
      if (typeof l != "number")
        throw new TypeError("Argument must be a number");
      var T = s(l);
      return f !== void 0 ? typeof g == "string" ? T.fill(f, g) : T.fill(f) : T.fill(0), T;
    }, d.allocUnsafe = function(l) {
      if (typeof l != "number")
        throw new TypeError("Argument must be a number");
      return s(l);
    }, d.allocUnsafeSlow = function(l) {
      if (typeof l != "number")
        throw new TypeError("Argument must be a number");
      return n.SlowBuffer(l);
    };
  }(At, At.exports)), At.exports;
}
var dn;
function kt() {
  if (dn)
    return yr;
  dn = 1;
  var e2 = Ka().Buffer, t = e2.isEncoding || function(x) {
    switch (x = "" + x, x && x.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function n(x) {
    if (!x)
      return "utf8";
    for (var R; ; )
      switch (x) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return x;
        default:
          if (R)
            return;
          x = ("" + x).toLowerCase(), R = true;
      }
  }
  function s(x) {
    var R = n(x);
    if (typeof R != "string" && (e2.isEncoding === t || !t(x)))
      throw new Error("Unknown encoding: " + x);
    return R || x;
  }
  yr.StringDecoder = u;
  function u(x) {
    this.encoding = s(x);
    var R;
    switch (this.encoding) {
      case "utf16le":
        this.text = E, this.end = j, R = 4;
        break;
      case "utf8":
        this.fillLast = g, R = 4;
        break;
      case "base64":
        this.text = U, this.end = q, R = 3;
        break;
      default:
        this.write = N, this.end = Q;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e2.allocUnsafe(R);
  }
  u.prototype.write = function(x) {
    if (x.length === 0)
      return "";
    var R, L;
    if (this.lastNeed) {
      if (R = this.fillLast(x), R === void 0)
        return "";
      L = this.lastNeed, this.lastNeed = 0;
    } else
      L = 0;
    return L < x.length ? R ? R + this.text(x, L) : this.text(x, L) : R || "";
  }, u.prototype.end = F, u.prototype.text = T, u.prototype.fillLast = function(x) {
    if (this.lastNeed <= x.length)
      return x.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    x.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, x.length), this.lastNeed -= x.length;
  };
  function d(x) {
    return x <= 127 ? 0 : x >> 5 === 6 ? 2 : x >> 4 === 14 ? 3 : x >> 3 === 30 ? 4 : x >> 6 === 2 ? -1 : -2;
  }
  function l(x, R, L) {
    var z = R.length - 1;
    if (z < L)
      return 0;
    var V = d(R[z]);
    return V >= 0 ? (V > 0 && (x.lastNeed = V - 1), V) : --z < L || V === -2 ? 0 : (V = d(R[z]), V >= 0 ? (V > 0 && (x.lastNeed = V - 2), V) : --z < L || V === -2 ? 0 : (V = d(R[z]), V >= 0 ? (V > 0 && (V === 2 ? V = 0 : x.lastNeed = V - 3), V) : 0));
  }
  function f(x, R, L) {
    if ((R[0] & 192) !== 128)
      return x.lastNeed = 0, "�";
    if (x.lastNeed > 1 && R.length > 1) {
      if ((R[1] & 192) !== 128)
        return x.lastNeed = 1, "�";
      if (x.lastNeed > 2 && R.length > 2 && (R[2] & 192) !== 128)
        return x.lastNeed = 2, "�";
    }
  }
  function g(x) {
    var R = this.lastTotal - this.lastNeed, L = f(this, x);
    if (L !== void 0)
      return L;
    if (this.lastNeed <= x.length)
      return x.copy(this.lastChar, R, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    x.copy(this.lastChar, R, 0, x.length), this.lastNeed -= x.length;
  }
  function T(x, R) {
    var L = l(this, x, R);
    if (!this.lastNeed)
      return x.toString("utf8", R);
    this.lastTotal = L;
    var z = x.length - (L - this.lastNeed);
    return x.copy(this.lastChar, 0, z), x.toString("utf8", R, z);
  }
  function F(x) {
    var R = x && x.length ? this.write(x) : "";
    return this.lastNeed ? R + "�" : R;
  }
  function E(x, R) {
    if ((x.length - R) % 2 === 0) {
      var L = x.toString("utf16le", R);
      if (L) {
        var z = L.charCodeAt(L.length - 1);
        if (z >= 55296 && z <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = x[x.length - 2], this.lastChar[1] = x[x.length - 1], L.slice(0, -1);
      }
      return L;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = x[x.length - 1], x.toString("utf16le", R, x.length - 1);
  }
  function j(x) {
    var R = x && x.length ? this.write(x) : "";
    if (this.lastNeed) {
      var L = this.lastTotal - this.lastNeed;
      return R + this.lastChar.toString("utf16le", 0, L);
    }
    return R;
  }
  function U(x, R) {
    var L = (x.length - R) % 3;
    return L === 0 ? x.toString("base64", R) : (this.lastNeed = 3 - L, this.lastTotal = 3, L === 1 ? this.lastChar[0] = x[x.length - 1] : (this.lastChar[0] = x[x.length - 2], this.lastChar[1] = x[x.length - 1]), x.toString("base64", R, x.length - L));
  }
  function q(x) {
    var R = x && x.length ? this.write(x) : "";
    return this.lastNeed ? R + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : R;
  }
  function N(x) {
    return x.toString(this.encoding);
  }
  function Q(x) {
    return x && x.length ? this.write(x) : "";
  }
  return yr;
}
var gr;
var hn;
function hi() {
  if (hn)
    return gr;
  hn = 1;
  var e2 = Ge;
  gr = R;
  var t = po, n;
  R.ReadableState = x, lt.EventEmitter;
  var s = function(o, a) {
    return o.listeners(a).length;
  }, u = Ln, d = Lr.Buffer, l = (typeof te < "u" ? te : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function f(o) {
    return d.from(o);
  }
  function g(o) {
    return d.isBuffer(o) || o instanceof l;
  }
  var T = Object.create(re);
  T.inherits = Pe;
  var F = wt, E = void 0;
  F && F.debuglog ? E = F.debuglog("stream") : E = function() {
  };
  var j = Ga(), U = ci, q;
  T.inherits(R, u);
  var N = ["error", "close", "destroy", "pause", "resume"];
  function Q(o, a, w) {
    if (typeof o.prependListener == "function")
      return o.prependListener(a, w);
    !o._events || !o._events[a] ? o.on(a, w) : t(o._events[a]) ? o._events[a].unshift(w) : o._events[a] = [w, o._events[a]];
  }
  function x(o, a) {
    n = n || ut(), o = o || {};
    var w = a instanceof n;
    this.objectMode = !!o.objectMode, w && (this.objectMode = this.objectMode || !!o.readableObjectMode);
    var _ = o.highWaterMark, $ = o.readableHighWaterMark, C = this.objectMode ? 16 : 16 * 1024;
    _ || _ === 0 ? this.highWaterMark = _ : w && ($ || $ === 0) ? this.highWaterMark = $ : this.highWaterMark = C, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new j(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.destroyed = false, this.defaultEncoding = o.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, o.encoding && (q || (q = kt().StringDecoder), this.decoder = new q(o.encoding), this.encoding = o.encoding);
  }
  function R(o) {
    if (n = n || ut(), !(this instanceof R))
      return new R(o);
    this._readableState = new x(o, this), this.readable = true, o && (typeof o.read == "function" && (this._read = o.read), typeof o.destroy == "function" && (this._destroy = o.destroy)), u.call(this);
  }
  Object.defineProperty(R.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? false : this._readableState.destroyed;
    },
    set: function(o) {
      this._readableState && (this._readableState.destroyed = o);
    }
  }), R.prototype.destroy = U.destroy, R.prototype._undestroy = U.undestroy, R.prototype._destroy = function(o, a) {
    this.push(null), a(o);
  }, R.prototype.push = function(o, a) {
    var w = this._readableState, _;
    return w.objectMode ? _ = true : typeof o == "string" && (a = a || w.defaultEncoding, a !== w.encoding && (o = d.from(o, a), a = ""), _ = true), L(this, o, a, false, _);
  }, R.prototype.unshift = function(o) {
    return L(this, o, null, true, false);
  };
  function L(o, a, w, _, $) {
    var C = o._readableState;
    if (a === null)
      C.reading = false, he(o, C);
    else {
      var k;
      $ || (k = V(C, a)), k ? o.emit("error", k) : C.objectMode || a && a.length > 0 ? (typeof a != "string" && !C.objectMode && Object.getPrototypeOf(a) !== d.prototype && (a = f(a)), _ ? C.endEmitted ? o.emit("error", new Error("stream.unshift() after end event")) : z(o, C, a, true) : C.ended ? o.emit("error", new Error("stream.push() after EOF")) : (C.reading = false, C.decoder && !w ? (a = C.decoder.write(a), C.objectMode || a.length !== 0 ? z(o, C, a, false) : ve(o, C)) : z(o, C, a, false))) : _ || (C.reading = false);
    }
    return Ee(C);
  }
  function z(o, a, w, _) {
    a.flowing && a.length === 0 && !a.sync ? (o.emit("data", w), o.read(0)) : (a.length += a.objectMode ? 1 : w.length, _ ? a.buffer.unshift(w) : a.buffer.push(w), a.needReadable && ee(o)), ve(o, a);
  }
  function V(o, a) {
    var w;
    return !g(a) && typeof a != "string" && a !== void 0 && !o.objectMode && (w = new TypeError("Invalid non-string/buffer chunk")), w;
  }
  function Ee(o) {
    return !o.ended && (o.needReadable || o.length < o.highWaterMark || o.length === 0);
  }
  R.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  }, R.prototype.setEncoding = function(o) {
    return q || (q = kt().StringDecoder), this._readableState.decoder = new q(o), this._readableState.encoding = o, this;
  };
  var ie = 8388608;
  function de(o) {
    return o >= ie ? o = ie : (o--, o |= o >>> 1, o |= o >>> 2, o |= o >>> 4, o |= o >>> 8, o |= o >>> 16, o++), o;
  }
  function ce(o, a) {
    return o <= 0 || a.length === 0 && a.ended ? 0 : a.objectMode ? 1 : o !== o ? a.flowing && a.length ? a.buffer.head.data.length : a.length : (o > a.highWaterMark && (a.highWaterMark = de(o)), o <= a.length ? o : a.ended ? a.length : (a.needReadable = true, 0));
  }
  R.prototype.read = function(o) {
    E("read", o), o = parseInt(o, 10);
    var a = this._readableState, w = o;
    if (o !== 0 && (a.emittedReadable = false), o === 0 && a.needReadable && (a.length >= a.highWaterMark || a.ended))
      return E("read: emitReadable", a.length, a.ended), a.length === 0 && a.ended ? B(this) : ee(this), null;
    if (o = ce(o, a), o === 0 && a.ended)
      return a.length === 0 && B(this), null;
    var _ = a.needReadable;
    E("need readable", _), (a.length === 0 || a.length - o < a.highWaterMark) && (_ = true, E("length less than watermark", _)), a.ended || a.reading ? (_ = false, E("reading or ended", _)) : _ && (E("do read"), a.reading = true, a.sync = true, a.length === 0 && (a.needReadable = true), this._read(a.highWaterMark), a.sync = false, a.reading || (o = ce(w, a)));
    var $;
    return o > 0 ? $ = P(o, a) : $ = null, $ === null ? (a.needReadable = true, o = 0) : a.length -= o, a.length === 0 && (a.ended || (a.needReadable = true), w !== o && a.ended && B(this)), $ !== null && this.emit("data", $), $;
  };
  function he(o, a) {
    if (!a.ended) {
      if (a.decoder) {
        var w = a.decoder.end();
        w && w.length && (a.buffer.push(w), a.length += a.objectMode ? 1 : w.length);
      }
      a.ended = true, ee(o);
    }
  }
  function ee(o) {
    var a = o._readableState;
    a.needReadable = false, a.emittedReadable || (E("emitReadable", a.flowing), a.emittedReadable = true, a.sync ? e2.nextTick(ue, o) : ue(o));
  }
  function ue(o) {
    E("emit readable"), o.emit("readable"), b(o);
  }
  function ve(o, a) {
    a.readingMore || (a.readingMore = true, e2.nextTick(K, o, a));
  }
  function K(o, a) {
    for (var w = a.length; !a.reading && !a.flowing && !a.ended && a.length < a.highWaterMark && (E("maybeReadMore read 0"), o.read(0), w !== a.length); )
      w = a.length;
    a.readingMore = false;
  }
  R.prototype._read = function(o) {
    this.emit("error", new Error("_read() is not implemented"));
  }, R.prototype.pipe = function(o, a) {
    var w = this, _ = this._readableState;
    switch (_.pipesCount) {
      case 0:
        _.pipes = o;
        break;
      case 1:
        _.pipes = [_.pipes, o];
        break;
      default:
        _.pipes.push(o);
        break;
    }
    _.pipesCount += 1, E("pipe count=%d opts=%j", _.pipesCount, a);
    var $ = (!a || a.end !== false) && o !== J.process.stdout && o !== J.process.stderr, C = $ ? oe : be;
    _.endEmitted ? e2.nextTick(C) : w.once("end", C), o.on("unpipe", k);
    function k(_e, le) {
      E("onunpipe"), _e === w && le && le.hasUnpiped === false && (le.hasUnpiped = true, Ne());
    }
    function oe() {
      E("onend"), o.end();
    }
    var Se = ge(w);
    o.on("drain", Se);
    var Ce = false;
    function Ne() {
      E("cleanup"), o.removeListener("close", Ae), o.removeListener("finish", pe), o.removeListener("drain", Se), o.removeListener("error", xe), o.removeListener("unpipe", k), w.removeListener("end", oe), w.removeListener("end", be), w.removeListener("data", O), Ce = true, _.awaitDrain && (!o._writableState || o._writableState.needDrain) && Se();
    }
    var Be = false;
    w.on("data", O);
    function O(_e) {
      E("ondata"), Be = false;
      var le = o.write(_e);
      le === false && !Be && ((_.pipesCount === 1 && _.pipes === o || _.pipesCount > 1 && W(_.pipes, o) !== -1) && !Ce && (E("false write response, pause", _.awaitDrain), _.awaitDrain++, Be = true), w.pause());
    }
    function xe(_e) {
      E("onerror", _e), be(), o.removeListener("error", xe), s(o, "error") === 0 && o.emit("error", _e);
    }
    Q(o, "error", xe);
    function Ae() {
      o.removeListener("finish", pe), be();
    }
    o.once("close", Ae);
    function pe() {
      E("onfinish"), o.removeListener("close", Ae), be();
    }
    o.once("finish", pe);
    function be() {
      E("unpipe"), w.unpipe(o);
    }
    return o.emit("pipe", w), _.flowing || (E("pipe resume"), w.resume()), o;
  };
  function ge(o) {
    return function() {
      var a = o._readableState;
      E("pipeOnDrain", a.awaitDrain), a.awaitDrain && a.awaitDrain--, a.awaitDrain === 0 && s(o, "data") && (a.flowing = true, b(o));
    };
  }
  R.prototype.unpipe = function(o) {
    var a = this._readableState, w = { hasUnpiped: false };
    if (a.pipesCount === 0)
      return this;
    if (a.pipesCount === 1)
      return o && o !== a.pipes ? this : (o || (o = a.pipes), a.pipes = null, a.pipesCount = 0, a.flowing = false, o && o.emit("unpipe", this, w), this);
    if (!o) {
      var _ = a.pipes, $ = a.pipesCount;
      a.pipes = null, a.pipesCount = 0, a.flowing = false;
      for (var C = 0; C < $; C++)
        _[C].emit("unpipe", this, { hasUnpiped: false });
      return this;
    }
    var k = W(a.pipes, o);
    return k === -1 ? this : (a.pipes.splice(k, 1), a.pipesCount -= 1, a.pipesCount === 1 && (a.pipes = a.pipes[0]), o.emit("unpipe", this, w), this);
  }, R.prototype.on = function(o, a) {
    var w = u.prototype.on.call(this, o, a);
    if (o === "data")
      this._readableState.flowing !== false && this.resume();
    else if (o === "readable") {
      var _ = this._readableState;
      !_.endEmitted && !_.readableListening && (_.readableListening = _.needReadable = true, _.emittedReadable = false, _.reading ? _.length && ee(this) : e2.nextTick(me, this));
    }
    return w;
  }, R.prototype.addListener = R.prototype.on;
  function me(o) {
    E("readable nexttick read 0"), o.read(0);
  }
  R.prototype.resume = function() {
    var o = this._readableState;
    return o.flowing || (E("resume"), o.flowing = true, h(this, o)), this;
  };
  function h(o, a) {
    a.resumeScheduled || (a.resumeScheduled = true, e2.nextTick(y, o, a));
  }
  function y(o, a) {
    a.reading || (E("resume read 0"), o.read(0)), a.resumeScheduled = false, a.awaitDrain = 0, o.emit("resume"), b(o), a.flowing && !a.reading && o.read(0);
  }
  R.prototype.pause = function() {
    return E("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (E("pause"), this._readableState.flowing = false, this.emit("pause")), this;
  };
  function b(o) {
    var a = o._readableState;
    for (E("flow", a.flowing); a.flowing && o.read() !== null; )
      ;
  }
  R.prototype.wrap = function(o) {
    var a = this, w = this._readableState, _ = false;
    o.on("end", function() {
      if (E("wrapped end"), w.decoder && !w.ended) {
        var k = w.decoder.end();
        k && k.length && a.push(k);
      }
      a.push(null);
    }), o.on("data", function(k) {
      if (E("wrapped data"), w.decoder && (k = w.decoder.write(k)), !(w.objectMode && k == null) && !(!w.objectMode && (!k || !k.length))) {
        var oe = a.push(k);
        oe || (_ = true, o.pause());
      }
    });
    for (var $ in o)
      this[$] === void 0 && typeof o[$] == "function" && (this[$] = /* @__PURE__ */ function(k) {
        return function() {
          return o[k].apply(o, arguments);
        };
      }($));
    for (var C = 0; C < N.length; C++)
      o.on(N[C], this.emit.bind(this, N[C]));
    return this._read = function(k) {
      E("wrapped _read", k), _ && (_ = false, o.resume());
    }, this;
  }, Object.defineProperty(R.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), R._fromList = P;
  function P(o, a) {
    if (a.length === 0)
      return null;
    var w;
    return a.objectMode ? w = a.buffer.shift() : !o || o >= a.length ? (a.decoder ? w = a.buffer.join("") : a.buffer.length === 1 ? w = a.buffer.head.data : w = a.buffer.concat(a.length), a.buffer.clear()) : w = I(o, a.buffer, a.decoder), w;
  }
  function I(o, a, w) {
    var _;
    return o < a.head.data.length ? (_ = a.head.data.slice(0, o), a.head.data = a.head.data.slice(o)) : o === a.head.data.length ? _ = a.shift() : _ = w ? m(o, a) : A(o, a), _;
  }
  function m(o, a) {
    var w = a.head, _ = 1, $ = w.data;
    for (o -= $.length; w = w.next; ) {
      var C = w.data, k = o > C.length ? C.length : o;
      if (k === C.length ? $ += C : $ += C.slice(0, o), o -= k, o === 0) {
        k === C.length ? (++_, w.next ? a.head = w.next : a.head = a.tail = null) : (a.head = w, w.data = C.slice(k));
        break;
      }
      ++_;
    }
    return a.length -= _, $;
  }
  function A(o, a) {
    var w = d.allocUnsafe(o), _ = a.head, $ = 1;
    for (_.data.copy(w), o -= _.data.length; _ = _.next; ) {
      var C = _.data, k = o > C.length ? C.length : o;
      if (C.copy(w, w.length - o, 0, k), o -= k, o === 0) {
        k === C.length ? (++$, _.next ? a.head = _.next : a.head = a.tail = null) : (a.head = _, _.data = C.slice(k));
        break;
      }
      ++$;
    }
    return a.length -= $, w;
  }
  function B(o) {
    var a = o._readableState;
    if (a.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    a.endEmitted || (a.ended = true, e2.nextTick(D, a, o));
  }
  function D(o, a) {
    !o.endEmitted && o.length === 0 && (o.endEmitted = true, a.readable = false, a.emit("end"));
  }
  function W(o, a) {
    for (var w = 0, _ = o.length; w < _; w++)
      if (o[w] === a)
        return w;
    return -1;
  }
  return gr;
}
var pi = Le;
var Ht = ut();
var yi = Object.create(re);
yi.inherits = Pe;
yi.inherits(Le, Ht);
function Ya(e2, t) {
  var n = this._transformState;
  n.transforming = false;
  var s = n.writecb;
  if (!s)
    return this.emit("error", new Error("write callback called multiple times"));
  n.writechunk = null, n.writecb = null, t != null && this.push(t), s(e2);
  var u = this._readableState;
  u.reading = false, (u.needReadable || u.length < u.highWaterMark) && this._read(u.highWaterMark);
}
function Le(e2) {
  if (!(this instanceof Le))
    return new Le(e2);
  Ht.call(this, e2), this._transformState = {
    afterTransform: Ya.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = true, this._readableState.sync = false, e2 && (typeof e2.transform == "function" && (this._transform = e2.transform), typeof e2.flush == "function" && (this._flush = e2.flush)), this.on("prefinish", Za);
}
function Za() {
  var e2 = this;
  typeof this._flush == "function" ? this._flush(function(t, n) {
    pn(e2, t, n);
  }) : pn(this, null, null);
}
Le.prototype.push = function(e2, t) {
  return this._transformState.needTransform = false, Ht.prototype.push.call(this, e2, t);
};
Le.prototype._transform = function(e2, t, n) {
  throw new Error("_transform() is not implemented");
};
Le.prototype._write = function(e2, t, n) {
  var s = this._transformState;
  if (s.writecb = n, s.writechunk = e2, s.writeencoding = t, !s.transforming) {
    var u = this._readableState;
    (s.needTransform || u.needReadable || u.length < u.highWaterMark) && this._read(u.highWaterMark);
  }
};
Le.prototype._read = function(e2) {
  var t = this._transformState;
  t.writechunk !== null && t.writecb && !t.transforming ? (t.transforming = true, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = true;
};
Le.prototype._destroy = function(e2, t) {
  var n = this;
  Ht.prototype._destroy.call(this, e2, function(s) {
    t(s), n.emit("close");
  });
};
function pn(e2, t, n) {
  if (t)
    return e2.emit("error", t);
  if (n != null && e2.push(n), e2._writableState.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (e2._transformState.transforming)
    throw new Error("Calling transform done when still transforming");
  return e2.push(null);
}
var Qa = pt;
var gi = pi;
var mi = Object.create(re);
mi.inherits = Pe;
mi.inherits(pt, gi);
function pt(e2) {
  if (!(this instanceof pt))
    return new pt(e2);
  gi.call(this, e2);
}
pt.prototype._transform = function(e2, t, n) {
  n(null, e2);
};
(function(e2, t) {
  t = e2.exports = hi(), t.Stream = t, t.Readable = t, t.Writable = di(), t.Duplex = ut(), t.Transform = pi, t.PassThrough = Qa;
})(Sr, Sr.exports);
var wi = Sr.exports;
var Gr = { exports: {} };
var es = vi;
function vi(e2, t) {
  if (e2 && t)
    return vi(e2)(t);
  if (typeof e2 != "function")
    throw new TypeError("need wrapper function");
  return Object.keys(e2).forEach(function(s) {
    n[s] = e2[s];
  }), n;
  function n() {
    for (var s = new Array(arguments.length), u = 0; u < s.length; u++)
      s[u] = arguments[u];
    var d = e2.apply(this, s), l = s[s.length - 1];
    return typeof d == "function" && d !== l && Object.keys(l).forEach(function(f) {
      d[f] = l[f];
    }), d;
  }
}
var bi = es;
Gr.exports = bi(It);
Gr.exports.strict = bi(_i);
It.proto = It(function() {
  Object.defineProperty(Function.prototype, "once", {
    value: function() {
      return It(this);
    },
    configurable: true
  }), Object.defineProperty(Function.prototype, "onceStrict", {
    value: function() {
      return _i(this);
    },
    configurable: true
  });
});
function It(e2) {
  var t = function() {
    return t.called ? t.value : (t.called = true, t.value = e2.apply(this, arguments));
  };
  return t.called = false, t;
}
function _i(e2) {
  var t = function() {
    if (t.called)
      throw new Error(t.onceError);
    return t.called = true, t.value = e2.apply(this, arguments);
  }, n = e2.name || "Function wrapped with `once`";
  return t.onceError = n + " shouldn't be called more than once", t.called = false, t;
}
var zr = Gr.exports;
var ts = zr;
var rs = function() {
};
var ns = function(e2) {
  return e2.setHeader && typeof e2.abort == "function";
};
var is = function(e2) {
  return e2.stdio && Array.isArray(e2.stdio) && e2.stdio.length === 3;
};
var Ei = function(e2, t, n) {
  if (typeof t == "function")
    return Ei(e2, null, t);
  t || (t = {}), n = ts(n || rs);
  var s = e2._writableState, u = e2._readableState, d = t.readable || t.readable !== false && e2.readable, l = t.writable || t.writable !== false && e2.writable, f = false, g = function() {
    e2.writable || T();
  }, T = function() {
    l = false, d || n.call(e2);
  }, F = function() {
    d = false, l || n.call(e2);
  }, E = function(Q) {
    n.call(e2, Q ? new Error("exited with error code: " + Q) : null);
  }, j = function(Q) {
    n.call(e2, Q);
  }, U = function() {
    J.process.nextTick(q);
  }, q = function() {
    if (!f) {
      if (d && !(u && u.ended && !u.destroyed))
        return n.call(e2, new Error("premature close"));
      if (l && !(s && s.ended && !s.destroyed))
        return n.call(e2, new Error("premature close"));
    }
  }, N = function() {
    e2.req.on("finish", T);
  };
  return ns(e2) ? (e2.on("complete", T), e2.on("abort", U), e2.req ? N() : e2.on("request", N)) : l && !s && (e2.on("end", g), e2.on("close", g)), is(e2) && e2.on("exit", E), e2.on("end", F), e2.on("finish", T), t.error !== false && e2.on("error", j), e2.on("close", U), function() {
    f = true, e2.removeListener("complete", T), e2.removeListener("abort", U), e2.removeListener("request", N), e2.req && e2.req.removeListener("finish", T), e2.removeListener("end", g), e2.removeListener("close", g), e2.removeListener("finish", T), e2.removeListener("exit", E), e2.removeListener("end", F), e2.removeListener("error", j), e2.removeListener("close", U);
  };
};
var Si = Ei;
var Gt = {};
Object.defineProperty(Gt, "__esModule", { value: true });
Gt.Substream = void 0;
var os = wi;
var as = class extends os.Duplex {
  constructor({ parent: t, name: n }) {
    super({ objectMode: true }), this._parent = t, this._name = n;
  }
  /**
   * Explicitly sets read operations to a no-op.
   */
  _read() {
  }
  /**
   * Called when data should be written to this writable stream.
   *
   * @param chunk - Arbitrary object to write
   * @param encoding - Encoding to use when writing payload
   * @param callback - Called when writing is complete or an error occurs
   */
  _write(t, n, s) {
    this._parent.push({
      name: this._name,
      data: t
    }), s();
  }
};
Gt.Substream = as;
var Ai = te && te.__importDefault || function(e2) {
  return e2 && e2.__esModule ? e2 : { default: e2 };
};
Object.defineProperty(Ut, "__esModule", { value: true });
Ut.ObjectMultiplex = void 0;
var ss = wi;
var yn = Ai(Si);
var us = Ai(zr);
var fs = Gt;
var gn = Symbol("IGNORE_SUBSTREAM");
var cs = class extends ss.Duplex {
  constructor(t = {}) {
    super(Object.assign(Object.assign({}, t), { objectMode: true })), this._substreams = {};
  }
  createStream(t) {
    if (this.destroyed)
      throw new Error(`ObjectMultiplex - parent stream for name "${t}" already destroyed`);
    if (this._readableState.ended || this._writableState.ended)
      throw new Error(`ObjectMultiplex - parent stream for name "${t}" already ended`);
    if (!t)
      throw new Error("ObjectMultiplex - name must not be empty");
    if (this._substreams[t])
      throw new Error(`ObjectMultiplex - Substream for name "${t}" already exists`);
    const n = new fs.Substream({ parent: this, name: t });
    return this._substreams[t] = n, ls(this, (s) => n.destroy(s || void 0)), n;
  }
  // ignore streams (dont display orphaned data warning)
  ignoreStream(t) {
    if (!t)
      throw new Error("ObjectMultiplex - name must not be empty");
    if (this._substreams[t])
      throw new Error(`ObjectMultiplex - Substream for name "${t}" already exists`);
    this._substreams[t] = gn;
  }
  _read() {
  }
  _write(t, n, s) {
    const { name: u, data: d } = t;
    if (!u)
      return console.warn(`ObjectMultiplex - malformed chunk without name "${t}"`), s();
    const l = this._substreams[u];
    return l ? (l !== gn && l.push(d), s()) : (console.warn(`ObjectMultiplex - orphaned data for stream "${u}"`), s());
  }
};
Ut.ObjectMultiplex = cs;
function ls(e2, t) {
  const n = us.default(t);
  yn.default(e2, { readable: false }, n), yn.default(e2, { writable: false }, n);
}
var ds = Ut;
var hs = ds.ObjectMultiplex;
var ps = Tn(hs);
var xi = {};
Object.defineProperty(xi, "__esModule", { value: true });
var ys = {
  errors: {
    disconnected: () => "MetaMask: Disconnected from chain. Attempting to connect.",
    permanentlyDisconnected: () => "MetaMask: Disconnected from MetaMask background. Page reload required.",
    sendSiteMetadata: () => "MetaMask: Failed to send site metadata. This is an internal error, please report this bug.",
    unsupportedSync: (e2) => `MetaMask: The MetaMask Ethereum provider does not support synchronous methods like ${e2} without a callback parameter.`,
    invalidDuplexStream: () => "Must provide a Node.js-style duplex stream.",
    invalidRequestArgs: () => "Expected a single, non-array, object argument.",
    invalidRequestMethod: () => "'args.method' must be a non-empty string.",
    invalidRequestParams: () => "'args.params' must be an object or array if provided.",
    invalidLoggerObject: () => "'args.logger' must be an object if provided.",
    invalidLoggerMethod: (e2) => `'args.logger' must include required method '${e2}'.`
  },
  info: {
    connected: (e2) => `MetaMask: Connected to chain with ID "${e2}".`
  },
  warnings: {
    // deprecated methods
    enableDeprecation: `MetaMask: 'ethereum.enable()' is deprecated and may be removed in the future. Please use the 'eth_requestAccounts' RPC method instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1102`,
    sendDeprecation: `MetaMask: 'ethereum.send(...)' is deprecated and may be removed in the future. Please use 'ethereum.sendAsync(...)' or 'ethereum.request(...)' instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1193`,
    // deprecated events
    events: {
      close: `MetaMask: The event 'close' is deprecated and may be removed in the future. Please use 'disconnect' instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1193#disconnect`,
      data: `MetaMask: The event 'data' is deprecated and will be removed in the future. Use 'message' instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1193#message`,
      networkChanged: `MetaMask: The event 'networkChanged' is deprecated and may be removed in the future. Use 'chainChanged' instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1193#chainchanged`,
      notification: `MetaMask: The event 'notification' is deprecated and may be removed in the future. Use 'message' instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1193#message`
    },
    // misc
    experimentalMethods: "MetaMask: 'ethereum._metamask' exposes non-standard, experimental methods. They may be removed or changed without warning."
  }
};
var dt = xi.default = ys;
var Oe = {};
var ot = {};
var Ve = {};
var gs = yt;
yt.default = yt;
yt.stable = Mi;
yt.stableStringify = Mi;
var $t = "[...]";
var Ri = "[Circular]";
var Ye = [];
var Je = [];
function Ti() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function yt(e2, t, n, s) {
  typeof s > "u" && (s = Ti()), Ir(e2, "", 0, [], void 0, 0, s);
  var u;
  try {
    Je.length === 0 ? u = JSON.stringify(e2, t, n) : u = JSON.stringify(e2, Bi(t), n);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; Ye.length !== 0; ) {
      var d = Ye.pop();
      d.length === 4 ? Object.defineProperty(d[0], d[1], d[3]) : d[0][d[1]] = d[2];
    }
  }
  return u;
}
function at(e2, t, n, s) {
  var u = Object.getOwnPropertyDescriptor(s, n);
  u.get !== void 0 ? u.configurable ? (Object.defineProperty(s, n, { value: e2 }), Ye.push([s, n, t, u])) : Je.push([t, n, e2]) : (s[n] = e2, Ye.push([s, n, t]));
}
function Ir(e2, t, n, s, u, d, l) {
  d += 1;
  var f;
  if (typeof e2 == "object" && e2 !== null) {
    for (f = 0; f < s.length; f++)
      if (s[f] === e2) {
        at(Ri, e2, t, u);
        return;
      }
    if (typeof l.depthLimit < "u" && d > l.depthLimit) {
      at($t, e2, t, u);
      return;
    }
    if (typeof l.edgesLimit < "u" && n + 1 > l.edgesLimit) {
      at($t, e2, t, u);
      return;
    }
    if (s.push(e2), Array.isArray(e2))
      for (f = 0; f < e2.length; f++)
        Ir(e2[f], f, f, s, e2, d, l);
    else {
      var g = Object.keys(e2);
      for (f = 0; f < g.length; f++) {
        var T = g[f];
        Ir(e2[T], T, f, s, e2, d, l);
      }
    }
    s.pop();
  }
}
function ms(e2, t) {
  return e2 < t ? -1 : e2 > t ? 1 : 0;
}
function Mi(e2, t, n, s) {
  typeof s > "u" && (s = Ti());
  var u = jr(e2, "", 0, [], void 0, 0, s) || e2, d;
  try {
    Je.length === 0 ? d = JSON.stringify(u, t, n) : d = JSON.stringify(u, Bi(t), n);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; Ye.length !== 0; ) {
      var l = Ye.pop();
      l.length === 4 ? Object.defineProperty(l[0], l[1], l[3]) : l[0][l[1]] = l[2];
    }
  }
  return d;
}
function jr(e2, t, n, s, u, d, l) {
  d += 1;
  var f;
  if (typeof e2 == "object" && e2 !== null) {
    for (f = 0; f < s.length; f++)
      if (s[f] === e2) {
        at(Ri, e2, t, u);
        return;
      }
    try {
      if (typeof e2.toJSON == "function")
        return;
    } catch {
      return;
    }
    if (typeof l.depthLimit < "u" && d > l.depthLimit) {
      at($t, e2, t, u);
      return;
    }
    if (typeof l.edgesLimit < "u" && n + 1 > l.edgesLimit) {
      at($t, e2, t, u);
      return;
    }
    if (s.push(e2), Array.isArray(e2))
      for (f = 0; f < e2.length; f++)
        jr(e2[f], f, f, s, e2, d, l);
    else {
      var g = {}, T = Object.keys(e2).sort(ms);
      for (f = 0; f < T.length; f++) {
        var F = T[f];
        jr(e2[F], F, f, s, e2, d, l), g[F] = e2[F];
      }
      if (typeof u < "u")
        Ye.push([u, t, e2]), u[t] = g;
      else
        return g;
    }
    s.pop();
  }
}
function Bi(e2) {
  return e2 = typeof e2 < "u" ? e2 : function(t, n) {
    return n;
  }, function(t, n) {
    if (Je.length > 0)
      for (var s = 0; s < Je.length; s++) {
        var u = Je[s];
        if (u[1] === t && u[0] === n) {
          n = u[2], Je.splice(s, 1);
          break;
        }
      }
    return e2.call(this, t, n);
  };
}
Object.defineProperty(Ve, "__esModule", { value: true });
Ve.EthereumProviderError = Ve.EthereumRpcError = void 0;
var ws = gs;
var Oi = class extends Error {
  constructor(t, n, s) {
    if (!Number.isInteger(t))
      throw new Error('"code" must be an integer.');
    if (!n || typeof n != "string")
      throw new Error('"message" must be a nonempty string.');
    super(n), this.code = t, s !== void 0 && (this.data = s);
  }
  /**
   * Returns a plain object with all public class properties.
   */
  serialize() {
    const t = {
      code: this.code,
      message: this.message
    };
    return this.data !== void 0 && (t.data = this.data), this.stack && (t.stack = this.stack), t;
  }
  /**
   * Return a string representation of the serialized error, omitting
   * any circular references.
   */
  toString() {
    return ws.default(this.serialize(), _s, 2);
  }
};
Ve.EthereumRpcError = Oi;
var vs = class extends Oi {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(t, n, s) {
    if (!bs(t))
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(t, n, s);
  }
};
Ve.EthereumProviderError = vs;
function bs(e2) {
  return Number.isInteger(e2) && e2 >= 1e3 && e2 <= 4999;
}
function _s(e2, t) {
  if (t !== "[Circular]")
    return t;
}
var Jr = {};
var He = {};
Object.defineProperty(He, "__esModule", { value: true });
He.errorValues = He.errorCodes = void 0;
He.errorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901
  }
};
He.errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  4001: {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  4100: {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  4200: {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  4900: {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  4901: {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  }
};
(function(e2) {
  Object.defineProperty(e2, "__esModule", { value: true }), e2.serializeError = e2.isValidCode = e2.getMessageFromCode = e2.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const t = He, n = Ve, s = t.errorCodes.rpc.internal, u = "Unspecified error message. This is a bug, please report it.", d = {
    code: s,
    message: l(s)
  };
  e2.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
  function l(j, U = u) {
    if (Number.isInteger(j)) {
      const q = j.toString();
      if (E(t.errorValues, q))
        return t.errorValues[q].message;
      if (T(j))
        return e2.JSON_RPC_SERVER_ERROR_MESSAGE;
    }
    return U;
  }
  e2.getMessageFromCode = l;
  function f(j) {
    if (!Number.isInteger(j))
      return false;
    const U = j.toString();
    return !!(t.errorValues[U] || T(j));
  }
  e2.isValidCode = f;
  function g(j, { fallbackError: U = d, shouldIncludeStack: q = false } = {}) {
    var N, Q;
    if (!U || !Number.isInteger(U.code) || typeof U.message != "string")
      throw new Error("Must provide fallback error with integer number code and string message.");
    if (j instanceof n.EthereumRpcError)
      return j.serialize();
    const x = {};
    if (j && typeof j == "object" && !Array.isArray(j) && E(j, "code") && f(j.code)) {
      const L = j;
      x.code = L.code, L.message && typeof L.message == "string" ? (x.message = L.message, E(L, "data") && (x.data = L.data)) : (x.message = l(x.code), x.data = { originalError: F(j) });
    } else {
      x.code = U.code;
      const L = (N = j) === null || N === void 0 ? void 0 : N.message;
      x.message = L && typeof L == "string" ? L : U.message, x.data = { originalError: F(j) };
    }
    const R = (Q = j) === null || Q === void 0 ? void 0 : Q.stack;
    return q && j && R && typeof R == "string" && (x.stack = R), x;
  }
  e2.serializeError = g;
  function T(j) {
    return j >= -32099 && j <= -32e3;
  }
  function F(j) {
    return j && typeof j == "object" && !Array.isArray(j) ? Object.assign({}, j) : j;
  }
  function E(j, U) {
    return Object.prototype.hasOwnProperty.call(j, U);
  }
})(Jr);
var zt = {};
Object.defineProperty(zt, "__esModule", { value: true });
zt.ethErrors = void 0;
var Xr = Ve;
var Pi = Jr;
var we = He;
zt.ethErrors = {
  rpc: {
    /**
     * Get a JSON RPC 2.0 Parse (-32700) error.
     */
    parse: (e2) => Re(we.errorCodes.rpc.parse, e2),
    /**
     * Get a JSON RPC 2.0 Invalid Request (-32600) error.
     */
    invalidRequest: (e2) => Re(we.errorCodes.rpc.invalidRequest, e2),
    /**
     * Get a JSON RPC 2.0 Invalid Params (-32602) error.
     */
    invalidParams: (e2) => Re(we.errorCodes.rpc.invalidParams, e2),
    /**
     * Get a JSON RPC 2.0 Method Not Found (-32601) error.
     */
    methodNotFound: (e2) => Re(we.errorCodes.rpc.methodNotFound, e2),
    /**
     * Get a JSON RPC 2.0 Internal (-32603) error.
     */
    internal: (e2) => Re(we.errorCodes.rpc.internal, e2),
    /**
     * Get a JSON RPC 2.0 Server error.
     * Permits integer error codes in the [ -32099 <= -32005 ] range.
     * Codes -32000 through -32004 are reserved by EIP-1474.
     */
    server: (e2) => {
      if (!e2 || typeof e2 != "object" || Array.isArray(e2))
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      const { code: t } = e2;
      if (!Number.isInteger(t) || t > -32005 || t < -32099)
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      return Re(t, e2);
    },
    /**
     * Get an Ethereum JSON RPC Invalid Input (-32000) error.
     */
    invalidInput: (e2) => Re(we.errorCodes.rpc.invalidInput, e2),
    /**
     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
     */
    resourceNotFound: (e2) => Re(we.errorCodes.rpc.resourceNotFound, e2),
    /**
     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
     */
    resourceUnavailable: (e2) => Re(we.errorCodes.rpc.resourceUnavailable, e2),
    /**
     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
     */
    transactionRejected: (e2) => Re(we.errorCodes.rpc.transactionRejected, e2),
    /**
     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
     */
    methodNotSupported: (e2) => Re(we.errorCodes.rpc.methodNotSupported, e2),
    /**
     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
     */
    limitExceeded: (e2) => Re(we.errorCodes.rpc.limitExceeded, e2)
  },
  provider: {
    /**
     * Get an Ethereum Provider User Rejected Request (4001) error.
     */
    userRejectedRequest: (e2) => ht(we.errorCodes.provider.userRejectedRequest, e2),
    /**
     * Get an Ethereum Provider Unauthorized (4100) error.
     */
    unauthorized: (e2) => ht(we.errorCodes.provider.unauthorized, e2),
    /**
     * Get an Ethereum Provider Unsupported Method (4200) error.
     */
    unsupportedMethod: (e2) => ht(we.errorCodes.provider.unsupportedMethod, e2),
    /**
     * Get an Ethereum Provider Not Connected (4900) error.
     */
    disconnected: (e2) => ht(we.errorCodes.provider.disconnected, e2),
    /**
     * Get an Ethereum Provider Chain Not Connected (4901) error.
     */
    chainDisconnected: (e2) => ht(we.errorCodes.provider.chainDisconnected, e2),
    /**
     * Get a custom Ethereum Provider error.
     */
    custom: (e2) => {
      if (!e2 || typeof e2 != "object" || Array.isArray(e2))
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      const { code: t, message: n, data: s } = e2;
      if (!n || typeof n != "string")
        throw new Error('"message" must be a nonempty string');
      return new Xr.EthereumProviderError(t, n, s);
    }
  }
};
function Re(e2, t) {
  const [n, s] = Ci(t);
  return new Xr.EthereumRpcError(e2, n || Pi.getMessageFromCode(e2), s);
}
function ht(e2, t) {
  const [n, s] = Ci(t);
  return new Xr.EthereumProviderError(e2, n || Pi.getMessageFromCode(e2), s);
}
function Ci(e2) {
  if (e2) {
    if (typeof e2 == "string")
      return [e2];
    if (typeof e2 == "object" && !Array.isArray(e2)) {
      const { message: t, data: n } = e2;
      if (t && typeof t != "string")
        throw new Error("Must specify string message.");
      return [t || void 0, n];
    }
  }
  return [];
}
(function(e2) {
  Object.defineProperty(e2, "__esModule", { value: true }), e2.getMessageFromCode = e2.serializeError = e2.EthereumProviderError = e2.EthereumRpcError = e2.ethErrors = e2.errorCodes = void 0;
  const t = Ve;
  Object.defineProperty(e2, "EthereumRpcError", { enumerable: true, get: function() {
    return t.EthereumRpcError;
  } }), Object.defineProperty(e2, "EthereumProviderError", { enumerable: true, get: function() {
    return t.EthereumProviderError;
  } });
  const n = Jr;
  Object.defineProperty(e2, "serializeError", { enumerable: true, get: function() {
    return n.serializeError;
  } }), Object.defineProperty(e2, "getMessageFromCode", { enumerable: true, get: function() {
    return n.getMessageFromCode;
  } });
  const s = zt;
  Object.defineProperty(e2, "ethErrors", { enumerable: true, get: function() {
    return s.ethErrors;
  } });
  const u = He;
  Object.defineProperty(e2, "errorCodes", { enumerable: true, get: function() {
    return u.errorCodes;
  } });
})(ot);
Object.defineProperty(Oe, "__esModule", { value: true });
var Ii = Oe.EMITTED_NOTIFICATIONS = Oe.NOOP = Oe.logStreamDisconnectWarning = ji = Oe.getRpcPromiseCallback = Oe.createErrorMiddleware = void 0;
var Es = ot;
function Ss(e2) {
  return (t, n, s) => {
    (typeof t.method != "string" || !t.method) && (n.error = Es.ethErrors.rpc.invalidRequest({
      message: "The request 'method' must be a non-empty string.",
      data: t
    })), s((u) => {
      const { error: d } = n;
      return d && e2.error(`MetaMask - RPC Error: ${d.message}`, d), u();
    });
  };
}
Oe.createErrorMiddleware = Ss;
var As = (e2, t, n = true) => (s, u) => {
  s || u.error ? t(s || u.error) : !n || Array.isArray(u) ? e2(u) : e2(u.result);
};
var ji = Oe.getRpcPromiseCallback = As;
function xs(e2, t, n, s) {
  let u = `MetaMask: Lost connection to "${t}".`;
  n != null && n.stack && (u += `
${n.stack}`), e2.warn(u), s && s.listenerCount("error") > 0 && s.emit("error", u);
}
Oe.logStreamDisconnectWarning = xs;
var Rs = () => {
};
Oe.NOOP = Rs;
Ii = Oe.EMITTED_NOTIFICATIONS = [
  "eth_subscription"
  // per eth-json-rpc-filters/subscriptionManager
];
var Fi = {};
Object.defineProperty(Fi, "__esModule", { value: true });
var Ts = lt;
function mn(e2, t, n) {
  try {
    Reflect.apply(e2, t, n);
  } catch (s) {
    setTimeout(() => {
      throw s;
    });
  }
}
function Ms(e2) {
  const t = e2.length, n = new Array(t);
  for (let s = 0; s < t; s += 1)
    n[s] = e2[s];
  return n;
}
var Bs = class extends Ts.EventEmitter {
  emit(t, ...n) {
    let s = t === "error";
    const u = this._events;
    if (u !== void 0)
      s = s && u.error === void 0;
    else if (!s)
      return false;
    if (s) {
      let l;
      if (n.length > 0 && ([l] = n), l instanceof Error)
        throw l;
      const f = new Error(`Unhandled error.${l ? ` (${l.message})` : ""}`);
      throw f.context = l, f;
    }
    const d = u[t];
    if (d === void 0)
      return false;
    if (typeof d == "function")
      mn(d, this, n);
    else {
      const l = d.length, f = Ms(d);
      for (let g = 0; g < l; g += 1)
        mn(f[g], this, n);
    }
    return true;
  }
};
var Os = Fi.default = Bs;
var $e = (e2) => e2 !== null && typeof e2 == "object" && typeof e2.pipe == "function";
$e.writable = (e2) => $e(e2) && e2.writable !== false && typeof e2._write == "function" && typeof e2._writableState == "object";
$e.readable = (e2) => $e(e2) && e2.readable !== false && typeof e2._read == "function" && typeof e2._readableState == "object";
$e.duplex = (e2) => $e.writable(e2) && $e.readable(e2);
$e.transform = (e2) => $e.duplex(e2) && typeof e2._transform == "function";
var Ps = $e;
var Fr = {};
var Jt = {};
var bt = {};
Object.defineProperty(bt, "__esModule", { value: true });
bt.getUniqueId = void 0;
var ki = 4294967295;
var mr = Math.floor(Math.random() * ki);
function Cs() {
  return mr = (mr + 1) % ki, mr;
}
bt.getUniqueId = Cs;
Object.defineProperty(Jt, "__esModule", { value: true });
Jt.createIdRemapMiddleware = void 0;
var Is = bt;
function js() {
  return (e2, t, n, s) => {
    const u = e2.id, d = Is.getUniqueId();
    e2.id = d, t.id = d, n((l) => {
      e2.id = u, t.id = u, l();
    });
  };
}
Jt.createIdRemapMiddleware = js;
var Xt = {};
Object.defineProperty(Xt, "__esModule", { value: true });
Xt.createAsyncMiddleware = void 0;
function Fs(e2) {
  return async (t, n, s, u) => {
    let d;
    const l = new Promise((F) => {
      d = F;
    });
    let f = null, g = false;
    const T = async () => {
      g = true, s((F) => {
        f = F, d();
      }), await l;
    };
    try {
      await e2(t, n, T), g ? (await l, f(null)) : u(null);
    } catch (F) {
      f ? f(F) : u(F);
    }
  };
}
Xt.createAsyncMiddleware = Fs;
var Kt = {};
Object.defineProperty(Kt, "__esModule", { value: true });
Kt.createScaffoldMiddleware = void 0;
function ks(e2) {
  return (t, n, s, u) => {
    const d = e2[t.method];
    return d === void 0 ? s() : typeof d == "function" ? d(t, n, s, u) : (n.result = d, u());
  };
}
Kt.createScaffoldMiddleware = ks;
var _t = {};
var Yt = {};
Object.defineProperty(Yt, "__esModule", { value: true });
var $s = lt;
function wn(e2, t, n) {
  try {
    Reflect.apply(e2, t, n);
  } catch (s) {
    setTimeout(() => {
      throw s;
    });
  }
}
function Ns(e2) {
  const t = e2.length, n = new Array(t);
  for (let s = 0; s < t; s += 1)
    n[s] = e2[s];
  return n;
}
var Us = class extends $s.EventEmitter {
  emit(t, ...n) {
    let s = t === "error";
    const u = this._events;
    if (u !== void 0)
      s = s && u.error === void 0;
    else if (!s)
      return false;
    if (s) {
      let l;
      if (n.length > 0 && ([l] = n), l instanceof Error)
        throw l;
      const f = new Error(`Unhandled error.${l ? ` (${l.message})` : ""}`);
      throw f.context = l, f;
    }
    const d = u[t];
    if (d === void 0)
      return false;
    if (typeof d == "function")
      wn(d, this, n);
    else {
      const l = d.length, f = Ns(d);
      for (let g = 0; g < l; g += 1)
        wn(f[g], this, n);
    }
    return true;
  }
};
Yt.default = Us;
var Ds = te && te.__importDefault || function(e2) {
  return e2 && e2.__esModule ? e2 : { default: e2 };
};
Object.defineProperty(_t, "__esModule", { value: true });
_t.JsonRpcEngine = void 0;
var Ls = Ds(Yt);
var Te = ot;
var Ue = class _Ue extends Ls.default {
  constructor() {
    super(), this._middleware = [];
  }
  /**
   * Add a middleware function to the engine's middleware stack.
   *
   * @param middleware - The middleware function to add.
   */
  push(t) {
    this._middleware.push(t);
  }
  handle(t, n) {
    if (n && typeof n != "function")
      throw new Error('"callback" must be a function if provided.');
    return Array.isArray(t) ? n ? this._handleBatch(t, n) : this._handleBatch(t) : n ? this._handle(t, n) : this._promiseHandle(t);
  }
  /**
   * Returns this engine as a middleware function that can be pushed to other
   * engines.
   *
   * @returns This engine as a middleware function.
   */
  asMiddleware() {
    return async (t, n, s, u) => {
      try {
        const [d, l, f] = await _Ue._runAllMiddleware(t, n, this._middleware);
        return l ? (await _Ue._runReturnHandlers(f), u(d)) : s(async (g) => {
          try {
            await _Ue._runReturnHandlers(f);
          } catch (T) {
            return g(T);
          }
          return g();
        });
      } catch (d) {
        return u(d);
      }
    };
  }
  async _handleBatch(t, n) {
    try {
      const s = await Promise.all(
        // 1. Begin executing each request in the order received
        t.map(this._promiseHandle.bind(this))
      );
      return n ? n(null, s) : s;
    } catch (s) {
      if (n)
        return n(s);
      throw s;
    }
  }
  /**
   * A promise-wrapped _handle.
   */
  _promiseHandle(t) {
    return new Promise((n) => {
      this._handle(t, (s, u) => {
        n(u);
      });
    });
  }
  /**
   * Ensures that the request object is valid, processes it, and passes any
   * error and the response object to the given callback.
   *
   * Does not reject.
   */
  async _handle(t, n) {
    if (!t || Array.isArray(t) || typeof t != "object") {
      const l = new Te.EthereumRpcError(Te.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof t}`, { request: t });
      return n(l, { id: void 0, jsonrpc: "2.0", error: l });
    }
    if (typeof t.method != "string") {
      const l = new Te.EthereumRpcError(Te.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof t.method}`, { request: t });
      return n(l, { id: t.id, jsonrpc: "2.0", error: l });
    }
    const s = Object.assign({}, t), u = {
      id: s.id,
      jsonrpc: s.jsonrpc
    };
    let d = null;
    try {
      await this._processRequest(s, u);
    } catch (l) {
      d = l;
    }
    return d && (delete u.result, u.error || (u.error = Te.serializeError(d))), n(d, u);
  }
  /**
   * For the given request and response, runs all middleware and their return
   * handlers, if any, and ensures that internal request processing semantics
   * are satisfied.
   */
  async _processRequest(t, n) {
    const [s, u, d] = await _Ue._runAllMiddleware(t, n, this._middleware);
    if (_Ue._checkForCompletion(t, n, u), await _Ue._runReturnHandlers(d), s)
      throw s;
  }
  /**
   * Serially executes the given stack of middleware.
   *
   * @returns An array of any error encountered during middleware execution,
   * a boolean indicating whether the request was completed, and an array of
   * middleware-defined return handlers.
   */
  static async _runAllMiddleware(t, n, s) {
    const u = [];
    let d = null, l = false;
    for (const f of s)
      if ([d, l] = await _Ue._runMiddleware(t, n, f, u), l)
        break;
    return [d, l, u.reverse()];
  }
  /**
   * Runs an individual middleware.
   *
   * @returns An array of any error encountered during middleware exection,
   * and a boolean indicating whether the request should end.
   */
  static _runMiddleware(t, n, s, u) {
    return new Promise((d) => {
      const l = (g) => {
        const T = g || n.error;
        T && (n.error = Te.serializeError(T)), d([T, true]);
      }, f = (g) => {
        n.error ? l(n.error) : (g && (typeof g != "function" && l(new Te.EthereumRpcError(Te.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof g}" for request:
${wr(t)}`, { request: t })), u.push(g)), d([null, false]));
      };
      try {
        s(t, n, f, l);
      } catch (g) {
        l(g);
      }
    });
  }
  /**
   * Serially executes array of return handlers. The request and response are
   * assumed to be in their scope.
   */
  static async _runReturnHandlers(t) {
    for (const n of t)
      await new Promise((s, u) => {
        n((d) => d ? u(d) : s());
      });
  }
  /**
   * Throws an error if the response has neither a result nor an error, or if
   * the "isComplete" flag is falsy.
   */
  static _checkForCompletion(t, n, s) {
    if (!("result" in n) && !("error" in n))
      throw new Te.EthereumRpcError(Te.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${wr(t)}`, { request: t });
    if (!s)
      throw new Te.EthereumRpcError(Te.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${wr(t)}`, { request: t });
  }
};
_t.JsonRpcEngine = Ue;
function wr(e2) {
  return JSON.stringify(e2, null, 2);
}
var Zt = {};
Object.defineProperty(Zt, "__esModule", { value: true });
Zt.mergeMiddleware = void 0;
var qs = _t;
function Ws(e2) {
  const t = new qs.JsonRpcEngine();
  return e2.forEach((n) => t.push(n)), t.asMiddleware();
}
Zt.mergeMiddleware = Ws;
(function(e2) {
  var t = te && te.__createBinding || (Object.create ? function(s, u, d, l) {
    l === void 0 && (l = d), Object.defineProperty(s, l, { enumerable: true, get: function() {
      return u[d];
    } });
  } : function(s, u, d, l) {
    l === void 0 && (l = d), s[l] = u[d];
  }), n = te && te.__exportStar || function(s, u) {
    for (var d in s)
      d !== "default" && !Object.prototype.hasOwnProperty.call(u, d) && t(u, s, d);
  };
  Object.defineProperty(e2, "__esModule", { value: true }), n(Jt, e2), n(Xt, e2), n(Kt, e2), n(bt, e2), n(_t, e2), n(Zt, e2);
})(Fr);
var gt = {};
var Kr = {};
var kr = { exports: {} };
var Vs = {}.toString;
var Hs = Array.isArray || function(e2) {
  return Vs.call(e2) == "[object Array]";
};
var $i = lt.EventEmitter;
var $r = { exports: {} };
(function(e2, t) {
  var n = ct, s = n.Buffer;
  function u(l, f) {
    for (var g in l)
      f[g] = l[g];
  }
  s.from && s.alloc && s.allocUnsafe && s.allocUnsafeSlow ? e2.exports = n : (u(n, t), t.Buffer = d);
  function d(l, f, g) {
    return s(l, f, g);
  }
  u(s, d), d.from = function(l, f, g) {
    if (typeof l == "number")
      throw new TypeError("Argument must not be a number");
    return s(l, f, g);
  }, d.alloc = function(l, f, g) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    var T = s(l);
    return f !== void 0 ? typeof g == "string" ? T.fill(f, g) : T.fill(f) : T.fill(0), T;
  }, d.allocUnsafe = function(l) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    return s(l);
  }, d.allocUnsafeSlow = function(l) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    return n.SlowBuffer(l);
  };
})($r, $r.exports);
var Yr = $r.exports;
var vr = { exports: {} };
var vn;
function Gs() {
  return vn || (vn = 1, function(e2) {
    function t(d, l) {
      if (!(d instanceof l))
        throw new TypeError("Cannot call a class as a function");
    }
    var n = Yr.Buffer, s = wt;
    function u(d, l, f) {
      d.copy(l, f);
    }
    e2.exports = function() {
      function d() {
        t(this, d), this.head = null, this.tail = null, this.length = 0;
      }
      return d.prototype.push = function(f) {
        var g = { data: f, next: null };
        this.length > 0 ? this.tail.next = g : this.head = g, this.tail = g, ++this.length;
      }, d.prototype.unshift = function(f) {
        var g = { data: f, next: this.head };
        this.length === 0 && (this.tail = g), this.head = g, ++this.length;
      }, d.prototype.shift = function() {
        if (this.length !== 0) {
          var f = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, f;
        }
      }, d.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, d.prototype.join = function(f) {
        if (this.length === 0)
          return "";
        for (var g = this.head, T = "" + g.data; g = g.next; )
          T += f + g.data;
        return T;
      }, d.prototype.concat = function(f) {
        if (this.length === 0)
          return n.alloc(0);
        for (var g = n.allocUnsafe(f >>> 0), T = this.head, F = 0; T; )
          u(T.data, g, F), F += T.data.length, T = T.next;
        return g;
      }, d;
    }(), s && s.inspect && s.inspect.custom && (e2.exports.prototype[s.inspect.custom] = function() {
      var d = s.inspect({ length: this.length });
      return this.constructor.name + " " + d;
    });
  }(vr)), vr.exports;
}
var xt = Ge;
function zs(e2, t) {
  var n = this, s = this._readableState && this._readableState.destroyed, u = this._writableState && this._writableState.destroyed;
  return s || u ? (t ? t(e2) : e2 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, xt.nextTick(Rt, this, e2)) : xt.nextTick(Rt, this, e2)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(e2 || null, function(d) {
    !t && d ? n._writableState ? n._writableState.errorEmitted || (n._writableState.errorEmitted = true, xt.nextTick(Rt, n, d)) : xt.nextTick(Rt, n, d) : t && t(d);
  }), this);
}
function Js() {
  this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
}
function Rt(e2, t) {
  e2.emit("error", t);
}
var Ni = {
  destroy: zs,
  undestroy: Js
};
var br;
var bn;
function Ui() {
  if (bn)
    return br;
  bn = 1;
  var e2 = Ge;
  br = N;
  function t(h) {
    var y = this;
    this.next = null, this.entry = null, this.finish = function() {
      me(y, h);
    };
  }
  var n = !J.process.browser && ["v0.10", "v0.9."].indexOf(J.process.version.slice(0, 5)) > -1 ? setImmediate : e2.nextTick, s;
  N.WritableState = U;
  var u = Object.create(re);
  u.inherits = Pe;
  var d = {
    deprecate: li
  }, l = $i, f = Yr.Buffer, g = (typeof te < "u" ? te : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function T(h) {
    return f.from(h);
  }
  function F(h) {
    return f.isBuffer(h) || h instanceof g;
  }
  var E = Ni;
  u.inherits(N, l);
  function j() {
  }
  function U(h, y) {
    s = s || ft(), h = h || {};
    var b = y instanceof s;
    this.objectMode = !!h.objectMode, b && (this.objectMode = this.objectMode || !!h.writableObjectMode);
    var P = h.highWaterMark, I = h.writableHighWaterMark, m = this.objectMode ? 16 : 16 * 1024;
    P || P === 0 ? this.highWaterMark = P : b && (I || I === 0) ? this.highWaterMark = I : this.highWaterMark = m, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    var A = h.decodeStrings === false;
    this.decodeStrings = !A, this.defaultEncoding = h.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(B) {
      ie(y, B);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  U.prototype.getBuffer = function() {
    for (var y = this.bufferedRequest, b = []; y; )
      b.push(y), y = y.next;
    return b;
  }, function() {
    try {
      Object.defineProperty(U.prototype, "buffer", {
        get: d.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var q;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (q = Function.prototype[Symbol.hasInstance], Object.defineProperty(N, Symbol.hasInstance, {
    value: function(h) {
      return q.call(this, h) ? true : this !== N ? false : h && h._writableState instanceof U;
    }
  })) : q = function(h) {
    return h instanceof this;
  };
  function N(h) {
    if (s = s || ft(), !q.call(N, this) && !(this instanceof s))
      return new N(h);
    this._writableState = new U(h, this), this.writable = true, h && (typeof h.write == "function" && (this._write = h.write), typeof h.writev == "function" && (this._writev = h.writev), typeof h.destroy == "function" && (this._destroy = h.destroy), typeof h.final == "function" && (this._final = h.final)), l.call(this);
  }
  N.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function Q(h, y) {
    var b = new Error("write after end");
    h.emit("error", b), e2.nextTick(y, b);
  }
  function x(h, y, b, P) {
    var I = true, m = false;
    return b === null ? m = new TypeError("May not write null values to stream") : typeof b != "string" && b !== void 0 && !y.objectMode && (m = new TypeError("Invalid non-string/buffer chunk")), m && (h.emit("error", m), e2.nextTick(P, m), I = false), I;
  }
  N.prototype.write = function(h, y, b) {
    var P = this._writableState, I = false, m = !P.objectMode && F(h);
    return m && !f.isBuffer(h) && (h = T(h)), typeof y == "function" && (b = y, y = null), m ? y = "buffer" : y || (y = P.defaultEncoding), typeof b != "function" && (b = j), P.ended ? Q(this, b) : (m || x(this, P, h, b)) && (P.pendingcb++, I = L(this, P, m, h, y, b)), I;
  }, N.prototype.cork = function() {
    var h = this._writableState;
    h.corked++;
  }, N.prototype.uncork = function() {
    var h = this._writableState;
    h.corked && (h.corked--, !h.writing && !h.corked && !h.bufferProcessing && h.bufferedRequest && he(this, h));
  }, N.prototype.setDefaultEncoding = function(y) {
    if (typeof y == "string" && (y = y.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((y + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + y);
    return this._writableState.defaultEncoding = y, this;
  };
  function R(h, y, b) {
    return !h.objectMode && h.decodeStrings !== false && typeof y == "string" && (y = f.from(y, b)), y;
  }
  Object.defineProperty(N.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function L(h, y, b, P, I, m) {
    if (!b) {
      var A = R(y, P, I);
      P !== A && (b = true, I = "buffer", P = A);
    }
    var B = y.objectMode ? 1 : P.length;
    y.length += B;
    var D = y.length < y.highWaterMark;
    if (D || (y.needDrain = true), y.writing || y.corked) {
      var W = y.lastBufferedRequest;
      y.lastBufferedRequest = {
        chunk: P,
        encoding: I,
        isBuf: b,
        callback: m,
        next: null
      }, W ? W.next = y.lastBufferedRequest : y.bufferedRequest = y.lastBufferedRequest, y.bufferedRequestCount += 1;
    } else
      z(h, y, false, B, P, I, m);
    return D;
  }
  function z(h, y, b, P, I, m, A) {
    y.writelen = P, y.writecb = A, y.writing = true, y.sync = true, b ? h._writev(I, y.onwrite) : h._write(I, m, y.onwrite), y.sync = false;
  }
  function V(h, y, b, P, I) {
    --y.pendingcb, b ? (e2.nextTick(I, P), e2.nextTick(K, h, y), h._writableState.errorEmitted = true, h.emit("error", P)) : (I(P), h._writableState.errorEmitted = true, h.emit("error", P), K(h, y));
  }
  function Ee(h) {
    h.writing = false, h.writecb = null, h.length -= h.writelen, h.writelen = 0;
  }
  function ie(h, y) {
    var b = h._writableState, P = b.sync, I = b.writecb;
    if (Ee(b), y)
      V(h, b, P, y, I);
    else {
      var m = ee(b);
      !m && !b.corked && !b.bufferProcessing && b.bufferedRequest && he(h, b), P ? n(de, h, b, m, I) : de(h, b, m, I);
    }
  }
  function de(h, y, b, P) {
    b || ce(h, y), y.pendingcb--, P(), K(h, y);
  }
  function ce(h, y) {
    y.length === 0 && y.needDrain && (y.needDrain = false, h.emit("drain"));
  }
  function he(h, y) {
    y.bufferProcessing = true;
    var b = y.bufferedRequest;
    if (h._writev && b && b.next) {
      var P = y.bufferedRequestCount, I = new Array(P), m = y.corkedRequestsFree;
      m.entry = b;
      for (var A = 0, B = true; b; )
        I[A] = b, b.isBuf || (B = false), b = b.next, A += 1;
      I.allBuffers = B, z(h, y, true, y.length, I, "", m.finish), y.pendingcb++, y.lastBufferedRequest = null, m.next ? (y.corkedRequestsFree = m.next, m.next = null) : y.corkedRequestsFree = new t(y), y.bufferedRequestCount = 0;
    } else {
      for (; b; ) {
        var D = b.chunk, W = b.encoding, o = b.callback, a = y.objectMode ? 1 : D.length;
        if (z(h, y, false, a, D, W, o), b = b.next, y.bufferedRequestCount--, y.writing)
          break;
      }
      b === null && (y.lastBufferedRequest = null);
    }
    y.bufferedRequest = b, y.bufferProcessing = false;
  }
  N.prototype._write = function(h, y, b) {
    b(new Error("_write() is not implemented"));
  }, N.prototype._writev = null, N.prototype.end = function(h, y, b) {
    var P = this._writableState;
    typeof h == "function" ? (b = h, h = null, y = null) : typeof y == "function" && (b = y, y = null), h != null && this.write(h, y), P.corked && (P.corked = 1, this.uncork()), P.ending || ge(this, P, b);
  };
  function ee(h) {
    return h.ending && h.length === 0 && h.bufferedRequest === null && !h.finished && !h.writing;
  }
  function ue(h, y) {
    h._final(function(b) {
      y.pendingcb--, b && h.emit("error", b), y.prefinished = true, h.emit("prefinish"), K(h, y);
    });
  }
  function ve(h, y) {
    !y.prefinished && !y.finalCalled && (typeof h._final == "function" ? (y.pendingcb++, y.finalCalled = true, e2.nextTick(ue, h, y)) : (y.prefinished = true, h.emit("prefinish")));
  }
  function K(h, y) {
    var b = ee(y);
    return b && (ve(h, y), y.pendingcb === 0 && (y.finished = true, h.emit("finish"))), b;
  }
  function ge(h, y, b) {
    y.ending = true, K(h, y), b && (y.finished ? e2.nextTick(b) : h.once("finish", b)), y.ended = true, h.writable = false;
  }
  function me(h, y, b) {
    var P = h.entry;
    for (h.entry = null; P; ) {
      var I = P.callback;
      y.pendingcb--, I(b), P = P.next;
    }
    y.corkedRequestsFree.next = h;
  }
  return Object.defineProperty(N.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? false : this._writableState.destroyed;
    },
    set: function(h) {
      this._writableState && (this._writableState.destroyed = h);
    }
  }), N.prototype.destroy = E.destroy, N.prototype._undestroy = E.undestroy, N.prototype._destroy = function(h, y) {
    this.end(), y(h);
  }, br;
}
var _r;
var _n;
function ft() {
  if (_n)
    return _r;
  _n = 1;
  var e2 = Ge, t = Object.keys || function(E) {
    var j = [];
    for (var U in E)
      j.push(U);
    return j;
  };
  _r = g;
  var n = Object.create(re);
  n.inherits = Pe;
  var s = Di(), u = Ui();
  n.inherits(g, s);
  for (var d = t(u.prototype), l = 0; l < d.length; l++) {
    var f = d[l];
    g.prototype[f] || (g.prototype[f] = u.prototype[f]);
  }
  function g(E) {
    if (!(this instanceof g))
      return new g(E);
    s.call(this, E), u.call(this, E), E && E.readable === false && (this.readable = false), E && E.writable === false && (this.writable = false), this.allowHalfOpen = true, E && E.allowHalfOpen === false && (this.allowHalfOpen = false), this.once("end", T);
  }
  Object.defineProperty(g.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function T() {
    this.allowHalfOpen || this._writableState.ended || e2.nextTick(F, this);
  }
  function F(E) {
    E.end();
  }
  return Object.defineProperty(g.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? false : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(E) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = E, this._writableState.destroyed = E);
    }
  }), g.prototype._destroy = function(E, j) {
    this.push(null), this.end(), e2.nextTick(j, E);
  }, _r;
}
var Er;
var En;
function Di() {
  if (En)
    return Er;
  En = 1;
  var e2 = Ge;
  Er = R;
  var t = Hs, n;
  R.ReadableState = x, lt.EventEmitter;
  var s = function(o, a) {
    return o.listeners(a).length;
  }, u = $i, d = Yr.Buffer, l = (typeof te < "u" ? te : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function f(o) {
    return d.from(o);
  }
  function g(o) {
    return d.isBuffer(o) || o instanceof l;
  }
  var T = Object.create(re);
  T.inherits = Pe;
  var F = wt, E = void 0;
  F && F.debuglog ? E = F.debuglog("stream") : E = function() {
  };
  var j = Gs(), U = Ni, q;
  T.inherits(R, u);
  var N = ["error", "close", "destroy", "pause", "resume"];
  function Q(o, a, w) {
    if (typeof o.prependListener == "function")
      return o.prependListener(a, w);
    !o._events || !o._events[a] ? o.on(a, w) : t(o._events[a]) ? o._events[a].unshift(w) : o._events[a] = [w, o._events[a]];
  }
  function x(o, a) {
    n = n || ft(), o = o || {};
    var w = a instanceof n;
    this.objectMode = !!o.objectMode, w && (this.objectMode = this.objectMode || !!o.readableObjectMode);
    var _ = o.highWaterMark, $ = o.readableHighWaterMark, C = this.objectMode ? 16 : 16 * 1024;
    _ || _ === 0 ? this.highWaterMark = _ : w && ($ || $ === 0) ? this.highWaterMark = $ : this.highWaterMark = C, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new j(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.destroyed = false, this.defaultEncoding = o.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, o.encoding && (q || (q = kt().StringDecoder), this.decoder = new q(o.encoding), this.encoding = o.encoding);
  }
  function R(o) {
    if (n = n || ft(), !(this instanceof R))
      return new R(o);
    this._readableState = new x(o, this), this.readable = true, o && (typeof o.read == "function" && (this._read = o.read), typeof o.destroy == "function" && (this._destroy = o.destroy)), u.call(this);
  }
  Object.defineProperty(R.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? false : this._readableState.destroyed;
    },
    set: function(o) {
      this._readableState && (this._readableState.destroyed = o);
    }
  }), R.prototype.destroy = U.destroy, R.prototype._undestroy = U.undestroy, R.prototype._destroy = function(o, a) {
    this.push(null), a(o);
  }, R.prototype.push = function(o, a) {
    var w = this._readableState, _;
    return w.objectMode ? _ = true : typeof o == "string" && (a = a || w.defaultEncoding, a !== w.encoding && (o = d.from(o, a), a = ""), _ = true), L(this, o, a, false, _);
  }, R.prototype.unshift = function(o) {
    return L(this, o, null, true, false);
  };
  function L(o, a, w, _, $) {
    var C = o._readableState;
    if (a === null)
      C.reading = false, he(o, C);
    else {
      var k;
      $ || (k = V(C, a)), k ? o.emit("error", k) : C.objectMode || a && a.length > 0 ? (typeof a != "string" && !C.objectMode && Object.getPrototypeOf(a) !== d.prototype && (a = f(a)), _ ? C.endEmitted ? o.emit("error", new Error("stream.unshift() after end event")) : z(o, C, a, true) : C.ended ? o.emit("error", new Error("stream.push() after EOF")) : (C.reading = false, C.decoder && !w ? (a = C.decoder.write(a), C.objectMode || a.length !== 0 ? z(o, C, a, false) : ve(o, C)) : z(o, C, a, false))) : _ || (C.reading = false);
    }
    return Ee(C);
  }
  function z(o, a, w, _) {
    a.flowing && a.length === 0 && !a.sync ? (o.emit("data", w), o.read(0)) : (a.length += a.objectMode ? 1 : w.length, _ ? a.buffer.unshift(w) : a.buffer.push(w), a.needReadable && ee(o)), ve(o, a);
  }
  function V(o, a) {
    var w;
    return !g(a) && typeof a != "string" && a !== void 0 && !o.objectMode && (w = new TypeError("Invalid non-string/buffer chunk")), w;
  }
  function Ee(o) {
    return !o.ended && (o.needReadable || o.length < o.highWaterMark || o.length === 0);
  }
  R.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  }, R.prototype.setEncoding = function(o) {
    return q || (q = kt().StringDecoder), this._readableState.decoder = new q(o), this._readableState.encoding = o, this;
  };
  var ie = 8388608;
  function de(o) {
    return o >= ie ? o = ie : (o--, o |= o >>> 1, o |= o >>> 2, o |= o >>> 4, o |= o >>> 8, o |= o >>> 16, o++), o;
  }
  function ce(o, a) {
    return o <= 0 || a.length === 0 && a.ended ? 0 : a.objectMode ? 1 : o !== o ? a.flowing && a.length ? a.buffer.head.data.length : a.length : (o > a.highWaterMark && (a.highWaterMark = de(o)), o <= a.length ? o : a.ended ? a.length : (a.needReadable = true, 0));
  }
  R.prototype.read = function(o) {
    E("read", o), o = parseInt(o, 10);
    var a = this._readableState, w = o;
    if (o !== 0 && (a.emittedReadable = false), o === 0 && a.needReadable && (a.length >= a.highWaterMark || a.ended))
      return E("read: emitReadable", a.length, a.ended), a.length === 0 && a.ended ? B(this) : ee(this), null;
    if (o = ce(o, a), o === 0 && a.ended)
      return a.length === 0 && B(this), null;
    var _ = a.needReadable;
    E("need readable", _), (a.length === 0 || a.length - o < a.highWaterMark) && (_ = true, E("length less than watermark", _)), a.ended || a.reading ? (_ = false, E("reading or ended", _)) : _ && (E("do read"), a.reading = true, a.sync = true, a.length === 0 && (a.needReadable = true), this._read(a.highWaterMark), a.sync = false, a.reading || (o = ce(w, a)));
    var $;
    return o > 0 ? $ = P(o, a) : $ = null, $ === null ? (a.needReadable = true, o = 0) : a.length -= o, a.length === 0 && (a.ended || (a.needReadable = true), w !== o && a.ended && B(this)), $ !== null && this.emit("data", $), $;
  };
  function he(o, a) {
    if (!a.ended) {
      if (a.decoder) {
        var w = a.decoder.end();
        w && w.length && (a.buffer.push(w), a.length += a.objectMode ? 1 : w.length);
      }
      a.ended = true, ee(o);
    }
  }
  function ee(o) {
    var a = o._readableState;
    a.needReadable = false, a.emittedReadable || (E("emitReadable", a.flowing), a.emittedReadable = true, a.sync ? e2.nextTick(ue, o) : ue(o));
  }
  function ue(o) {
    E("emit readable"), o.emit("readable"), b(o);
  }
  function ve(o, a) {
    a.readingMore || (a.readingMore = true, e2.nextTick(K, o, a));
  }
  function K(o, a) {
    for (var w = a.length; !a.reading && !a.flowing && !a.ended && a.length < a.highWaterMark && (E("maybeReadMore read 0"), o.read(0), w !== a.length); )
      w = a.length;
    a.readingMore = false;
  }
  R.prototype._read = function(o) {
    this.emit("error", new Error("_read() is not implemented"));
  }, R.prototype.pipe = function(o, a) {
    var w = this, _ = this._readableState;
    switch (_.pipesCount) {
      case 0:
        _.pipes = o;
        break;
      case 1:
        _.pipes = [_.pipes, o];
        break;
      default:
        _.pipes.push(o);
        break;
    }
    _.pipesCount += 1, E("pipe count=%d opts=%j", _.pipesCount, a);
    var $ = (!a || a.end !== false) && o !== J.process.stdout && o !== J.process.stderr, C = $ ? oe : be;
    _.endEmitted ? e2.nextTick(C) : w.once("end", C), o.on("unpipe", k);
    function k(_e, le) {
      E("onunpipe"), _e === w && le && le.hasUnpiped === false && (le.hasUnpiped = true, Ne());
    }
    function oe() {
      E("onend"), o.end();
    }
    var Se = ge(w);
    o.on("drain", Se);
    var Ce = false;
    function Ne() {
      E("cleanup"), o.removeListener("close", Ae), o.removeListener("finish", pe), o.removeListener("drain", Se), o.removeListener("error", xe), o.removeListener("unpipe", k), w.removeListener("end", oe), w.removeListener("end", be), w.removeListener("data", O), Ce = true, _.awaitDrain && (!o._writableState || o._writableState.needDrain) && Se();
    }
    var Be = false;
    w.on("data", O);
    function O(_e) {
      E("ondata"), Be = false;
      var le = o.write(_e);
      le === false && !Be && ((_.pipesCount === 1 && _.pipes === o || _.pipesCount > 1 && W(_.pipes, o) !== -1) && !Ce && (E("false write response, pause", _.awaitDrain), _.awaitDrain++, Be = true), w.pause());
    }
    function xe(_e) {
      E("onerror", _e), be(), o.removeListener("error", xe), s(o, "error") === 0 && o.emit("error", _e);
    }
    Q(o, "error", xe);
    function Ae() {
      o.removeListener("finish", pe), be();
    }
    o.once("close", Ae);
    function pe() {
      E("onfinish"), o.removeListener("close", Ae), be();
    }
    o.once("finish", pe);
    function be() {
      E("unpipe"), w.unpipe(o);
    }
    return o.emit("pipe", w), _.flowing || (E("pipe resume"), w.resume()), o;
  };
  function ge(o) {
    return function() {
      var a = o._readableState;
      E("pipeOnDrain", a.awaitDrain), a.awaitDrain && a.awaitDrain--, a.awaitDrain === 0 && s(o, "data") && (a.flowing = true, b(o));
    };
  }
  R.prototype.unpipe = function(o) {
    var a = this._readableState, w = { hasUnpiped: false };
    if (a.pipesCount === 0)
      return this;
    if (a.pipesCount === 1)
      return o && o !== a.pipes ? this : (o || (o = a.pipes), a.pipes = null, a.pipesCount = 0, a.flowing = false, o && o.emit("unpipe", this, w), this);
    if (!o) {
      var _ = a.pipes, $ = a.pipesCount;
      a.pipes = null, a.pipesCount = 0, a.flowing = false;
      for (var C = 0; C < $; C++)
        _[C].emit("unpipe", this, { hasUnpiped: false });
      return this;
    }
    var k = W(a.pipes, o);
    return k === -1 ? this : (a.pipes.splice(k, 1), a.pipesCount -= 1, a.pipesCount === 1 && (a.pipes = a.pipes[0]), o.emit("unpipe", this, w), this);
  }, R.prototype.on = function(o, a) {
    var w = u.prototype.on.call(this, o, a);
    if (o === "data")
      this._readableState.flowing !== false && this.resume();
    else if (o === "readable") {
      var _ = this._readableState;
      !_.endEmitted && !_.readableListening && (_.readableListening = _.needReadable = true, _.emittedReadable = false, _.reading ? _.length && ee(this) : e2.nextTick(me, this));
    }
    return w;
  }, R.prototype.addListener = R.prototype.on;
  function me(o) {
    E("readable nexttick read 0"), o.read(0);
  }
  R.prototype.resume = function() {
    var o = this._readableState;
    return o.flowing || (E("resume"), o.flowing = true, h(this, o)), this;
  };
  function h(o, a) {
    a.resumeScheduled || (a.resumeScheduled = true, e2.nextTick(y, o, a));
  }
  function y(o, a) {
    a.reading || (E("resume read 0"), o.read(0)), a.resumeScheduled = false, a.awaitDrain = 0, o.emit("resume"), b(o), a.flowing && !a.reading && o.read(0);
  }
  R.prototype.pause = function() {
    return E("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (E("pause"), this._readableState.flowing = false, this.emit("pause")), this;
  };
  function b(o) {
    var a = o._readableState;
    for (E("flow", a.flowing); a.flowing && o.read() !== null; )
      ;
  }
  R.prototype.wrap = function(o) {
    var a = this, w = this._readableState, _ = false;
    o.on("end", function() {
      if (E("wrapped end"), w.decoder && !w.ended) {
        var k = w.decoder.end();
        k && k.length && a.push(k);
      }
      a.push(null);
    }), o.on("data", function(k) {
      if (E("wrapped data"), w.decoder && (k = w.decoder.write(k)), !(w.objectMode && k == null) && !(!w.objectMode && (!k || !k.length))) {
        var oe = a.push(k);
        oe || (_ = true, o.pause());
      }
    });
    for (var $ in o)
      this[$] === void 0 && typeof o[$] == "function" && (this[$] = /* @__PURE__ */ function(k) {
        return function() {
          return o[k].apply(o, arguments);
        };
      }($));
    for (var C = 0; C < N.length; C++)
      o.on(N[C], this.emit.bind(this, N[C]));
    return this._read = function(k) {
      E("wrapped _read", k), _ && (_ = false, o.resume());
    }, this;
  }, Object.defineProperty(R.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), R._fromList = P;
  function P(o, a) {
    if (a.length === 0)
      return null;
    var w;
    return a.objectMode ? w = a.buffer.shift() : !o || o >= a.length ? (a.decoder ? w = a.buffer.join("") : a.buffer.length === 1 ? w = a.buffer.head.data : w = a.buffer.concat(a.length), a.buffer.clear()) : w = I(o, a.buffer, a.decoder), w;
  }
  function I(o, a, w) {
    var _;
    return o < a.head.data.length ? (_ = a.head.data.slice(0, o), a.head.data = a.head.data.slice(o)) : o === a.head.data.length ? _ = a.shift() : _ = w ? m(o, a) : A(o, a), _;
  }
  function m(o, a) {
    var w = a.head, _ = 1, $ = w.data;
    for (o -= $.length; w = w.next; ) {
      var C = w.data, k = o > C.length ? C.length : o;
      if (k === C.length ? $ += C : $ += C.slice(0, o), o -= k, o === 0) {
        k === C.length ? (++_, w.next ? a.head = w.next : a.head = a.tail = null) : (a.head = w, w.data = C.slice(k));
        break;
      }
      ++_;
    }
    return a.length -= _, $;
  }
  function A(o, a) {
    var w = d.allocUnsafe(o), _ = a.head, $ = 1;
    for (_.data.copy(w), o -= _.data.length; _ = _.next; ) {
      var C = _.data, k = o > C.length ? C.length : o;
      if (C.copy(w, w.length - o, 0, k), o -= k, o === 0) {
        k === C.length ? (++$, _.next ? a.head = _.next : a.head = a.tail = null) : (a.head = _, _.data = C.slice(k));
        break;
      }
      ++$;
    }
    return a.length -= $, w;
  }
  function B(o) {
    var a = o._readableState;
    if (a.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    a.endEmitted || (a.ended = true, e2.nextTick(D, a, o));
  }
  function D(o, a) {
    !o.endEmitted && o.length === 0 && (o.endEmitted = true, a.readable = false, a.emit("end"));
  }
  function W(o, a) {
    for (var w = 0, _ = o.length; w < _; w++)
      if (o[w] === a)
        return w;
    return -1;
  }
  return Er;
}
var Li = qe;
var Qt = ft();
var qi = Object.create(re);
qi.inherits = Pe;
qi.inherits(qe, Qt);
function Xs(e2, t) {
  var n = this._transformState;
  n.transforming = false;
  var s = n.writecb;
  if (!s)
    return this.emit("error", new Error("write callback called multiple times"));
  n.writechunk = null, n.writecb = null, t != null && this.push(t), s(e2);
  var u = this._readableState;
  u.reading = false, (u.needReadable || u.length < u.highWaterMark) && this._read(u.highWaterMark);
}
function qe(e2) {
  if (!(this instanceof qe))
    return new qe(e2);
  Qt.call(this, e2), this._transformState = {
    afterTransform: Xs.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = true, this._readableState.sync = false, e2 && (typeof e2.transform == "function" && (this._transform = e2.transform), typeof e2.flush == "function" && (this._flush = e2.flush)), this.on("prefinish", Ks);
}
function Ks() {
  var e2 = this;
  typeof this._flush == "function" ? this._flush(function(t, n) {
    Sn(e2, t, n);
  }) : Sn(this, null, null);
}
qe.prototype.push = function(e2, t) {
  return this._transformState.needTransform = false, Qt.prototype.push.call(this, e2, t);
};
qe.prototype._transform = function(e2, t, n) {
  throw new Error("_transform() is not implemented");
};
qe.prototype._write = function(e2, t, n) {
  var s = this._transformState;
  if (s.writecb = n, s.writechunk = e2, s.writeencoding = t, !s.transforming) {
    var u = this._readableState;
    (s.needTransform || u.needReadable || u.length < u.highWaterMark) && this._read(u.highWaterMark);
  }
};
qe.prototype._read = function(e2) {
  var t = this._transformState;
  t.writechunk !== null && t.writecb && !t.transforming ? (t.transforming = true, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = true;
};
qe.prototype._destroy = function(e2, t) {
  var n = this;
  Qt.prototype._destroy.call(this, e2, function(s) {
    t(s), n.emit("close");
  });
};
function Sn(e2, t, n) {
  if (t)
    return e2.emit("error", t);
  if (n != null && e2.push(n), e2._writableState.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (e2._transformState.transforming)
    throw new Error("Calling transform done when still transforming");
  return e2.push(null);
}
var Ys = mt;
var Wi = Li;
var Vi = Object.create(re);
Vi.inherits = Pe;
Vi.inherits(mt, Wi);
function mt(e2) {
  if (!(this instanceof mt))
    return new mt(e2);
  Wi.call(this, e2);
}
mt.prototype._transform = function(e2, t, n) {
  n(null, e2);
};
(function(e2, t) {
  t = e2.exports = Di(), t.Stream = t, t.Readable = t, t.Writable = Ui(), t.Duplex = ft(), t.Transform = Li, t.PassThrough = Ys;
})(kr, kr.exports);
var Hi = kr.exports;
Object.defineProperty(Kr, "__esModule", { value: true });
var Zs = Hi;
function Qs(e2) {
  if (!e2 || !e2.engine)
    throw new Error("Missing engine parameter!");
  const { engine: t } = e2, n = new Zs.Duplex({ objectMode: true, read: s, write: u });
  return t.on && t.on("notification", (d) => {
    n.push(d);
  }), n;
  function s() {
  }
  function u(d, l, f) {
    t.handle(d, (g, T) => {
      n.push(T);
    }), f();
  }
}
Kr.default = Qs;
var Zr = {};
var eu = te && te.__importDefault || function(e2) {
  return e2 && e2.__esModule ? e2 : { default: e2 };
};
Object.defineProperty(Zr, "__esModule", { value: true });
var tu = eu(Yt);
var ru = Hi;
function nu() {
  const e2 = {}, t = new ru.Duplex({
    objectMode: true,
    read: u,
    write: d
  }), n = new tu.default();
  return { events: n, middleware: (g, T, F, E) => {
    t.push(g), e2[g.id] = { req: g, res: T, next: F, end: E };
  }, stream: t };
  function u() {
    return false;
  }
  function d(g, T, F) {
    let E;
    try {
      !g.id ? f(g) : l(g);
    } catch (j) {
      E = j;
    }
    F(E);
  }
  function l(g) {
    const T = e2[g.id];
    if (!T)
      throw new Error(`StreamMiddleware - Unknown response id "${g.id}"`);
    delete e2[g.id], Object.assign(T.res, g), setTimeout(T.end);
  }
  function f(g) {
    n.emit("notification", g);
  }
}
Zr.default = nu;
var Gi = te && te.__importDefault || function(e2) {
  return e2 && e2.__esModule ? e2 : { default: e2 };
};
Object.defineProperty(gt, "__esModule", { value: true });
var zi = gt.createStreamMiddleware = gt.createEngineStream = void 0;
var iu = Gi(Kr);
gt.createEngineStream = iu.default;
var ou = Gi(Zr);
zi = gt.createStreamMiddleware = ou.default;
var au = zr;
var su = Si;
var Nr = function() {
};
var uu = /^v?\.0/.test(J.process.version);
var Qr = function(e2) {
  return typeof e2 == "function";
};
var fu = function(e2) {
  return false;
};
var cu = function(e2) {
  return e2.setHeader && Qr(e2.abort);
};
var lu = function(e2, t, n, s) {
  s = au(s);
  var u = false;
  e2.on("close", function() {
    u = true;
  }), su(e2, { readable: t, writable: n }, function(l) {
    if (l)
      return s(l);
    u = true, s();
  });
  var d = false;
  return function(l) {
    if (!u && !d) {
      if (d = true, fu())
        return e2.close(Nr);
      if (cu(e2))
        return e2.abort();
      if (Qr(e2.destroy))
        return e2.destroy();
      s(l || new Error("stream was destroyed"));
    }
  };
};
var An = function(e2) {
  e2();
};
var du = function(e2, t) {
  return e2.pipe(t);
};
var hu = function() {
  var e2 = Array.prototype.slice.call(arguments), t = Qr(e2[e2.length - 1] || Nr) && e2.pop() || Nr;
  if (Array.isArray(e2[0]) && (e2 = e2[0]), e2.length < 2)
    throw new Error("pump requires two streams per minimum");
  var n, s = e2.map(function(u, d) {
    var l = d < e2.length - 1, f = d > 0;
    return lu(u, l, f, function(g) {
      n || (n = g), g && s.forEach(An), !l && (s.forEach(An), t(n));
    });
  });
  return e2.reduce(du);
};
var pu = hu;
var xn = Tn(pu);
var yu = "cede-provider";
var Nt = class Nt2 extends Os {
  constructor(n, { jsonRpcStreamName: s = yu, maxEventListeners: u = 100 } = {}) {
    super();
    ye(this, "_state");
    ye(this, "_rpcEngine");
    ye(this, "_jsonRpcConnection");
    ye(this, "_connectionStream");
    ye(this, "request", async (n2) => {
      if (!n2 || typeof n2 != "object" || Array.isArray(n2))
        throw ot.ethErrors.rpc.invalidRequest({
          message: dt.errors.invalidRequestArgs(),
          data: n2
        });
      const { method: s2, params: u2 } = n2;
      if (typeof s2 != "string" || s2.length === 0)
        throw ot.ethErrors.rpc.invalidRequest({
          message: dt.errors.invalidRequestMethod(),
          data: n2
        });
      if (u2 !== void 0 && !Array.isArray(u2) && (typeof u2 != "object" || u2 === null))
        throw ot.ethErrors.rpc.invalidRequest({
          message: dt.errors.invalidRequestParams(),
          data: n2
        });
      if (!(u2 != null && u2.version))
        throw new Error("No version provided");
      const d2 = new Promise((l2, f) => {
        const g = { method: s2, params: u2 }, T = ji(l2, f);
        return g.jsonrpc || (g.jsonrpc = "2.0"), this._rpcEngine.handle(g, T);
      });
      return s2 === "connect" && (u2 != null && u2.silent) && d2.then((l2) => {
        l2 && (this._state.isUnlocked = true);
      }).catch((l2) => l2), d2;
    });
    if (this._connectionStream = n, n.addListener("close", () => {
      console.log("Connection closed !");
    }), !Ps.duplex(n))
      throw new Error(dt.errors.invalidDuplexStream());
    this.setMaxListeners(u), this._state = Qi({
      ...Nt2._defaultState
    }), this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this), this.request = this.request.bind(this);
    const d = new ps();
    xn(
      n,
      d,
      n,
      this._handleStreamDisconnect.bind(this, "CEDE.store")
    ), this.on("connect", () => {
      this._state.isConnected = true;
    }), this._jsonRpcConnection = zi(), xn(
      this._jsonRpcConnection.stream,
      d.createStream(s),
      this._jsonRpcConnection.stream,
      this._handleStreamDisconnect.bind(this, "CEDE.store RpcProvider")
    );
    const l = new Fr.JsonRpcEngine();
    l.push(Fr.createIdRemapMiddleware()), l.push(this._jsonRpcConnection.middleware), this._rpcEngine = l, this._jsonRpcConnection.events.on("notification", (f) => {
      const { method: g, params: T } = f;
      Ii.includes(g) ? this.emit("message", {
        type: g,
        data: T
      }) : g === "STREAM_FAILURE" ? n.destroy(new Error(dt.errors.permanentlyDisconnected())) : this.executeMethod(g, T);
    });
  }
  /**
   * Called when connection is lost to critical streams.
   *
   * @emits InpageProvider#disconnect
   */
  _handleStreamDisconnect(n, s) {
    console.log(`Critical stream failure for ${n}`), this._state.isConnected && (this._state.isConnected = false, this._state.vaultPreviews = null, this._state.isUnlocked = false, this.emit("disconnect", s));
  }
  /**
   * When the provider becomes connected, updates internal state and emits
   * required events. Idempotent.
   *
   * @emits connect event
   */
  _connectionEstablished() {
    console.log("Connection established !"), this._state.isConnected || (this._state.isConnected = true, this.emit("connect"));
  }
  async _updateVaults(n) {
    var s;
    this._state.vaultPreviews = n.vaultsPreview, this.emit("accountsChanged", [
      (s = n.vaultsPreview.find((u) => u.isActive)) == null ? void 0 : s.name
    ]);
  }
  _unlock() {
    this._state.isUnlocked = true, this.emit("unlock");
  }
  _lock() {
    this._state.isUnlocked = false, this._state.vaultPreviews = [], this.emit("lock");
  }
  getNotificationApi() {
    return {
      connect: this._connectionEstablished.bind(this),
      accountsChanged: this._updateVaults.bind(this),
      unlock: this._unlock.bind(this),
      lock: this._lock.bind(this)
    };
  }
  executeMethod(n, ...s) {
    const d = this.getNotificationApi()[n];
    if (!d)
      throw new Error(`Method not found : ${n}`);
    return d(...s);
  }
  getIsUnlocked() {
    return this._state.isUnlocked;
  }
  /** Returns vaultPreview */
  getVaultPreviews() {
    return this._state.vaultPreviews;
  }
  getActiveVault() {
    return (this.getVaultPreviews() || []).find((n) => n.isActive);
  }
};
ye(Nt, "_defaultState", {
  vaultPreviews: null,
  isConnected: false,
  isUnlocked: false
});
var Z = {
  // transport related errors
  rpc: {
    parse: {
      code: -32700,
      message: "JSON parsing error",
      description: "{data.description}",
      documentation: "An error occurred on the server while parsing the JSON text"
    },
    invalidRequest: {
      code: -32600,
      message: "Invalid request object",
      description: "{data.description}",
      documentation: "The JSON sent is not a valid Request object"
    },
    methodNotFound: {
      code: -32601,
      message: "Method not found",
      description: "{data.description}",
      documentation: "The method does not exist / is not available"
    },
    invalidParams: {
      code: -32602,
      message: "Invalid method parameter(s)",
      description: "{data.description}",
      documentation: "Provided parameters do not match the method signature"
    },
    internal: {
      code: -32603,
      message: "Internal JSON-RPC error",
      description: "{data.description}",
      documentation: "Something went wrong in the communication engine of cede.store"
    }
  },
  defaultError: {
    code: 1e3,
    message: "cede.store default error",
    description: "{vault_and_account}: An error occurred",
    documentation: "Something went wrong in cede.store"
  },
  // ccxt library specific errors
  ccxt: {
    general: {
      notSupportedNfts: {
        code: 3e3,
        message: "NFTs are not supported",
        description: "{account.exchangeId}: NFTs aren't supported",
        documentation: "NFTs aren't supported on the given exchange"
      },
      cexError: {
        code: 3001,
        message: "CEX error",
        description: "{vault_and_account}: The exchange has a system abnormality. Original error: {error.message}",
        documentation: "The exchange has a system abnormality. The original exchange error is provided."
      },
      cexApiAuthError: {
        code: 3002,
        message: "CEX API authentication error",
        description: "{vault_and_account}: Invalid API-KEY or permission denied",
        documentation: "Invalid API key or permission denied"
      },
      cexNotAvailable: {
        code: 3003,
        message: "CEX is not available",
        description: "{vault_and_account}: Exchange is not available, please try again later",
        documentation: "Exchange is not available, please try again later"
      },
      cexOnMaintenance: {
        code: 3004,
        message: "CEX on maintenance",
        description: "{vault_and_account}: Exchange is on maintenance, please try again later",
        documentation: "Exchange is on maintenance, please try again later"
      },
      invalidNonce: {
        code: 3005,
        message: "Invalid nonce",
        description: "The API keys seem to be used by another app. Please create new {account.exchangeId} API keys and use them only for cede.store.",
        documentation: "The API keys seem to be used by another app. The user should create new API keys and use them only for cede.store."
      },
      notSupported: {
        code: 3006,
        message: "Not supported",
        description: "{vault_and_account}: Not supported - {error.message}",
        documentation: "This error is raised if the endpoint is not offered/not supported by the exchange API"
      }
    },
    order: {
      orderNotFound: {
        code: 3100,
        message: "Could not find the order",
        description: "{vault_and_account}: Order not found",
        documentation: "Raised when you are trying to fetch or cancel a non-existent order"
      },
      orderImmediatelyFillable: {
        code: 3101,
        message: "The order is immediately fillable",
        description: "{vault_and_account}: Order would immediately be triggered",
        documentation: "Raised when the order you're trying to place would immediately be triggered and filled, and not be placed on the order book"
      },
      orderNotFillable: {
        code: 3102,
        message: "The order is not fillable",
        description: "{vault_and_account}: Unable to fill this order - {error.message}",
        documentation: "Unable to fill this order"
      },
      invalidOrder: {
        code: 3103,
        message: "The order is invalid",
        description: "{vault_and_account}: Invalid order - {error.message}",
        documentation: "Raised when the order you're trying to place is not valid"
      },
      duplicateOrderId: {
        code: 3104,
        message: "Two or more orders have identical ids",
        description: "{vault_and_account}: Duplicate order id found",
        documentation: "Raised when two or more orders have identical ids"
      }
    },
    request: {
      badRequest: {
        code: 3200,
        message: "Bad request",
        description: "{vault_and_account}: Bad request - {error.message}",
        documentation: "The request is malformed, the content of the request is not valid"
      },
      requestTimeout: {
        code: 3201,
        message: "Request timeout",
        description: "{vault_and_account}: Request timeout, please try again later",
        documentation: "The request timed out"
      },
      badResponse: {
        code: 3202,
        message: "Bad response",
        description: "{vault_and_account}: Bad response from the exchange - {error.message}",
        documentation: "The response from the exchange is malformed"
      },
      rateLimitExceeded: {
        code: 3203,
        message: "Rate limit exceeded",
        description: "{vault_and_account}: Rate limit exceeded, please try again later",
        documentation: "The request rate limit has been exceeded"
      },
      argumentsRequired: {
        code: 3204,
        message: "Method requires some arguments",
        description: "{vault_and_account}: Arguments required - {error.message}",
        documentation: "The method requires some arguments"
      },
      nullResponse: {
        code: 3205,
        message: "Null response",
        description: "{vault_and_account}: Null response from the exchange - {error.message}",
        documentation: "The response from the exchange is null"
      },
      ddosProtection: {
        code: 3206,
        message: "DDOS protection",
        description: "{vault_and_account}: DDOS protection. Too many requests, please try again later",
        documentation: "The request has been rejected by the exchange due to DDOS protection"
      },
      badSymbol: {
        code: 3207,
        message: "Bad symbol",
        description: "{vault_and_account}: Bad symbol {account} - {error.message}",
        documentation: "The symbol is not valid"
      }
    },
    account: {
      accountSuspended: {
        code: 3300,
        message: "Account suspended",
        description: "{vault_and_account}: Account suspended",
        documentation: "The user account is suspended"
      },
      permissionDenied: {
        code: 3301,
        message: "Permission denied",
        description: "{vault_and_account}: permission denied. Your key doesn't have the right permissions.",
        documentation: "The user doesn't have enough permission to perform the action"
      },
      insufficientFunds: {
        code: 3302,
        message: "Insufficient funds",
        description: "{vault_and_account}: Insufficient balance",
        documentation: "The user doesn't have enough funds to perform the action"
      },
      invalidAddress: {
        code: 3303,
        message: "Invalid address",
        description: "{vault_and_account}: Invalid address",
        documentation: "The address is not valid"
      },
      addressPending: {
        code: 3304,
        message: "Address pending",
        description: "{vault_and_account}: Address pending",
        documentation: "The address is pending"
      },
      cancelPending: {
        code: 3305,
        message: "Cancel pending",
        description: "{vault_and_account}: Cancel pending",
        documentation: "The cancel is pending"
      }
    }
  },
  internal: {
    general: {
      badPassword: {
        code: 4e3,
        message: "Bad password",
        description: "Bad password",
        documentation: "The password provided is incorrect"
      }
    },
    misc: {
      jobs: {
        fetchTransactionHistoryError: {
          code: 4100,
          message: "Transaction history cannot be fetched through the job",
          description: "An error happened while fetching the transaction history",
          documentation: "An error happened while fetching the transaction history"
        },
        getLastTxUpdateError: {
          code: 4101,
          message: "Last transaction update cannot be fetched through the job",
          description: "An error happened while getting the last transaction update",
          documentation: "An error happened while getting the last transaction update"
        }
      }
    },
    vault: {
      accountAlreadyExists: {
        code: 4200,
        message: "Vault account already exists",
        description: "The exchange account has already been added to the vault",
        documentation: "The exchange account has already been added to the vault"
      },
      nameExists: {
        code: 4201,
        message: "Vault name already exists",
        description: "The vault {vault} already exists",
        documentation: "Raised when trying to create the vault with same name as the existent vault"
      },
      nameCannotBeGenerated: {
        code: 4202,
        message: "Vault name cannot be generated",
        description: "The vault name cannot be generated",
        documentation: "Raised when there is an error in the vault name generation"
      },
      accountKeysInconsistent: {
        code: 4203,
        message: "Account keys inconsistent. They may not relate to the same account",
        description: "The Api Keys are not related to the same CEX account",
        documentation: "Raised when the user is trying to a second pair of API keys for the 2 key CEX which are not related to the same account"
      },
      cannotUnlockStorage: {
        code: 4204,
        message: "The storage cannot be unlocked",
        description: "Cede Store cannot unlock the storage",
        documentation: "Raised when the storage cannot be unlocked"
      },
      cannotPersisted: {
        code: 4205,
        message: "Vaults cannot persisted",
        description: "The vaults cannot be persisted",
        documentation: "Raised when the vaults cannot be persisted"
      },
      creationError: {
        code: 4206,
        message: "Vault creation error",
        description: "{vault}: An error happened while creating the vault",
        documentation: "Raised when an error happened while creating the vault"
      },
      deletionError: {
        code: 4207,
        message: "Vault deletion error",
        description: "{vault}: An error happened while deleting the vault",
        documentation: "Raised when an error happened while deleting the vault"
      },
      checkApiCredentialsError: {
        code: 4208,
        message: "API check credentials failure",
        description: "{vault}: An error happened while checking the API credentials",
        documentation: "Raised when an error happened while checking the API credentials when adding a new CEX"
      },
      updateApiCredentialsError: {
        code: 4209,
        message: "API update credentials failure",
        description: "{vault_and_account}: An error happened while updating the API credentials",
        documentation: "Raised when an error happened while updating the API credentials when updating a CEX"
      },
      updateCexSettingsError: {
        code: 4210,
        message: "Vault CEX update settings error",
        description: "{vault_and_account}: An error happened while updating the CEX settings",
        documentation: "Raised when an error happened while updating the CEX settings when updating a CEX"
      },
      accountCreationError: {
        code: 4211,
        message: "Vault account creation error",
        description: "{vault}: An error happened while creating the account",
        documentation: "Raised when an error happened while creating the account"
      },
      accountUpdateError: {
        code: 4212,
        message: "Vault account update error",
        description: "{vault_and_account}: An error happened while updating the account",
        documentation: "Raised when an error happened while updating the account"
      },
      globalUnlockError: {
        code: 4213,
        message: "Vault cannot be unlocked",
        description: "An error happened while unlocking the vaults",
        documentation: "Raised when an error happened while unlocking globally the vaults"
      },
      notWhitelisted: {
        code: 4214,
        message: "IP not whitelisted for API keys",
        description: "IP addresses weren't whitelisted. Please, whitelist them first.",
        documentation: "Raised when cede.store proxy IP was not whitelisted on the CEX side"
      },
      accountKeyAlreadyExists: {
        code: 4215,
        message: "API key already exists",
        description: "The API Key already exists",
        documentation: "Raised when the user is trying to update a key using one that already exists in the vault for the same CEX"
      },
      whitelistCheckFail: {
        code: 4216,
        message: "Whitelist check failed",
        description: "Whitelist check failed. Please try again later.",
        documentation: "Raised when the whitelist check failed"
      }
    }
  },
  // cede.store background errors
  cede: {
    general: {
      dispatcherDefaultError: {
        code: 5e3,
        message: "Dispatcher default error",
        description: "An error occured while {data.humanizedAction}",
        documentation: "An error occured while executing the method."
      },
      approvalNotFound: {
        code: 5001,
        message: "Approval not found",
        description: "The approval {data.approvalId} isn't found",
        documentation: "The approval isn't found. This can happen if the approval is not in pending approvals array"
      },
      vaultNotAllowedToAccess: {
        code: 5002,
        message: "Vault is not allowed to access",
        description: "You aren't allowed to access to this vault",
        documentation: "You aren't allowed to access to this vault"
      },
      accountNotPermission: {
        code: 5003,
        message: "Account does not have sufficient permissions to perform this action",
        description: "The account {account} doesn't have the permission to {data.permission} : {vault}",
        documentation: "The account doesn't have the permission to perform this action. If the account is read-only, you can't perform trades/withdrawals"
      },
      notAllowedMethod: {
        code: 5004,
        message: "Method not allowed",
        description: "You aren't available to access to the method {data.method}",
        documentation: "You aren't available to access to the given method"
      },
      notConnected: {
        code: 5005,
        message: "Not connected",
        description: "Connect with cede.store to perfom this request",
        documentation: "Connect with cede.store to perfom this request"
      },
      notInitialized: {
        code: 5006,
        message: "Not initialized",
        description: "The user must set up at least one vault in the cede.store first",
        documentation: "Raised when cede.store has been downloaded but not initialized. The user must set up at least one vault in the cede.store first"
      },
      oauthAccessRevoked: {
        code: 5007,
        message: "Access token revoked",
        description: "{vault}: Access token revoked. You should remove the {account} account and add it again.",
        documentation: "Raised when user adds an account via OAuth2. The user must remove and add the account again to get the new access token."
      },
      notSupportedFeature: {
        code: 5108,
        message: "This feature is not supported by the {account}",
        description: "This feature is not supported by the {account}",
        documentation: "Verify if the feature is supported by the CEX"
      },
      userDeniedApproval: {
        code: 5109,
        message: "User denied approval",
        description: "User denied approval",
        documentation: "User denied approval"
      }
    },
    vault: {
      notFound: {
        code: 5100,
        message: "Vault not found",
        description: "The vault was not found",
        documentation: "The vault was not found. Verify the vauld id"
      },
      accountNotFound: {
        code: 5101,
        message: "Vault account not found",
        // TODO make sure the error handler puts accountId in the context
        description: "{vault}: The account {account} was not found",
        documentation: "The account was not found. Verify the account name"
      },
      fetchVaultsError: {
        code: 5102,
        message: "Vaults cannot be retrieved",
        description: "An error happened while retrieveing the vaults",
        documentation: "Raised when the vaults cannot be retrieved from cede.store"
      },
      generateAccountNameError: {
        code: 5103,
        message: "An error occured while generating the account name",
        description: "An error occured while generating the account name",
        documentation: "The generate account name method shouldn't fail"
      },
      validateAccountNameError: {
        code: 5104,
        message: "An error occured while validating the account name",
        description: "An error occured while validating the account name",
        documentation: "The validate account name method shouldn't fail"
      },
      updateAccountNameError: {
        code: 5105,
        message: "An error occured while updating the account name",
        description: "An error occured while updating the account name",
        documentation: "Verify if the old account name is valid because we are using it to update the account"
      },
      getAccountError: {
        code: 5106,
        message: "An error occured while getting the account",
        description: "An error occured while getting the account",
        documentation: "Verify if the account id is valid"
      },
      getAccountsError: {
        code: 5107,
        message: "An error occured while getting the accounts",
        description: "An error occured while getting the accounts",
        documentation: "Verify if the vault id is valid"
      },
      notOAuthAccount: {
        code: 5108,
        message: "The account is not an OAuth account",
        description: "The account is not an OAuth account",
        documentation: "This error is raised when we try to perform an action on an OAuth account and the account is not using OAuth"
      }
    },
    exchange: {
      // public data, such as available tickers, tokens, etc.
      public: {
        fetchTickerFromTokenError: {
          code: 5201,
          message: "Cannot fetch ticker from token",
          description: "{vault_and_account}: An error happened while fetching tickers",
          documentation: "Raised when the ticker for a given token symbol cannot be retrieved from the CEX"
        },
        tokenNotFound: {
          code: 5202,
          message: "Token not found",
          description: "{vault_and_account}: The token {data.tokenSymbol} was not found",
          documentation: "Raised when the token cannot be found on the CEX"
        },
        marketNotFound: {
          code: 5203,
          message: "Market not found",
          description: "{vault_and_account}: The market {data.pairSymbol} was not found",
          documentation: "Raised when the market cannot be found on the CEX"
        }
      },
      // fungible and non-fungible balances (tokens, nfts, fiat)
      balances: {
        getBalancesError: {
          code: 5210,
          message: "Cannot retrieve vault portfolio from CEX",
          description: "{vault_and_account}: An error happened while fetching the portfolio from the CEX",
          documentation: "Raised when the portfolio cannot be retrieved from the CEX"
        },
        getNftFromCexError: {
          code: 5211,
          message: "NFTs cannot be fetched from CEX",
          description: "{vault_and_account}: An error happened while fetching the NFTs",
          documentation: "Raised when the NFTs cannot be retrieved from the CEX"
        }
      },
      transactions: {
        getVaultTransactionsError: {
          code: 5220,
          message: "Cannot retrieve vault transactions",
          description: "{vault_and_account}: An error happened while fetching the vault transactions",
          documentation: "Raised when the transactions cannot be retrieved from the CEX"
        }
      },
      deposit: {
        getDepositableTokensError: {
          code: 5230,
          message: "Cannot get depositable tokens",
          description: "{vault_and_account}: An error happened while fetching the depositable tokens",
          documentation: "Raised when the depositable tokens cannot be retrieved from the CEX"
        },
        getDepositAddressError: {
          code: 5231,
          message: "Cannot get deposit address",
          description: "{vault_and_account}: An error happened while fetching the deposit address",
          documentation: "Raised when the deposit address cannot be retrieved from the CEX"
        }
      },
      trade: {
        postOrderError: {
          code: 5240,
          message: "Error encountered while posting order",
          description: "{vault_and_account}: An error occured with the market order",
          documentation: "Raised when the order cannot be posted to the CEX"
        },
        fetchMarketPairsError: {
          code: 5241,
          message: "Market pairs cannot be fetched",
          description: "{vault_and_account}: An error happened while fetching the market pairs",
          documentation: "Raised when the market pairs cannot be retrieved from the CEX"
        },
        fetchAllTickersFromSymbolsError: {
          code: 5242,
          message: "Tickers cannot be fetched from symbols",
          description: "{vault_and_account}: An error happened while fetching the tickers",
          documentation: "Raised when the tickers cannot be retrieved from the CEX"
        },
        orderNotFound: {
          code: 5243,
          message: "Order not found",
          description: "{vault_and_account}: The order {data.orderId} was not found",
          documentation: "Raised when the order cannot be found on the CEX"
        },
        minAmountError: {
          code: 5244,
          message: "Minimum amount error",
          description: "{vault_and_account}: The amount should be greater than {data.minAmount}",
          documentation: "Raised when the amount is too low to execute the trade"
        },
        tickerNotFound: {
          code: 5245,
          message: "Ticker not found",
          description: "{vault_and_account}: The ticker for {data.pairSymbol} was not found",
          documentation: "Raised when the ticker cannot be found on the CEX"
        },
        invalidOrderRequest: {
          code: 5246,
          message: "Invalid order request",
          description: "{vault_and_account}: The order request is invalid: {data.error}",
          documentation: "This error is triggered by invalid order requests. It could arise due to inappropriate data inputs, such as a price set to zero. To streamline error handling, we avoid generating overly specific errors for each scenario. This approach assumes that proper data validation is performed within the dApp, ensuring user inputs are correct."
        },
        fetchMarketPriceError: {
          code: 5247,
          message: "Market rates cannot be fetched",
          description: "{vault_and_account}: An error happened while fetching market rates",
          documentation: "Raised when market rates cannot be retrieved from the CEX"
        }
      },
      network: {
        networkNotFound: {
          code: 5250,
          message: "Network not found",
          description: "The network {data.network} isn't found",
          documentation: "Raised when the network isn't found"
        },
        networkNotProvided: {
          code: 5251,
          message: "Network not provided",
          description: "The network is not provided",
          documentation: "Raised when the network is not provided, but required"
        },
        networksNotStandardized: {
          code: 5252,
          message: "Networks are not standardized",
          description: "The networks are not standardized",
          documentation: "Raised when the networks are not standardized"
        }
      },
      withdrawal: {
        tokenToDefiAddressError: {
          code: 5260,
          message: "Error encountered while withdrawing token to DeFi address",
          description: "{vault_and_account}: An error happened while withdrawing to a DeFi address",
          documentation: "Raised when the withdrawal cannot be posted to DeFi address"
        },
        tokenToAnotherCexError: {
          code: 5261,
          message: "Error encountered while withdrawing token to another CEX",
          description: "{vault_and_account}: An error happened while withdrawing to another CEX",
          documentation: "Raised when the withdrawal cannot be posted to the CEX"
        },
        notFound: {
          code: 5262,
          message: "Withdrawal not found",
          description: "The withdrawal with id {data.withdrawalId} isn't found",
          documentation: "Raised when the withdrawal isn't found"
        },
        infoError: {
          code: 5263,
          message: "Withdrawal info error",
          description: "{vault_and_account}: Withdrawal info not found",
          documentation: "Raised when the withdrawal info cannot be retrieved from the CEX"
        },
        notEnoughBalance: {
          code: 5265,
          message: "Not enough balance to withdraw",
          description: "{vault_and_account}: Not enough balance to withdraw",
          documentation: "Raised when the balance hasn't enough funds to execute the withdrawal"
        },
        underWithdrawMin: {
          code: 5266,
          message: "Amount under the minimum withdrawal amount",
          description: "{vault_and_account}: Amount under the minimum withdrawal amount",
          documentation: "Raised when the amount is under the minimum withdrawal amount"
        },
        overWithdrawMax: {
          code: 5267,
          message: "Amont over the maximum withdrawal amount",
          description: "{vault_and_account}: Amount over the maximum withdrawal amount",
          documentation: "Raised when the amount is over the maximum withdrawal amount"
        }
      },
      coinbase: {
        accountNotFound: {
          code: 5270,
          message: "Coinbase account not found",
          description: "{account}: The account for currency {data.currency} was not found",
          documentation: "Raised when the account for currency cannot be found on the CEX"
        }
      },
      binance: {
        readonlyBinanceNotProvided: {
          code: 5280,
          message: "Read-only Binance account not provided",
          description: "{account}: The read-only Binance account was not provided",
          documentation: "Raised when the read-only Binance account was not provided"
        }
      },
      register: {
        invalidExchangeId: {
          code: 5290,
          message: "Error encountered while registering an exchange instance",
          description: "Invalid exchange id",
          documentation: "Raised when the exchange id isn't recognized"
        },
        invalidExchangeInstanceId: {
          code: 5291,
          message: "Error encountered while getting an exchange instance",
          description: "Invalid exchange instance id",
          documentation: "Raised when the exchange instance id isn't recognized"
        },
        invalidCredentials: {
          code: 5292,
          message: "Error encountered while checking credentials of an exchange instance",
          description: "Invalid credentials",
          documentation: "Raised when the credentials are invalid"
        }
      },
      authentication: {
        authenticationFlowNotSupported: {
          code: 5300,
          message: "Authentication flow not supported",
          description: "Authentication flow not supported",
          documentation: "Raised when the authentication flow is not supported"
        },
        oauthFlowInterruptedByTheUser: {
          code: 5301,
          message: "Connection has been interrupted",
          description: "Connection has been interrupted",
          documentation: "Raised when the OAuth flow is interrupted by the user (e.g. user closes the authorization popup)"
        }
      }
    }
  },
  api: {
    invalidRequest: {
      code: 6e3,
      message: "Error encountered when sending a request to the api",
      description: "Request failed",
      documentation: "Raised when an API request failed"
    }
  }
};
Z.ccxt.general.cexError, Z.ccxt.general.cexApiAuthError, Z.ccxt.account.permissionDenied, Z.ccxt.account.accountSuspended, Z.ccxt.request.argumentsRequired, Z.ccxt.request.badRequest, Z.ccxt.request.badSymbol, Z.ccxt.request.badResponse, Z.ccxt.account.insufficientFunds, Z.ccxt.request.nullResponse, Z.ccxt.account.invalidAddress, Z.ccxt.order.invalidOrder, Z.ccxt.account.addressPending, Z.ccxt.order.orderNotFound, Z.ccxt.order.orderImmediatelyFillable, Z.ccxt.order.orderNotFillable, Z.ccxt.account.cancelPending, Z.ccxt.order.duplicateOrderId, Z.ccxt.general.notSupported, Z.ccxt.general.invalidNonce, Z.ccxt.request.requestTimeout, Z.ccxt.general.cexNotAvailable, Z.ccxt.general.cexOnMaintenance, Z.ccxt.request.ddosProtection, Z.ccxt.request.rateLimitExceeded;
var gu = (e2) => {
  const t = {};
  function n(s, u = "") {
    for (const d in s) {
      const l = s[d], f = u ? `${u}.${d}` : d;
      typeof l == "object" && "code" in l && typeof l.code == "number" && typeof l.documentation == "string" && typeof l.message == "string" ? t[f] = {
        code: l.code,
        message: l.message,
        documentation: l.documentation
      } : typeof l == "object" && n(l, f);
    }
  }
  return n(e2), t;
};
var Eu = gu(Z);

// node_modules/@web3-onboard/cede-store/dist/index.js
function cedeStoreWallet() {
  if (typeof window === "undefined")
    return () => null;
  return () => ({
    label: "cede.store",
    injectedNamespace: "cede",
    checkProviderIdentity: () => window.cede,
    getIcon: async () => (await import("./icon-ZZFBQH7X.js")).default,
    getInterface: async () => {
      const provider = await wu();
      if (!provider) {
        window.open("https://cede.store", "_blank");
        throw new Error("Please, install cede.store to use this wallet");
      }
      provider.once("lock", () => {
        provider.emit("accountsChanged", []);
      });
      return Promise.resolve({
        provider: createEIP1193Provider(provider, {
          eth_requestAccounts: async () => {
            const accounts = await provider.request({
              method: "connect"
            });
            if (!accounts.length) {
              return [];
            }
            const activeVault = accounts.find((account) => account.isActive);
            return [(activeVault === null || activeVault === void 0 ? void 0 : activeVault.name) || accounts[0].name];
          },
          eth_chainId: () => Promise.resolve("0x1"),
          wallet_switchEthereumChain: null,
          wallet_addEthereumChain: null,
          eth_getBalance: () => Promise.resolve("0x0"),
          eth_selectAccounts: null
        })
      });
    },
    platforms: ["desktop"]
  });
}
var dist_default = cedeStoreWallet;
export {
  dist_default as default
};
/*! Bundled license information:

@cedelabs/providers/dist/providers.mjs:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=@web3-onboard_cede-store.js.map
